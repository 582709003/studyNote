jvm在哪
    jvm在jre里，在操作系统之上（操作系统也是软件），操作系统在硬件体系之上

    jvm里面是有方法区、java栈、本地方法栈（native method stack）、堆、程序计数器；
    jvm调用本地方法接口（JNI）来调用操作系统，调用本地方法接口时会使用本地方法库；


    栈里面没有垃圾，用完就销毁了；程序计数器也没有垃圾；
    jvm调优是针对堆以及方法区进行调优，有图


    jvm内部组成(有图)
    1、classloader类加载器
        复杂加载class文件，class文件在文件开头有特定的文件按标识，并且classLoader只负责class文件加载

    2、Native interface
        本地接口的作用是融合不同的编程语言为java所用，初衷是融合C/C++程序；该方法的实现由非java语言实现；
        调用c/c++/其他本地代码,该接口提供了java与os本地代码互相调用的功能（自我理解：本地方法库是存在于我们计算机硬盘上的.dll文件）
        当java调用JNI接口时，会在执行引擎执行时加载本地方法库中的接口由非java语言写的实现体，在本地方法栈里面加载的native方法

    3、方法区
        方法区空间被所有方法共享，所有定义的方法信息都保存在这片区域，此区属于共享区间
        静态变、常量、类信息、运行时常量池存在方法区中，实例变量存在堆内存中

    4、PC Register 程序计数器
        每个线程都i有一个程序计数器，就是一个指针，指向方法区中的方法字节码（下一个将要执行的指令代码），由执行引擎执行下一条
        指令，是一个非常小的内存空间

    5、本地方法栈
        会在执行引擎执行时加载本地方法库中的接口由非java语言写的实现体，在本地方法栈里面加载的native方法

    6、栈
        栈也叫内存，主管java程序运行，在线程创建时创建，他的生命周期和线程是一致的，线程一结束该栈就over；基本类型的变量和对象的引用变量
        都在栈中分配；栈中存储 本地变量：输入参数，输出参数以及方法内的变量；栈操作：记录出栈，入栈的操作；栈帧数据：包括类文件(入参可能是引用对象)、方法等
        这里可能会出现栈溢出异常   stackOverFlowError


jvm优化在哪里
    方法区和堆是线程共同享有的，这是jvm优化的内存区；

    jvm其实是一种规范，他的具体实现其实是有七种，其中sun公司实现的jvm叫hotspot，平常如果我们称的jvm就默认是sun公司的；

    堆
        由三个区组成：新生区、养老区和永久存储区

        新生区由伊甸区、幸存0区和幸存1区；新生区是类的诞生、成长和消亡的区域，一个类在这里诞生，应用，最后被垃圾回收器结束生命
        新生区又分为两个部分：伊甸区和幸存者区，所有的类都是在伊甸区被new出来，幸村区有两个，0区和1区，，当伊甸区空间用完时，
        程序又要创建对象，jvm垃圾回收器将对伊甸园区进行垃圾回收，将伊甸区里的没有对象引用的对象进行销毁，然后将伊甸区的剩余对象移到幸存0区，
        如果0区满了就移动到1区；如果1区满了，在移动到养老区，如果养老区也满了，那么这时候将产生Gc（fullGc），进行养老区的内存清理，
        若养老区执行了full gc之后发现依然无法进行对象的保存，就会产生outOfMemoryError: Java heap space说明java虚拟机的堆内存不够，原因有二：
        1、java虚拟机的堆内存设置不够，可以通过-xms、-xmx来调整
        2、代码中创建了大量的大对象，并且长时间不能被垃圾回收器收集(存在被引用)
           System.out.println(Runtime.getRuntime().maxMemory()/1024/1024);这个可以查看jvm可用的最大内存
           byte[] b = new byte[1024 * 1024 * 2000];这个就可能发生内存溢出错误;需要占用大量连续内存空间的jaa对象是大对象，比如很长的字符串和数组

        养老区
            养老区用于保存从新生区筛选出来的java对象，一般池对象都在这个区域活跃

        永久区
            永久区是一个常驻内存区域，用于存放jdk所携带的class，interface的元数据，也就是说他存储的运行环境必须的类信息，被装载
            进此区域的数据是不会垃圾回收器回收掉的，关闭jvm才会释放此区域占用的内存
            如果产生outOfMemoryError:permGen space,说明是java虚拟机对永久代内存设置不够。一般出现这种情况，都是程序
            启动需要大量的第三方jar包。例如在一个tomcat下部署了太多的应用，或者大量的动态反射生成的类不断被加载，最终导致permGen占满

