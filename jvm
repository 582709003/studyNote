jvm
    位置：
        jvm在jre里，在操作系统之上（操作系统也是软件），操作系统在硬件体系之上，它与硬件没有直接交互

    作用：java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行（编译完后，
        字节码文件不用在不同操作系统平台做不同的编译，因为同一个字节码文件放在不同的操作系统，有不同的操作系统的jvm，这样就可以将同一个
        字节码文件翻译成不同的可以被不同操作系统识别的字节码指令，由操作码和操作数，字节码指令再转换成机器指令，是唯一可以被cpu识别的指令）。每一条java字节码指令，java虚拟机
        规范中都有详细的定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。

    特点：一次编译，到处运行；自动内存管理；自动垃圾回收功能；

    java执行过程：java源码--java前端编译器（javac命令）--生成字节码文件--类装载器加载到jvm---字节码校验器---翻译字节码指令或者编译进而生成机器
    指令（JIT编译器主要负责将热点代码即时编译成机器指令并且缓存到方法区，因为使用频率较高，如果每一次都解释的话效率不高）

    javap -v Test.class 反编译class文件得到指令语言

    总结：由于跨平台性设计，java的指令都是根据栈来设计的，优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的
          功能需要更多的指令


    jvm生命周期
        虚拟机的启动：java虚拟机的启动是通过引导类加载器（bootStrap class loader）加载一个初始类来完成的，这个类由虚拟机的具体
        实现（如hotpot或者jrocket的虚拟机）指定的；

        虚拟机的执行：一个运行的java虚拟机有一个清晰的任务，执行java程序；
                    程序开始执行时他才运行，程序结束时他就停止；
                    执行一个所谓的java程序时，真真正正执行的是一个叫做java虚拟机的进程；

        虚拟机的退出：程序正常执行结束；
                    程序在执行过程中遇到了异常或错误而正常终止；
                    由于操作系统出现错误而导致java虚拟机的进程终止；
                    System类的exit方法；
                    JNI也可以加载或卸载jvm；

类的加载过程
    类的加载
        加载器类型：
            BootStrap classLoader：引用类加载器  非java语言编写的，核心类库(jre/lib/rt.jar、resources.jar、sun.boot.class.path路劲下的内容)
                                   使用引导类加载器进行加载，用于提供jvm自身需要的类；不继承classLoader,没有父加载器；
                                   加载扩展类和应用类类加载器，并指定为他们的父类加载器；出于安全考虑，引导类只加载包名为java、javax、sun等开头的类
                                   URL[] urLs = Launcher.getBootstrapClassPath().getURLs();
                                           for (int l = 0; l < urLs.length; l++) {
                                               System.out.println(urLs[l]);
                                           }
                                           获取加载的类的路径

            Extension classLoader：扩展类加载器  java语言编写，由ExtClassLoader实现；父类加载器为启动（引导）类加载器；从java.ext.dirs系统属性所指定的目录中加载类库
                                    或从jdk的安装目录jre/lib/ext子目录下加载类库；如果用户创建的jar放在
                                    此目录下，也会自动由扩展类加载器加载

            Appliction classLoader:应用加载器  java语言编写，由AppClassLoader实现；父类加载器为启动（引导）类加载
                                                自定义类使用系统/应用类加载器进行加载  他负责加载环境变量classpath或
                                              系统属性 java.class.path 指定路径下的类库；
                                              该类加载是程序中默认的类加载器，一般来说，java应用的类都是由他加载；
                                               ClassLoader.getSystemClassLoader() 可以获得这个加载器

                    注意：jvm规范认为间接或直接继承了classLoader类的加载器都属于自定义类加载器

            双亲委派机制：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类加载器器
                        去加载；如果父类加载器还存在父类加载器，则进一步向上委托，以此递归，最终到引导类加载器；
                        如果父类加载器可以完成加载则返回，如果不能加载就返回给子类加载器加载

    类的主动使用和被动使用
        主动使用：
            1、创建类的实例
            2、访问某个类和接口的静态变量，或者对该变量的赋值
            3、调用类的静态方法
            4、反射（Class.forName("com.xxx.xxx")）
            5、初始化一个类的子类，父类就会被加载
            6、java虚拟机启动时被标注为启动类的类
            7、

         被动使用：除以上情况外的所有对类的使用都是被动使用，且不会导致类的初始化，即不会执行<clinit>方法

   ding()：
               1、通过一个类的全限定名获取定义此类的二进制字节流；
               2、将这个字节流所代表的静态存储结构（字节数组）转化为方法区的运行时数据结构
               3、在内存中生成一个代表这个类的java.lang.Class对象，作为这个类的各种数据的访问入口

     类的链接
        verify---prepare---resolve
        verify(验证)：目的在于确保class文件的字节流中包含的信息符合当前虚拟机的要求，保证被加载的正确性。
                    主要有四种验证：文件格式验证、元数据验证、字节码验证、符合引用验证
        prepare(准备)：为静态变量分配内存并且设置该静态变量的默认初始值，即零值；
                      这里不包含用final修饰的static，因为final在编译的时候就已经会分配了，准备阶段会显式的初始化；
                      这里不会为实例变量分配初始化，静态变量会分配在方法区中，而实例变量会随着new对象一起分配到堆中
        resolve(解析)：将常量池内的符号引用转换为直接引用的过程；实际上，解析操作往往会伴随着jvm在执行完初始化之后再执行
     初始化
        初始化阶段就是执行类构造器方法(这个不是我们常说的构造器)<clinit>()的过程。
        此方法不需要我们定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。
        构造器方法中指令按语句再与那文件中出现的顺序执行。
        子类在加载clinit前会先加载父类的；一个类只会加载一次


     类的加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识；如果加载出现问题就会报错；
     classloader只负责class文件的加载，至于他是否可以运行，由执行引擎决定；






     加载的类信息存放于方法区










    jvm里面是有方法区、java栈、本地方法栈（native method stack）、堆、程序计数器；
    jvm调用本地方法接口（JNI）来调用操作系统，调用本地方法接口时会使用本地方法库；


    栈里面没有垃圾，用完就销毁了；程序计数器也没有垃圾；
    jvm调优是针对堆以及方法区进行调优，有图


    jvm内部组成(有图)
    1、classloader类加载器
        复杂加载class文件，class文件在文件开头有特定的文件按标识，并且classLoader只负责class文件加载
        什么是类的加载
            类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，
            用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，
            并且向Java程序员提供了访问方法区内的数据结构的接口。
    2、Native interface
        本地接口的作用是融合不同的编程语言为java所用，初衷是融合C/C++程序；该方法的实现由非java语言实现；
        调用c/c++/其他本地代码,该接口提供了java与os本地代码互相调用的功能（自我理解：本地方法库是存在于我们计算机硬盘上的.dll文件）
        当java调用JNI接口时，会在执行引擎执行时加载本地方法库中的接口由非java语言写的实现体，在本地方法栈里面加载的native方法

    3、方法区
        方法区空间被所有方法共享，所有定义的方法信息都保存在这片区域，此区属于共享区间
        静态变、常量、类信息、运行时常量池存在方法区中，实例变量存在堆内存中； 方法区和堆一样，是各个内存共享的内存区域，它用于虚拟机加载的类信息、普通常量、静态常量、编译器编译后的代码等等，对于hotpot虚拟机，
        很多开发者习惯将方法区称为永久代，但严格本质上说两者不同，或者说使用永久代实现方法区而已，永久代是方法区的一个实现，jdk1.7的版本中，
        已经将原本方法区的字符串常量池移到堆里面，1.8版本中，已经移到元空间中；
        常量池是方法去的一部分，class文件除了有类的版本，字段、方法
        接口等描述信息外，还有一项信息就是常量池，这部分信息将在类加载后进入方法区的运行时常量池中存放

    4、PC Register 程序计数器
        每个线程都有一个程序计数器，就是一个指针，存储的是下一个要执行的指令的地址，指向方法区中的方法字节码（下一个将要执行的指令代码），
        由执行引擎区pc计数器里取下一条指令的地址然后找到指令进行执行下一条指令，是一个非常小的内存空间；


    5、本地方法栈
        会在执行引擎执行时加载本地方法库中的接口由非java语言写的实现体，在本地方法栈里面加载的native方法

    6、栈
        栈也叫内存，主管java程序运行，在线程创建时创建，他的生命周期和线程是一致的，线程一结束该栈就over；基本类型的变量和对象的引用变量
        都在栈中分配；栈中存储 本地变量：输入参数，输出参数以及方法内的变量；栈操作：记录出栈，入栈的操作；栈帧数据：包括类文件(入参可能是引用对象)、方法等
        这里可能会出现栈溢出异常   stackOverFlowError


jvm优化在哪里
    方法区和堆是线程共同享有的，这是jvm优化的内存区；

    jvm其实是一种规范，他的具体实现其实是有七种，其中sun公司实现的jvm叫hotspot，平常如果我们称的jvm就默认是sun公司的；

    堆
        由三个区组成：新生区、养老区和永久存储区

        新生区由伊甸区、幸存0区和幸存1区；新生区是类的诞生、成长和消亡的区域，一个类在这里诞生，应用，最后被垃圾回收器结束生命
        新生区又分为两个部分：伊甸区和幸存者区，所有的类都是在伊甸区被new出来，幸村区有两个，0区和1区，，当伊甸区空间用完时，
        程序又要创建对象，jvm垃圾回收器将对伊甸园区进行垃圾回收，将伊甸区里的没有对象引用的对象进行销毁，然后将伊甸区的剩余对象移到幸存0区，
        如果0区满了就移动到1区；如果1区满了，在移动到养老区，如果养老区也满了，那么这时候将产生Gc（fullGc），进行养老区的内存清理，
        若养老区执行了full gc之后发现依然无法进行对象的保存，就会产生outOfMemoryError: Java heap space说明java虚拟机的堆内存不够，原因有二：
        1、java虚拟机的堆内存设置不够，可以通过-xms、-xmx来调整
        2、代码中创建了大量的大对象，并且长时间不能被垃圾回收器收集(存在被引用)
        大对象是直接进入老年代的

           System.out.println(Runtime.getRuntime().maxMemory()/1024/1024);这个可以查看jvm可用的最大内存
           byte[] b = new byte[1024 * 1024 * 2000];这个就可能发生内存溢出错误;需要占用大量连续内存空间的jaa对象是大对象，比如很长的字符串和数组

        养老区
            养老区用于保存从新生区筛选出来的java对象，一般池对象都在这个区域活跃

        永久区
            永久区是一个常驻内存区域，用于存放jdk所携带的class，interface的元数据，也就是说他存储的运行环境必须的类信息，被装载
            进此区域的数据是不会垃圾回收器回收掉的，关闭jvm才会释放此区域占用的内存
            如果产生outOfMemoryError:permGen space,说明是java虚拟机对永久代内存设置不够。一般出现这种情况，都是程序
            启动需要大量的第三方jar包。例如在一个tomcat下部署了太多的应用，或者大量的动态反射生成的类不断被加载，
            最终导致permGen占满


        堆内存调优简介
            -Xms  设置初始分配大小，默认为物理内存的 1/64
            -Xmx  最大分配内存，默认为物理分配内存的 1/4
            -XX:PrintGCDetails 输出详细的GC处理日志

            Runtime.getRuntime().maxMemory()//返回java虚拟机试图使用的最大内存量
            Runtime.getRuntime().totalMemory()//返回java虚拟机中的当前的内存总量

       jvm在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分的时候回收都是指新生代。
       因此GC按照回收的区域又分了两种类型，一种是普通GC(minor GC),一种是全局GC(major GC or Full GC),
       普通GC只针对新生代区，全局GC针对老年代的GC，偶尔伴随对新生代的GC以及对永久代的GC


       GC算法总体概述:
           复制算法：MinorGC
            zaiGC开始的时候，对象只会存在Eden区和名为From的Survivor区，Survivor区To是空的，紧接着进行GC，Eden区中所有存活的对象
            都会被复制到to，而在from区，仍存活的对象会根据他们的年龄值来决定去向，年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)
            的对象会被移送到老年代中，没有达到阈值的对象会被复制到to区；经过这次GC后，Eden区和from区已经被清空，这个时候from区和to区会
            交换他们的角色，即from变成to，to变成from，不管怎样，都会保证to区是空的，Minor GC会一直重复这样的过程，直到to区被填满，to区被填满后，
            会将所有对象移动到老年代中。一般eden区内存和两个Survivor区内存是8：1：1；

            优点：不会产生内存碎片，完整度高
            缺点：浪费了10%的内存


           标记清除/标记整理算法：FullGC又叫MajorGC
             标记：从根集合开始扫描，对存活对象进行标记
             清除：扫描整个内存空间，回收未被日标记的对象

             缺点：效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址，从效率上来说，标记/整理算法要低于复制算法



















