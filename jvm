jvm
    位置：
        jvm在jre里，在操作系统之上（操作系统也是软件），操作系统在硬件体系之上，它与硬件没有直接交互

    作用：java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行（编译完后，
        字节码文件不用在不同操作系统平台做不同的编译，因为同一个字节码文件放在不同的操作系统，有不同的操作系统的jvm，这样就可以将同一个
        字节码文件翻译成不同的可以被不同操作系统识别的字节码指令，由操作码和操作数，字节码指令由执行引擎再转换成机器指令，是唯一可以被cpu识别的指令）。每一条java字节码指令，java虚拟机
        规范中都有详细的定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。

    特点：一次编译，到处运行；自动内存管理；自动垃圾回收功能；

    java执行过程：java源码--java前端编译器（javac命令）--生成字节码文件--类装载器加载到jvm---字节码校验器---翻译字节码指令或者编译进而生成机器
    指令（JIT编译器主要负责将热点代码即时编译成机器指令并且缓存到方法区，因为使用频率较高，如果每一次都解释的话效率不高）

    执行引擎工作其实就是将字节码指令翻译成机器指令

    javap -v Test.class 解析class文件得到指令语言(其实源码在编译成字节码文件后的效果就是字节码指令)

    总结：由于跨平台性设计，java的指令都是根据栈来设计的，优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的
          功能需要更多的指令


    jvm生命周期
        虚拟机的启动：java虚拟机的启动是通过引导类加载器（bootStrap class loader）加载一个初始类来完成的，这个类由虚拟机的具体
        实现（如hotpot或者jrocket的虚拟机）指定的；

        虚拟机的执行：一个运行的java虚拟机有一个清晰的任务，执行java程序；
                    程序开始执行时他才运行，程序结束时他就停止；
                    执行一个所谓的java程序时，真真正正执行的是一个叫做java虚拟机的进程；

        虚拟机的退出：程序正常执行结束；
                    程序在执行过程中遇到了异常或错误而正常终止；
                    由于操作系统出现错误而导致java虚拟机的进程终止；
                    System类的exit方法；
                    JNI也可以加载或卸载jvm；

类的加载过程
    类的加载
        加载器类型：
            BootStrap classLoader：引用类加载器  非java语言编写的，核心类库(jre/lib/rt.jar、resources.jar、sun.boot.class.path路劲下的内容)
                                   使用引导类加载器进行加载，用于提供jvm自身需要的类；不继承classLoader,没有父加载器；
                                   加载扩展类和应用类类加载器，并指定为他们的父类加载器；出于安全考虑，引导类只加载包名为java、javax、sun等开头的类
                                   URL[] urLs = Launcher.getBootstrapClassPath().getURLs();
                                           for (int l = 0; l < urLs.length; l++) {
                                               System.out.println(urLs[l]);
                                           }
                                           获取加载的类的路径

            Extension classLoader：扩展类加载器  java语言编写，由ExtClassLoader实现；父类加载器为启动（引导）类加载器；从java.ext.dirs系统属性所指定的目录中加载类库
                                    或从jdk的安装目录jre/lib/ext子目录下加载类库；如果用户创建的jar放在
                                    此目录下，也会自动由扩展类加载器加载

            Appliction classLoader:应用加载器  java语言编写，由AppClassLoader实现；父类加载器为启动（引导）类加载
                                                自定义类使用系统/应用类加载器进行加载  他负责加载环境变量classpath或
                                              系统属性 java.class.path 指定路径下的类库；
                                              该类加载是程序中默认的类加载器，一般来说，java应用的类都是由他加载；
                                               ClassLoader.getSystemClassLoader() 可以获得这个加载器

                    注意：jvm规范认为间接或直接继承了classLoader类的加载器都属于自定义类加载器

            双亲委派机制：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类加载器器
                        去加载；如果父类加载器还存在父类加载器，则进一步向上委托，以此递归，最终到引导类加载器；
                        如果父类加载器可以完成加载则返回，如果不能加载就返回给子类加载器加载

    类的主动使用和被动使用
        主动使用：
            1、创建类的实例
            2、访问某个类和接口的静态变量，或者对该变量的赋值
            3、调用类的静态方法
            4、反射（Class.forName("com.xxx.xxx")）
            5、初始化一个类的子类，父类就会被加载
            6、java虚拟机启动时被标注为启动类的类
            7、

         被动使用：除以上情况外的所有对类的使用都是被动使用，且不会导致类的初始化，即不会执行<clinit>方法

   loading()：
               1、通过一个类的全限定名获取定义此类的二进制字节流；
               2、将这个字节流所代表的静态存储结构（字节数组）转化为方法区的运行时数据结构
               3、在内存中生成一个代表这个类的java.lang.Class对象，作为这个类的各种数据的访问入口

     类的链接
        verify---prepare---resolve
        verify(验证)：目的在于确保class文件的字节流中包含的信息符合当前虚拟机的要求，保证被加载的正确性。
                    主要有四种验证：文件格式验证、元数据验证、字节码验证、符合引用验证
        prepare(准备)：为类变量分配内存并且设置该静态变量的默认初始值，即零值；
                      这里不包含用final修饰的static，因为final在编译的时候就已经会分配了，准备阶段会显式的初始化；
                      这里不会为实例变量分配初始化，静态变量会分配在方法区中（1.7以及之前，1.8后也在堆中），而实例变量会随着new对象一起分配到堆中
        resolve(解析)：将常量池内的符号引用转换为直接引用的过程；实际上，解析操作往往会伴随着jvm在执行完初始化之后再执行
     初始化
        初始化阶段就是执行类构造器方法(这个不是我们常说的构造器)<clinit>()的过程。
        此方法不需要我们定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。
        构造器方法中指令按语句再与那文件中出现的顺序执行。
        子类在加载clinit前会先加载父类的；一个类只会加载一次


     类的加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识；如果加载出现问题就会报错；
     classloader只负责class文件的加载，至于他是否可以运行，由执行引擎决定；






     加载的类信息存放于方法区










    jvm里面是有方法区、java栈、本地方法栈（native method stack）、堆、程序计数器；
    jvm调用本地方法接口（JNI）来调用操作系统，调用本地方法接口时会使用本地方法库；


    栈里面没有垃圾，用完就销毁了；程序计数器也没有垃圾；
    jvm调优是针对堆以及方法区进行调优，有图


    jvm内部组成(有图)
    1、classloader类加载器
        复杂加载class文件，class文件在文件开头有特定的文件按标识，并且classLoader只负责class文件加载
        什么是类的加载
            类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，
            用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，
            并且向Java程序员提供了访问方法区内的数据结构的接口。
    2、Java Native interface
        本地接口的作用是融合不同的编程语言为java所用，初衷是融合C/C++程序；该方法的实现由非java语言实现，并不提供实现体；
        调用c/c++/其他本地代码,该接口提供了java与os本地代码互相调用的功能（自我理解：本地方法库是存在于我们计算机硬盘上的.dll文件）
        当java调用JNI接口时，会在执行引擎执行时加载本地方法库中的接口由非java语言写的实现体，在本地方法栈里面加载的native方法

    3、方法区
        方法区空间被所有方法共享，所有定义的方法信息都保存在这片区域，此区属于共享区间
        静态变量、常量、类信息、运行时常量池存在方法区中，实例变量存在堆内存中； 方法区和堆一样，是各个内存共享的内存区域，它用于虚拟机加载的类信息、普通常量、静态常量、编译器编译后的代码等等，对于hotpot虚拟机，
        很多开发者习惯将方法区称为永久代，但严格本质上说两者不同，或者说使用永久代实现方法区而已，永久代是方法区的一个实现，jdk1.7的版本中，
        已经将原本方法区的字符串常量池移到堆里面，1.8版本中，已经移到元空间中；
        常量池是方法去的一部分，class文件除了有类的版本，字段、方法
        接口等描述信息外，还有一项信息就是常量池，这部分信息将在类加载后进入方法区的运行时常量池中存放;
----------------
        1、方法区还有一个别名叫“非堆”，目的就是要和堆分开；所以方法区看作是独立于java堆的内存空间；
        2、方法区和堆一样，是各个线程共享的内存区域
        3、方法区在jvm启动的时候被创建，并且他的实际的物理内存空间中和java堆区一样都可以是不连续的
        4、方法区的大小，和堆空间一样，可以是固定的也可以是可扩展的
        5、方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类(加载了大量的第三方的jar包；tomcat部署的工程过多；大量动态的生成发射类)（使用时才会加载类，否则就保留在文件系统内），
            导致方法区溢出，虚拟机同样会报内存溢出错误，OOM：PermGen space 或者 OOM：MetaSpace
        6、关闭jvm就会释放这个区域的内存

        方法区的演进
            在jdk1.7之前，习惯上把方法区称为永久代，jdk1.8后改成了元空间；本质上，方法区和永久代并不等价，仅仅是对hotspot而言；
            元空间的本质和永久代类似，都是对jvm规范中方法区的实现。不过元空间和永久代最大区别在于：元空间不在虚拟机设置的内存中，
            而是使用本地内存；

        方法区的垃圾收集主要是回收两大部分：常量池中的废弃的常量和不再使用的类(类，接口，枚举，注解)

        设置方法区大小与OOM
            方法区的大小不必是固定的，jvm可以根据应用的需要动态调整。
            jdk1.7以前：
                通过-XX:PermSize来设置永久代初始分配空间。默认值是20.75M
                通过-XX:MaxPermSize来设置永久代最大可分配空间，32位机器默认是64M，64位机器默认是82M
                当jvm加载的类信息容量超过这个值，会报OOM：PermGen
            jdk1.8以及以后：
                元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定，替代上述原有的两个参数。
                默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。

                与永久代不同，如果不指定大小，默认情况下，虚拟机会耗用所有的系统可用内存。如果元数据区发生溢出，虚拟机一样抛出异常
                OOM:Metaspace;

                -XX:MetaspaceSize:设置初始的元空间大小，对于一个64位的服务器端jvm来说，其默认的-XX:MetaspaceSize值位21m,
                这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不在存活），
                然后这个高水位线将会重置，新的高水位线的值取决于GC后释放了多少元空间，如果释放的元空间不足，那么在不超过
                MaxMetaspaceSize时，适当提高该值，如果释放空间过多，则适当降低该值；

                如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次，通过垃圾回收器的日志可以观察到full GC多次调用，
                为了避免频繁GC，建议将-XX:MetaspaceSize设置为一个相对较高的值；

         如何解决这些OOM？
            1、要解决oom或者heap space的异常，一般的手段是首先通过内存映像分析工具对dump出来的堆转储快照进行分析，重点是
            内存中的对象是否是必要的，也就是弄清楚到底是出现了内存泄露(memory leak)
            (内存泄露：就是对象有引用但是没有使用，这样的对象过多导致内存溢出)还是内存溢出(memory overflow)。
            2、如果是内存泄露，可进一步通过工具查看泄露对象到GC ROOTS的引用链，于是就能找到泄露的对象是通过怎样的路径与GC ROOTS
            相关联并导致垃圾收集器无法自动回收他们的。掌握了泄露对象的类型信息，以及GC ROOTS的引用链信息，就可以比较准确的定位出泄露代码的
            准确位置。
            3、如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须是活着的，那就应当检查jvm的堆参数(-Xmx 与-Xms)，与机器物理内存
            对比看，是否还可以调大，从代码上检查某些对象周期过长

        方法区的内部结构
            静态变量、字符串常量池、类信息、运行时常量池存在方法区中（jdk1.8及以后），代码缓存（jit编译后的机器码）
                类信息
                    类型信息：
                        对每个加载的类(包括类，接口，枚举，注解)，jvm必须在方法区存储以下类型信息
                        1、这个类的完整有效名称（包名加类名）
                        2、这个类的直接父类的完整有效名称（接口和object没有父类）
                        3、这个类的修饰符
                        4、这个类直接接口的一个有序列表(就是给实现的直接接口排个顺序，并且记录到有序列表)
                    域(属性)信息：
                        jvm必须在方法区中保存类的所有域的相关信息以及域的声明顺序。
                        域的相关信息包括：域名称、域类型、域的所有修饰符
                        static final修饰的变量在编译期就已经附上值了
                    方法（method）信息
                        jvm必须保存所有方法的以下信息
                            1、方法名称
                            2、方法的返回类型
                            3、方法的参数数量和类型(或void)
                            4、方法的修饰符
                            5、方法的字节码，操作数栈、局部变量表、以及形参的大小(abstract和native方法除外)
                            6、异常表(abstract和native方法除外)，每个异常处理的开始位置，结束位置，代码处理在程序计数器中的偏移地址、
                                被捕捉的异常类的常量池索引
                运行时常量池
                    jdk1.8之后，无永久代，本地信息、字段、方法，常量保存在本地内存的元空间，但字符串常量池、静态变量
                    (就是引用地址以及实际内存都是在堆里)仍存在堆里；

                    为什么字符串常量池移到堆里存放？
                        因为原先放在永久代里的话，永久代因为回收效率较低，只有在full gc时才会触发，而full gc只有在老年代、
                        永久代空间不足时才会触发，这就导致字符串常量池回收效率不高，放在堆里能及时被回收。


                    自我理解：程序中的变量名在内存中其实是以内存地址（引用类型）或者直接以数值（基本数据类型）存在；
                    静态变量放在哪里？
                        静态引用对应的对象始终都存在堆空间

                方法区的垃圾收集器主要回收两方面内容 常量池和不再使用的类型
                先来说说方法区内常量池中主要存放的两大类常量:字面量和符号引用
                字面量比较接近JAVA语言的常量概念，如文本字符串和被final修饰的常量值；而符号引用则属于编译原理方面的概念，包括下面三类常量
                    1、类和接口的全限定名
                    2、字段的名称和描述符
                    3、方法的名称和描述符
                回收的策略：只要方法区中的常量没有被任何地方引用，就可以被回收

            判定一个类型是否属于不再被使用的类的条件就比较苛刻了，需要同时满足下面三个条件
            1、该类所有的实例都已经被回收，包括派生的子类对象
            2、加载该类的类加载器已经被回收
            3、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
            java虚拟机对满足上述的三个条件的无用类及逆行回收，但是仅仅是被允许，而不是必然会被回收；关于是否对类型进行回收，
            hospot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:TraceClass-Loaading、-XX:TraceClass-Unloaading
            查看类加载和卸载信息
            在大量使用反射、动态代理、CGlib等字节码框架等频繁自定义类加载器的场景中，通常都需要虚拟机具备类型卸载的能力，以保证不会
            堆方法区造成过大的压力

                运行时常量池vs常量池
                    方法区中有一个运行时常量池
                    字节码文件中有一个常量池；
                    字节码文件在被加载到jvm后常量池就到了方法区的运行时常量池

                    常量池：
                        一个有效的字节码文件中除了包含类的版本信息，字段，方法，以节接口等描述信息外，还包含一项信息
                        那就是常量池表，用于存放编译器生成的各种字面值和对类型、域和方法的符号引用；
                        注意：
                            如果int类型的数值如果比较简单的话，是不会将该值放入常量池中的，可以直接通过JVM指令将值赋值给相应字段；
                            bipush 将单字节的常量值(-128~127)推送至栈顶
                            sipush 将一个短整型常量值(-32768~32767)推送至栈顶
                            该系列命令负责把一个整形数字（长度比较小）送到到栈顶。该系列命令有一个参数，用于指定要送到栈顶的数字。
                            注意该系列命令只能操作一定范围内的整形数值，超出该范围的使用将使用ldc命令系列。
                            看到这里我们就恍然大悟了，原来JVM字节码的指令是可以存储一定范围的值的，不需要将该范围内的值放置到常量池当中，然后搞个索引指向常量池中；
                            我们将int的值设置为32768，大于short型的最大值，可以看到，int型的数值出现在了常量池当中。


                        为什么要常量池？
                            使用常量池使用符号引用会大大减少字节码文件的大小，同一个字面值也不用创建多个；
                        常量池有什么？
                            数量值
                            字符串值
                            类引用
                            字段引用
                            方法引用
                     运行时常量池
                        是方法区的一部分；字节码文件在被加载到jvm后常量池就到了方法区的运行时常量池;
                        在加载类和接口到虚拟机后，就会创建对应的运行时常量池。
                        运行时常量池中包含多种不同的常量，包括编译期间就已经明确的数值字面量(static final修饰的变量在编译期间就已赋值了)




    4、PC Register 程序计数器
        每个线程都有一个程序计数器，就是一个指针，存储的是下一个要执行的指令的地址，指向方法区中的方法字节码（下一个将要执行的指令代码），
        由执行引擎区pc计数器里取下一条指令的地址然后找到指令进行执行下一条指令，是一个非常小的内存空间；
        为什么使用pc计数器记录当前线程的执行地址呢？
        因为cpu需要不停的切换各个线程，这时候切换回来之后们就得知道从哪继续执行；
        jvm的字节码解释器就需要通过改变pc计数器的值来明确下一条应该执行什么样的字节码指令

    5、本地方法栈
        会在执行引擎执行时加载本地方法库中的接口由非java语言写的实现体，在本地方法栈里面加载的native方法；





    6、栈
        栈也叫内存，主管java程序运行，程序如何运行，是运行时的单位，在线程创建时创建，他的生命周期和线程是一致的，
        线程一结束该栈就over；基本类型的变量和对象的引用变量，部分结果都在栈中分配；栈中存储 本地变量：输入参数，
        输出参数以及方法内的变量；栈操作：记录出栈，入栈的操作；栈帧数据：包括类文件(入参可能是引用对象)、方法等，
        并参与方法得调用和返回
        这里可能会出现栈溢出异常   stackOverFlowError

        java虚拟机规范允许java栈的大小是动态的或者是固定不变的；
            如果采用固定大小，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定，如果线程请求分配的栈容量超过
            java虚拟机栈容量允许的最大量java虚拟机将会抛出一个stackOverFlowError
            如果采用动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存时，java虚拟机会抛出
            outOfMemoryError

        如何设置栈的大小
            我么可以使用参数-Xss来设置线程的最大栈空间,默认单位字节，栈的大小直接决定了函数调用的最大可达深度
            -Xss1024k
            -Xss1m
            -Xss1048576
        每个线程都有自己的栈，栈中的数据都是以栈帧的格式保存，在这个线程上正在执行的每个方法都各自对应着一个栈桢，
        栈帧是一个内存块，是一个数据集；
        不同线程所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧；
        如果当前的方法调用了其他方法，方法返回之际，当前栈帧会返回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，
        使得前一个栈帧重新成为当前栈帧；
        如果方法出现异常，并且没有处理的话，会导致栈帧弹出；

        栈的结构：
            栈帧中存储着：
               1、局部变量表
                定义为一个数字数组，主要用于存储方法参数何定义在方法体内的局部变量值，是值，不是变量名，这些数据也包括各类基本数据类型，对象引用以及
                返回地址（returnAdrees）类型;
                局部变量表所需的容量大小是在编译期就已经确定下来的，并保存在方法的code属性的maximum local variables数据项中
                在运行期是不会改变局部变量表的大小的

                方法嵌套调用的次数由栈的大小决定，一般来说，栈越大，方法嵌套次数越多；
                局部变量中的变量只在当前方法调用中有效，在方法执行时，虚拟机通过局部变量表完成参数值到参数变量列表的传递过程。
                当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁；

                非静态方法默认第一个局部变量就是当前对象 this

                关于slot的理解
                    参数值的存放总是在局部变量数组index0开始，到数组长度-1索引结束
                    局部变量表最基本的但愿是slot(变量槽)
                    局部变量表中存放编译器可知的各种基本数据类型，引用类型，returnAddress类型的变量；
                    在局部变量表中，32位类型只占用一个slot(包括returnAddress类型)，64位的类型(long和double)占用两个slot
                    byte short char 在存储前被转换成int，boolean也被转为int，0表示false，非0表示true；
                    long和double则占据两个slot;
                    jvm会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中的局部变量值；
                    当一个实例方法被调用时，他的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上；
                    如果需要访问局部变量表中的一个64位的局部变量值时，只需要使用前一个索引即可；
                    如果当前栈帧是由构造方法或者实例方法创建的，那么该对象的引用this将会放在index为0的slot处，
                    其余的参数按照参数表顺序继续排列；


               2、操作数栈（或表达式栈）
                每一个独立的栈帧中除了包好局部变量表外，还包含一个后进先出的操作数栈；操作数栈在方法执行过程中，根据字节码指令
                往栈中写入数据或提取数据即压栈和弹栈。
                操作数栈主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。
                操作数栈就是jvm执行引擎的一个工作区，当一个方法执行的时候，一个新的栈帧也会被创建出来，这个方法的操作数栈就是空的；
                每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期间就已经确定了，保存在code属性
                的max_stack中；
                栈中的任何元素都可以是任意的java 数据类型
                32bit类型占用一个栈单位深度
                64bit类型占用两个栈单位深度
                操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的出栈和出栈操作来完成一次数据访问；

（这玩意就是指令地址）0 iconst_2  //将2存放到操作数栈(临时存储)，入栈
                1 istore_1  //将2取出并且存放到局部变量里，此时操作数栈就空了，出栈
                2 iconst_3  //将3存放到操作数栈(临时存储)，入栈
                3 istore_2  //存放到局部变量里，此时操作数栈就空了，出栈
                4 iload_1   //从局部变量表里取出来并且放到操作数栈
                5 iload_2   //从局部变量表里取出来并且放到操作数栈
                6 iadd      //将两个数取出来经过执行引擎的解释成机器指令，并拿到cpu进行计算，将结果又放到操作数栈
                7 istore_3  //将执行结果存放到局部变量
                8 return
                工作过程理解：经过执行引擎
                的翻译成机器指令，到cpu执行之后得到数据，再将数据压倒操作数栈里数据送到局部变量

                 如果被调用的方法有返回值，其返回值将会被压入当前栈帧的操作数栈中，并更新pc计数器中下一条需要执行的字节码指令；
                 public int getSum(){
                       int j = 2;
                       int k = 3;
                       int i = j + k;
                       return i;
                   }
                    0 iconst_2
                    1 istore_1
                    2 iconst_3
                    3 istore_2
                    4 iload_1
                    5 iload_2
                    6 iadd
                    7 istore_3
                    8 iload_3
                    9 ireturn


                   public void testGetSum(){
                       int i = getSum();
                       int j = 10;
                   }

                    0 aload_0  //直接将getsum方法的返回值加载到操作数栈中
                    1 invokevirtual #2 <com/sjd/controller/Test.getSum>
                    4 istore_1
                    5 bipush 10
                    7 istore_2
                    8 return




               3、动态链接 （或指向运行时常量池的方法引用）
                在java源文件被编译到字节码文件时，在调用时，所有的属性和方法的引用都作为符号引用保存在class文件的常量池里，
                比如一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用
                就是为了将这些符号引用转换为调用方法的引用；当jvm运行时，会将保存在class文件里的常量池放到方法区的常量池；

                为什么需要常量池?
                为了提供一些符号和常量，便于指令的识别
                jvm在运行程序时，会将变量以及方法的引用都作为常量存到常量池并分配一个符号引用，这样；
                class文件还比较小，用指令作为调用符号；

                      int num = 20;
                       public void methodA(){
                           System.out.println("Test.methodA");
                       }
                        解析后：
                        0 getstatic #3 <java/lang/System.out>  （这个就是具体指代常量池中代表的）
                        3 ldc #4 <Test.methodA>
                        5 invokevirtual #5 <java/io/PrintStream.println>
                        8 return


                       public void methodB(){
                           System.out.println("Test.methodB");
                           methodA();
                           num++;
                       }

                    解析后：
                     0 getstatic #3 <java/lang/System.out>
                     3 ldc #6 <Test.methodB>
                     5 invokevirtual #5 <java/io/PrintStream.println>
                     8 aload_0
                     9 invokevirtual #7 <com/sjd/controller/Test.methodA>
                    12 aload_0
                    13 dup
                    14 getfield #2 <com/sjd/controller/Test.num>
                    17 iconst_1
                    18 iadd
                    19 putfield #2 <com/sjd/controller/Test.num>
                    22 return
              方法的调用：
                在jvm中，经符号引用转换为调用方法的直接引用与方法的绑定机制有关
                    静态绑定
                        当一个字节码文件被装载进jvm内部时，如果被调用的方法在编译期可知，且运行期保持不变，这种情况下将调用方法的
                        符号引用转换为直接引用的过程称之为静态绑定
                    动态绑定
                        如果被调用方法在编译期间无法被确定下来，也就是说，只能够在程序运行期间将调用方法的符号引用转换为直接引用，
                        由于这种转换过程具有动态性，因此被称之为动态绑定。

                        理解：具有多态的或者子类的方法时，使用父类或者接口调用方法时，这时在编译期就不能确定调用的是父类还是子类，
                        这就是晚期绑定，或者也就是动态绑定；
                    如果在java中不希望某个函数用友虚函数的特征时，可以使用final来标注这个方法
                    非虚方法有哪些
                        静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法
                    其它称为虚方法
                    子类对象的多态性的使用前提：1、有类的继承关系 2、方法重写了

                    方法的调用：关于invokedynamic指令
                        invokedynamic指令，这是java为了实现【动态类型语言】支持而做的一种改进
                        但是在 java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM底层字节码工具来产生invokedynamic指令，
                        知道lambda表达式的出现，invokedynamic指令的生成，在java中才有了直接生成方式；

                        动态类型语言和静态类型语言：
                            区别在于对类型的检查是在编译期间还是运行期间，满足前者就是静态类型语言，反之就是动态类型语言；
                            再直白一点就是：静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，
                            变量值才有类型信息，这是动态语言的一个重要特征

               4、方法返回地址（或方法正常退出或者异常退出的定义）
                    存放调用该方法的pc寄存器的值；本质上，方法的退出就是当前栈帧出栈的过程，此时，需要回复上层方法的局部变量表，操作数栈、
                    将返回值压入调用者栈帧的操作数栈，设置pc寄存器值等，让调用者方法继续执行下去。
                    正常完成和异常退出的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值



               5、一些附加信息
                    忽略



jvm优化在哪里   方法区和堆是线程共同享有的，这是jvm优化的内存区；
    一个进程对应着一个jvm实例，一个jvm实例对应着一个运行时数据区，一个运行时数据区只有一个堆和方法区；
    jvm其实是一种规范，他的具体实现其实是有七种，其中sun公司实现的jvm叫hotspot，平常如果我们称的jvm就默认是sun公司的；

    查看jvm内存使用情况的工具：C:\Program Files\Java\jdk1.8.0_131\bin\jvisualvm.exe
    在方法结束后，堆中的对象不会被马上移除，仅仅在垃圾收集的时候才会被移除。堆是GC执行垃圾回收的重点区域；
    堆
        是存储的单位，数据怎么存放，放在哪；由三个区组成：新生区、养老区和永久存储区

        新生区由伊甸区、幸存0区和幸存1区；新生区是类的诞生、成长和消亡的区域，一个类在这里诞生，应用，最后被垃圾回收器结束生命
        新生区又分为两个部分：伊甸区和幸存者区，所有的类都是在伊甸区被new出来，幸村区有两个，0区和1区，，当伊甸区空间用完时，
        程序又要创建对象，jvm垃圾回收器将对伊甸园区进行垃圾回收，将伊甸区里的没有对象引用的对象进行销毁，然后将伊甸区的剩余对象移到幸存0区，
        如果0区满了就移动到1区，此时伊甸园区是空的；如果1区满了，在移动到养老区，如果养老区也满了，那么这时候将产生Gc（fullGc），进行养老区的内存清理，
        若养老区执行了full gc之后发现依然无法进行对象的保存，就会产生outOfMemoryError: Java heap space说明java虚拟机的堆内存不够，原因有二：
        1、java虚拟机的堆内存设置不够，可以通过-xms、-xmx来调整
        2、代码中创建了大量的大对象（内存连续的且较大的对象，例如较长字符串，数组），并且长时间不能被垃圾回收器收集(存在被引用)

        如果new的对象伊甸园区放不下去，就直接放入老年代的；老年代也放不下，那老年代就进行fullGC，如果gc完还放不下，那就outofmemoryerror吧

           System.out.println(Runtime.getRuntime().maxMemory()/1024/1024);这个可以查看jvm可用的最大内存
           byte[] b = new byte[1024 * 1024 * 2000];这个就可能发生内存溢出错误;需要占用大量连续内存空间的jaa对象是大对象，比如很长的字符串和数组

        养老区
            养老区用于保存从新生区筛选出来的java对象，一般池对象都在这个区域活跃

        永久区
            永久区是一个常驻内存区域，用于存放jdk所携带的class，interface的元数据，也就是说他存储的运行环境必须的类信息，被装载
            进此区域的数据是不会垃圾回收器回收掉的，关闭jvm才会释放此区域占用的内存
            如果产生outOfMemoryError:permGen space,说明是java虚拟机对永久代内存设置不够。一般出现这种情况，都是程序
            启动需要大量的第三方jar包。例如在一个tomcat下部署了太多的应用，或者大量的动态反射生成的类不断被加载，
            最终导致permGen占满


        堆内存调优简介
           堆空间设置大小
            -Xms  设置初始分配大小，默认为物理内存的 1/64  不涉及永久代区
            -Xmx  最大分配内存，默认为物理分配内存的 1/4  不涉及永久代区
            开始发设置中建议将初始堆内存和最大堆内存设置成相同的值，否则频繁扩容造成系统压力


            Runtime.getRuntime().maxMemory()//返回java虚拟机试图使用的最大内存量
            Runtime.getRuntime().totalMemory()//返回java虚拟机中的当前的内存总量，初始内存

            查看设置的参数：方式一 jps  /  jstat -gc 进程id
                          方式二 -XX:PrintGCDetails 输出详细的GC处理日志

            配置新生代与老年代在堆结构中的占比
                默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3  （不包含永久代）
                可以修改-XX:NewRatio =4,表示新生代占1，老年代占4，新生代整个堆的1/5 （不包含永久代）

            -XX:SurvivorRatio 用来调整新生代中的伊甸区和两个幸存区的比例，默认比例时8:1:1

       对象分配过程：概述


       jvm在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分的时候回收都是指新生代。
       因此GC按照回收的区域又分了两种类型，一种是普通GC(minor GC),一种是全局GC(major GC or Full GC),
       普通GC只针对新生代区里的伊甸园区，伊甸园区满的时候会触发minor GC，幸存区满不会触发minor GC；
       但是不意味着没有垃圾回收，当伊甸园区满的时候会将幸存者区也连带回收；
       全局GC针对老年代的GC，偶尔伴随对新生代的GC以及对永久代的GC；

       频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集


        MinorGC、MagorGC、FullGC
            jvm在进行GC时，并非每次都对上面三个内存（新生代、老年代、方法区）区域一起回收的，大部分时候回收的都是指老年代。
            针对hot spot vm的实现，它里面按照回收的区域又分为两大种类型：一种是部分收集(Partial GC),一种是整堆收集(Full GC)
            部分收集：不是完整收集整个java堆的垃圾收集。其中又分为：
                新生代收集(Minor GC),只是新生代(eden\s0\s1)的垃圾收集
                    触发机制：当新生代空间不足时，会触发  Minor GC，这里的新生代满指的是Eden代满，幸存区满不会触发GC（每次Minor GC会清理年轻代的内存）
                            因为Java对象大多数都具有朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也比较快。
                            Minor GC会引发STW(暂停用户线程)，等垃圾回收结束，用户线程才恢复运行，因为Minor GC速度很快，对性能影响较小。

                老年代收集(Magor GC),只是老年代的垃圾收集
                    目前，只有CMS GC会有单独收集老年代的行为。
                    注意，很多时候Magor GC会和Full GC混淆使用，需要具体分辨的是老年代回收还是整堆回收。
                    触发机制：老年代空间不足时，则触发Magor GC;Magor GC的速度一般会比Minor GC慢10倍以上，STW时间更长，
                        如果Magor GC后内存还是不足，则会OOM
                混合收集(Mixed GC)，收集整个新生代以及部分老年代的垃圾收集。


            整堆收集（Full GC）:收集整个java堆和方法区的垃圾收集
                触发机制：1、调用system.gc()，系统建议执行Full GC，但是不必然执行
                         2、老年代空间不足
                         3、方法去空间不足

                         说明：full gc是开发中或调优中尽量要避免的，这样暂停时间会短一些

            堆空间的分代思想：其实不分代是完全可以的，分代的唯一理由是优化GC性能，进而快速腾出空间出来

            堆空间内存分配策略：
                1、优先分配到Eden
                2、大对象直接分配到老年代(没有经过Minor GC，直接进入了老年代)
                    尽量避免程序中出现过多大对象
                3、长期存活的对象分配到老年代
                4、动态对象年龄判断
                    如果幸存区中相同年龄的所有对象大小的总和大于幸存区空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，
                    无需等到MaxTenuringThreshold中要求的年龄。
                5、空间分配担保
                    -XX:HandlePromotionFailure

            堆空间的参数设置：
                -XX:+PrintFlagsInitial 查看所有参数的默认默认值(即使修改了，也看到的是默认值)
                -XX:+PrintFlagsFinal    查看所有参数的最终值(可能初始值被修改，这样可以查看到最终值)
                -Xms:初始堆空间内存(默认为物理内存的1/64)
                -Xmx:最大堆空间内存(默认物理内存的1/4)
                -Xmn:设置新生代的大小(初始值和最大值)
                        例：-Xmn2g：设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。
                        持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，
                        Sun官方推荐配置为整个堆的3/8
                -XX:NewRatio 配置新生代与老年代在堆结构中的占比
                -XX:SurvivorRatio   设置新生代中的Eden和S0/S1空间的比例
                -XX:MaxTenuringThreshold    设置新生代中垃圾的最大年龄
                -XX:PintGcDetails   输出详细的GC处理日志
                -XX:HandlePromotionFailure 是否设置空间分配担保

        堆是分配对象存储的唯一选择吗？
            不是：如果经过了逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配，这样就无需在堆上
                分配内存，也无需进行垃圾回收了，这也是最常见的对象的堆外存储技术；
        逃逸分析的基本行为就是分析对象动态的作用域：
                当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸；就看new的对象实体，而不是对象引用，是否有可能在方法外被调用
                没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间被移除；
                jdk 6u23后 hotspot默认开启了逃逸分析，栈上分配；
                使用-XX:+PrintEscapeAnalysis 查看逃逸分析的筛选结果
            结论：开发中能使用局部变量的，就不要使用在方法外定义了；
            使用逃逸分析，编译器可以对代码做如下优化：

            ***基于逃逸分析，编译器可对代码做如下优化：
                1、栈上分配
                    见上面分析
                2、分离对象或标量替换
                    标量：是指一个无法再分解成更小的数据的数据，java的基本数据类型就是标量；
                        相对的，那些还可以分配的数据就是聚合量，Java中的对象就是聚合量，因此可以分解成聚合量和标量；
                        在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把对象拆解成若干个其中包含的
                        若干个成员变量来代替，这个过程就是标量替换；

                    标量替换参数设置：-XX:+EliminateAllocations  开启了标量替换（默认打开的），允许将对象打散分配到栈上

对象的实例化
    创建的对象的几种方式
        1、new
        2、Class的newInstance   反射，只能调用空参的构造器
        3、Constructor的newInstance(xxx) 可以调用无参/有参的构造器
        4、使用clone() 不调用构造器，但是当前的类需要使用Cloneable接口，实现clone()
        5、使用反序列化
        6、第三方库Objenesis
    创建对象的步骤
        1、判断对象对应的类是否加载、链接、初始化
        2、为对象分配内存
        3、处理并发安全问题
        4、初始化分配到的空间
        5、设置对象的对象头
        6、执行init方法进行初始化

    对象的内存布局
        1、对象头
            包括两部分
                        1、运行时元数据：哈希值（内存地址）、gc分代的年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳
                        2、类型指针：指向元数据，确定该对象的所属类型
        2、实例数据
            它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承的字段）
            父类的变量会出现在子类的前面；相同宽度的字段分配在一起；

    对像的访问定位
        访问方式主要有两种：1、句柄访问
                         2、直接引用（hotspot）
                                引用就是内存地址指向对象在堆里的内存，真正的对象里面保存着对象的类型指针，指向方法区里的类型

    执行引擎的作用以及工作过程
        执行引擎的任务就是将字节码指令解释/编译位对应平台上的本地机器指令才可以，简单来说，jvm中的执行引擎充当了将高级语言翻译为机器语言的翻译者；
        执行引擎在执行过程中究竟执行什么样的字节码指令完全依赖于PC寄存器；

    Java代码编译和执行的过程
        任何高级语言转变成机器码的过程都是要经过编译过程以及汇编过程

    JAVA是半解释半编译的语言
    执行引擎是通过解释器和编译器进行代码的执行
    解释器：当JAVA虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，
        将字节码中的内容翻译成对应平台的本地机器指令执行。
    编译器：将字节码直接翻译成机本地器识别的机器指令

    为什么还需要解释器而不全是用编译器呢？
    当程序启动后，解释器可以马上发挥作用，省去编译时间，立即执行。编译器要想发挥作用，把代码编译成本地代码，
    需要一定的执行时间，但编译为本地代码后执行效率高。
    当JAVA虚拟机启动时，解释器可以首先发挥作用，二不必等待即时编译器全部编译完成后在执行，这样可以省去许多不必要的编译时间，
    随着时间的推移，编译器发挥作用，根据热点探测功能，把越来越多的代码编译成本地代码，获得更高的执行效率。

    热点代码探测何时JIT
    JAVA语言的编译期其实是一段不确定的操作过程，因为它可能是一个前端编译器 把JAVA文件编译成字节码文件的过程；
    也可能是指虚拟机的后端运行期编译器，把字节码转变成机器码的过程；还可能是指使用静态提前编译器把JAVA文件编译
    成本地机器码的过程；

    热点代码：关于那些何时使用JIT需要根据代码的被调用频率而定，关于那些需要被编译成本地代码的字节码也被称之为热点代码
    ，JIT编译器会针对那些热点代码做出深度优化，将其编译成对应平台的本地机器指令，以提升JAVA性能。

    一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以称之为热点代码，因此都可以通过JIT编译器翻译成
    本地机器指令。
    一个方法要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准，必须明确一个阈值，这主要靠热点探测功能，
    hotspot热点探测功能是基于计数器的热点探测。
    hotspot将会为每一个方法都建立两个不同类型的计数器，分别是方法调用计数器和回边计数器。

    方法计数器：统计方法的调用次数
    回边计数器：统计方法体内循环体的执行循环次数
    热度衰减半衰周期
      如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法被调用的次数，
      当超过一定的时间限度，如果方法的调用次数任然不足以让它提交给即时编译器编译，，那这个方法的调用计数器就会减少一半，
      这个过程称为方法调用计数器热度衰减，而这段时间就称作此方法统计的半衰周期进行热度衰减的动作是在虚拟机进行垃圾回收时顺便
      进行的，可使用虚拟机参数-XX:-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行
      时间足够久，绝大部分方法都会被编译成本地代码。
    另外，还可以使用-XX:CountetHalfLifeTime参数设置半衰周期的时间，单位秒。

    回边计数器
      它的作用是统计一个方法中循环体代码执行的次数。
    缺省情况下，hotspot采用解释器和编译器并存的架构，当然开发人员可以根据具体应用场景，通过命令显式为JAVA虚拟机指定运行
    时的模式
      java -Xint -version:完全采用解释器模式执行程序
    java -Xcomp -version:完全采用即时编译器模式执行程序，如果即时编译器出现问题，解释器会介入执行
    java -Xmixed -version:采用解释加编译混合模式，默认

    hotspot虚拟机内嵌了两个即时编译器，分别是client以及Server编译器，简称c1和c2，
    c1(client)编译器会对字节码进行简单可靠的优化，耗时短，以达到更快的编译速度。
    c2（server）编译器会进行耗时较长的优化，以及激进优化，但代码的执行效率更高。
    一般来讲，JIT编译器编译出来的机器码性能比解释器高。
    C2编译器启动时长比c1编译器慢，系统稳定后，，C2执行速度远远快于C1编译器。


    String 类型jdk1.8之前使用char数组存储，jdk1.9后用byte数组保存，相关的类也是使用同样的改变;
    字符串常量池中是不会存储相同内容的字符串的；
    String的String pool是一个固定大小的HashTable，默认值大小长度是1009，如果放进String pool的String非常多，就会造成
    hash冲突严重，从而导致链表很长，而链表很长直接会造成调用String.intern时性能会大幅下降。
        使用-XX:StringTableSize可设置StringTable的长度
        在jdk1.6中StringTable的大小是固定的，就是1009 的长度，多以如果字符串常量池中的字符串过多会造成效率下降很快，
        StringTablleSize设置没有要求；
        在jdk7中，StringTable的长度默认值是60013，1009是可设置的最小值；

        String s1 = "javaee";
        String s2 = "hadoop";

        String s3 = "javaeehadoop";
        String s4 = "javaee" + "hadoop"; //编译成字节码的时候就直接变成了“javaeehadoop” ，称为编译期优化

        //如果拼接符号的前后出现了变量，则类似于在堆空间new了一个字符串对象，具体内容是拼接后的内容
        String s5 = s1 + "hadoop";
        String s6 = "javaee" + s2;

        如下s1+s2的细节
        StringBuilder s = new StringBuilder();
        s.append("javaee");
        s.append("hadoop");
        s.toString();   -->类似于new String("javaeehadoop");
        String s7 = s1 + s2;


        //intern方法作用：判断字符串常量池中是否存在javaeehadoop值，如果存在，则返回常量池中javaeehadoop的地址；
        //如果字符串常量池中不存在javaeehadoop，则在常量池中加载一份javaeehadoop，并返回此对象的地址
        String s8 = s6.intern();

        final String s9 = "a";
        final String s10 = "b";
        String s11 = "ab";
        String s12 = s9 + s10;//被final修饰的变量就不能称为变量了，所以拼接符号两边都被final修饰的话，
        // 适用于编译期优化，也就是说在编译期间就拼接了，相当于“a” + “b”；但是要有一个是变量底层就还是使用StringBuilder；
        //平常如果可以的话建议使用final，因为在编译期间就可以编译了
        System.out.println(s11 == s12);//true

        拼接操作和append操作效率

        public static void main(String[] args) {
                long start = System.currentTimeMillis();
                method1(100000);//耗时 10969
                method2(100000);//耗时 8
                long end = System.currentTimeMillis();
                System.out.println(end -start);
            }

            public static void method1(int i){
                String src = "";
                for (int j = 0; j < i; j++) {
                    src= src + "a";//每循环一次都会创建一个stringBuider和一个String
                }
            }

            public static void method2(int i){
                //自始至终只会创建一个StringBuilder
                StringBuilder src = new StringBuilder();
                for (int j = 0; j < i; j++) {
                    src.append("a");
                }
            }
        StringBuilder改进空间：由于底层维护的是一个char数组，初始容量16，如果append的量比较大的话，就会扩容，继续append，
            又要扩容，扩容实际上是重新new了一个容量更大的char数组，这样如果屡次扩容，以前的插入数组也会在堆中占用内存；
            所以可以在基本确定拼接的字符串长度时，可以在new  StringBuilder时，就直接使用构造器StringBuilder(int capacity)



       GC算法总体概述:
           复制算法：MinorGC
            zaiGC开始的时候，对象只会存在Eden区和名为From的Survivor区，Survivor区To是空的，紧接着进行GC，Eden区中所有存活的对象
            都会被复制到to，而在from区，仍存活的对象会根据他们的年龄值来决定去向，年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置，默认值 15)
            的对象会被移送到老年代中，没有达到阈值的对象会被复制到to区；经过这次GC后，Eden区和from区已经被清空，这个时候from区和to区会
            交换他们的角色，即from变成to，to变成from，不管怎样，都会保证to区是空的，Minor GC会一直重复这样的过程，直到to区被填满，to区被填满后，
            会将所有对象直接移动到老年代中。一般eden区内存和两个Survivor区内存是8：1：1；

            优点：不会产生内存碎片，完整度高
            缺点：浪费了10%的内存


           标记清除/标记整理算法：FullGC又叫MajorGC
             标记：从根集合开始扫描，对存活对象进行标记
             清除：扫描整个内存空间，回收未被日标记的对象

             缺点：效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址，从效率上来说，标记/整理算法要低于复制算法



















