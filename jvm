jvm
    位置：
        jvm在jre里，在操作系统之上（操作系统也是软件），操作系统在硬件体系之上，它与硬件没有直接交互

    作用：java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行（编译完后，
        字节码文件不用在不同操作系统平台做不同的编译，因为同一个字节码文件放在不同的操作系统，有不同的操作系统的jvm，这样就可以将同一个
        字节码文件翻译成不同的可以被不同操作系统识别的字节码指令，由操作码和操作数，字节码指令由执行引擎再转换成机器指令，是唯一可以被cpu识别的指令）。每一条java字节码指令，java虚拟机
        规范中都有详细的定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。

    特点：一次编译，到处运行；自动内存管理；自动垃圾回收功能；

    java执行过程：java源码--java前端编译器（javac命令）--生成字节码文件--类装载器加载到jvm---字节码校验器---翻译字节码指令或者编译进而生成机器
    指令（JIT编译器主要负责将热点代码即时编译成机器指令并且缓存到方法区，因为使用频率较高，如果每一次都解释的话效率不高）

    执行引擎工作其实就是将字节码指令翻译成机器指令

    javap -v Test.class 解析class文件得到指令语言(其实源码在编译成字节码文件后的效果就是字节码指令)

    总结：由于跨平台性设计，java的指令都是根据栈来设计的，优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的
          功能需要更多的指令


    jvm生命周期
        虚拟机的启动：java虚拟机的启动是通过引导类加载器（bootStrap class loader）加载一个初始类来完成的，这个类由虚拟机的具体
        实现（如hotpot或者jrocket的虚拟机）指定的；

        虚拟机的执行：一个运行的java虚拟机有一个清晰的任务，执行java程序；
                    程序开始执行时他才运行，程序结束时他就停止；
                    执行一个所谓的java程序时，真真正正执行的是一个叫做java虚拟机的进程；

        虚拟机的退出：程序正常执行结束；
                    程序在执行过程中遇到了异常或错误而正常终止；
                    由于操作系统出现错误而导致java虚拟机的进程终止；
                    System类的exit方法；
                    JNI也可以加载或卸载jvm；

类的加载过程
    类的加载
        加载器类型：
            BootStrap classLoader：引用类加载器  非java语言编写的，核心类库(jre/lib/rt.jar、resources.jar、sun.boot.class.path路劲下的内容)
                                   使用引导类加载器进行加载，用于提供jvm自身需要的类；不继承classLoader,没有父加载器；
                                   加载扩展类和应用类类加载器，并指定为他们的父类加载器；出于安全考虑，引导类只加载包名为java、javax、sun等开头的类
                                   URL[] urLs = Launcher.getBootstrapClassPath().getURLs();
                                           for (int l = 0; l < urLs.length; l++) {
                                               System.out.println(urLs[l]);
                                           }
                                           获取加载的类的路径

            Extension classLoader：扩展类加载器  java语言编写，由ExtClassLoader实现；父类加载器为启动（引导）类加载器；从java.ext.dirs系统属性所指定的目录中加载类库
                                    或从jdk的安装目录jre/lib/ext子目录下加载类库；如果用户创建的jar放在
                                    此目录下，也会自动由扩展类加载器加载

            Appliction classLoader:应用加载器  java语言编写，由AppClassLoader实现；父类加载器为启动（引导）类加载
                                                自定义类使用系统/应用类加载器进行加载  他负责加载环境变量classpath或
                                              系统属性 java.class.path 指定路径下的类库；
                                              该类加载是程序中默认的类加载器，一般来说，java应用的类都是由他加载；
                                               ClassLoader.getSystemClassLoader() 可以获得这个加载器

                    注意：jvm规范认为间接或直接继承了classLoader类的加载器都属于自定义类加载器

            双亲委派机制：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类加载器器
                        去加载；如果父类加载器还存在父类加载器，则进一步向上委托，以此递归，最终到引导类加载器；
                        如果父类加载器可以完成加载则返回，如果不能加载就返回给子类加载器加载

    类的主动使用和被动使用
        主动使用：
            1、创建类的实例
            2、访问某个类和接口的静态变量，或者对该变量的赋值
            3、调用类的静态方法
            4、反射（Class.forName("com.xxx.xxx")）
            5、初始化一个类的子类，父类就会被加载
            6、java虚拟机启动时被标注为启动类的类
            7、

         被动使用：除以上情况外的所有对类的使用都是被动使用，且不会导致类的初始化，即不会执行<clinit>方法

   ding()：
               1、通过一个类的全限定名获取定义此类的二进制字节流；
               2、将这个字节流所代表的静态存储结构（字节数组）转化为方法区的运行时数据结构
               3、在内存中生成一个代表这个类的java.lang.Class对象，作为这个类的各种数据的访问入口

     类的链接
        verify---prepare---resolve
        verify(验证)：目的在于确保class文件的字节流中包含的信息符合当前虚拟机的要求，保证被加载的正确性。
                    主要有四种验证：文件格式验证、元数据验证、字节码验证、符合引用验证
        prepare(准备)：为静态变量分配内存并且设置该静态变量的默认初始值，即零值；
                      这里不包含用final修饰的static，因为final在编译的时候就已经会分配了，准备阶段会显式的初始化；
                      这里不会为实例变量分配初始化，静态变量会分配在方法区中，而实例变量会随着new对象一起分配到堆中
        resolve(解析)：将常量池内的符号引用转换为直接引用的过程；实际上，解析操作往往会伴随着jvm在执行完初始化之后再执行
     初始化
        初始化阶段就是执行类构造器方法(这个不是我们常说的构造器)<clinit>()的过程。
        此方法不需要我们定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。
        构造器方法中指令按语句再与那文件中出现的顺序执行。
        子类在加载clinit前会先加载父类的；一个类只会加载一次


     类的加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识；如果加载出现问题就会报错；
     classloader只负责class文件的加载，至于他是否可以运行，由执行引擎决定；






     加载的类信息存放于方法区










    jvm里面是有方法区、java栈、本地方法栈（native method stack）、堆、程序计数器；
    jvm调用本地方法接口（JNI）来调用操作系统，调用本地方法接口时会使用本地方法库；


    栈里面没有垃圾，用完就销毁了；程序计数器也没有垃圾；
    jvm调优是针对堆以及方法区进行调优，有图


    jvm内部组成(有图)
    1、classloader类加载器
        复杂加载class文件，class文件在文件开头有特定的文件按标识，并且classLoader只负责class文件加载
        什么是类的加载
            类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，
            用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，
            并且向Java程序员提供了访问方法区内的数据结构的接口。
    2、Java Native interface
        本地接口的作用是融合不同的编程语言为java所用，初衷是融合C/C++程序；该方法的实现由非java语言实现，并不提供实现体；
        调用c/c++/其他本地代码,该接口提供了java与os本地代码互相调用的功能（自我理解：本地方法库是存在于我们计算机硬盘上的.dll文件）
        当java调用JNI接口时，会在执行引擎执行时加载本地方法库中的接口由非java语言写的实现体，在本地方法栈里面加载的native方法

    3、方法区
        方法区空间被所有方法共享，所有定义的方法信息都保存在这片区域，此区属于共享区间
        静态变、常量、类信息、运行时常量池存在方法区中，实例变量存在堆内存中； 方法区和堆一样，是各个内存共享的内存区域，它用于虚拟机加载的类信息、普通常量、静态常量、编译器编译后的代码等等，对于hotpot虚拟机，
        很多开发者习惯将方法区称为永久代，但严格本质上说两者不同，或者说使用永久代实现方法区而已，永久代是方法区的一个实现，jdk1.7的版本中，
        已经将原本方法区的字符串常量池移到堆里面，1.8版本中，已经移到元空间中；
        常量池是方法去的一部分，class文件除了有类的版本，字段、方法
        接口等描述信息外，还有一项信息就是常量池，这部分信息将在类加载后进入方法区的运行时常量池中存放;

        1、方法区还有一个别名叫“非堆”，目的就是要和堆分开；所以方法区看作是独立于java堆的内存空间；
        2、方法区和堆一样，是各个线程共享的内存区域
        3、方法区在jvm启动的时候被创建，并且他的实际的物理内存空间中和java堆区一样都可以是不连续的
        4、方法区的大小，和堆空间一样，可以是固定的也可以是可扩展的
        5、方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类(加载了大量的第三方的jar包；tomcat部署的工程过多；大量动态的生成发射类)（使用时才会加载类，否则就保留在文件系统内），
            导致方法区溢出，虚拟机同样会报内存溢出错误，OOM：PermGen space 或者 OOM：MetaSpace
        6、关闭jvm就会释放这个区域的内存






    4、PC Register 程序计数器
        每个线程都有一个程序计数器，就是一个指针，存储的是下一个要执行的指令的地址，指向方法区中的方法字节码（下一个将要执行的指令代码），
        由执行引擎区pc计数器里取下一条指令的地址然后找到指令进行执行下一条指令，是一个非常小的内存空间；
        为什么使用pc计数器记录当前线程的执行地址呢？
        因为cpu需要不停的切换各个线程，这时候切换回来之后们就得知道从哪继续执行；
        jvm的字节码解释器就需要通过改变pc计数器的值来明确下一条应该执行什么样的字节码指令

    5、本地方法栈
        会在执行引擎执行时加载本地方法库中的接口由非java语言写的实现体，在本地方法栈里面加载的native方法；





    6、栈
        栈也叫内存，主管java程序运行，程序如何运行，是运行时的单位，在线程创建时创建，他的生命周期和线程是一致的，
        线程一结束该栈就over；基本类型的变量和对象的引用变量，部分结果都在栈中分配；栈中存储 本地变量：输入参数，
        输出参数以及方法内的变量；栈操作：记录出栈，入栈的操作；栈帧数据：包括类文件(入参可能是引用对象)、方法等，
        并参与方法得调用和返回
        这里可能会出现栈溢出异常   stackOverFlowError

        java虚拟机规范允许java栈的大小是动态的或者是固定不变的；
            如果采用固定大小，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定，如果线程请求分配的栈容量超过
            java虚拟机栈容量允许的最大量java虚拟机将会抛出一个stackOverFlowError
            如果采用动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存时，java虚拟机会抛出
            outOfMemoryError

        如何设置栈的大小
            我么可以使用参数-Xss来设置线程的最大栈空间,默认单位字节，栈的大小直接决定了函数调用的最大可达深度
            -Xss1024k
            -Xss1m
            -Xss1048576
        每个线程都有自己的栈，栈中的数据都是以栈帧的格式保存，在这个线程上正在执行的每个方法都各自对应着一个栈桢，
        栈帧是一个内存块，是一个数据集；
        不同线程所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧；
        如果当前的方法调用了其他方法，方法返回之际，当前栈帧会返回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，
        使得前一个栈帧重新成为当前栈帧；
        如果方法出现异常，并且没有处理的话，会导致栈帧弹出；

        栈的结构：
            栈帧中存储着：
               1、局部变量表
                定义为一个数字数组，主要用于存储方法参数何定义在方法体内的局部变量，这些数据也包括各类基本数据类型，对象引用以及
                返回地址（returnAdrees）类型;
                局部变量表所需的容量大小是在编译期就已经确定下来的，并保存在方法的code属性的maximum local variables数据项中
                在运行期是不会改变局部变量表的大小的

                方法嵌套调用的次数由栈的大小决定，一般来说，栈越大，方法嵌套次数越多；
                局部变量中的变量只在当前方法调用中有效，在方法执行时，虚拟机通过局部变量表完成参数值到参数变量列表的传递过程。
                当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁；

                关于slot的理解
                    参数值的存放总是在局部变量数组index0开始，到数组长度-1索引结束
                    局部变量表最基本的但愿是slot(变量槽)
                    局部变量表中存放编译器可知的各种基本数据类型，引用类型，returnAddress类型的变量；
                    在局部变量表中，32位类型只占用一个slot(包括returnAddress类型)，64位的类型(long和double)占用两个slot
                    byte short char 在存储前被转换成int，boolean也被转为int，0表示false，非0表示true；
                    long和double则占据两个slot;
                    jvm会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中的局部变量值；
                    当一个实例方法被调用时，他的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上；
                    如果需要访问局部变量表中的一个64位的局部变量值时，只需要使用前一个索引即可；
                    如果当前栈帧是由构造方法或者实例方法创建的，那么该对象的引用this将会放在index为0的slot处，
                    其余的参数按照参数表顺序继续排列；


               2、操作数栈（或表达式栈）
                每一个独立的栈帧中除了包好局部变量表外，还包含一个后进先出的操作数栈；操作数栈在方法执行过程中，根据字节码指令
                往栈中写入数据或提取数据即压栈和弹栈。
                操作数栈主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。
                操作数栈就是jvm执行引擎的一个工作区，当一个方法执行的时候，一个新的栈帧也会被创建出来，这个方法的操作数栈就是空的；
                每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期间就已经确定了，保存在code属性
                的max_stack中；
                栈中的任何元素都可以是任意的java 数据类型
                32bit类型占用一个栈单位深度
                64bit类型占用两个栈单位深度
                操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的出栈和出栈操作来完成一次数据访问；

（这玩意就是指令地址）0 iconst_2  //将2存放到操作数栈(临时存储)，入栈
                1 istore_1  //将2取出并且存放到局部变量里，此时操作数栈就空了，出栈
                2 iconst_3  //将3存放到操作数栈(临时存储)，入栈
                3 istore_2  //存放到局部变量里，此时操作数栈就空了，出栈
                4 iload_1   //从局部变量表里取出来并且放到操作数栈
                5 iload_2   //从局部变量表里取出来并且放到操作数栈
                6 iadd      //将两个数取出来经过执行引擎的解释成机器指令，并拿到cpu进行计算，将结果又放到操作数栈
                7 istore_3  //将执行结果存放到局部变量
                8 return
                工作过程理解：经过执行引擎
                的翻译成机器指令，到cpu执行之后得到数据，再将数据压倒操作数栈里数据送到局部变量

                 如果被调用的方法有返回值，其返回值将会被压入当前栈帧的操作数栈中，并更新pc计数器中下一条需要执行的字节码指令；
                 public int getSum(){
                       int j = 2;
                       int k = 3;
                       int i = j + k;
                       return i;
                   }
                    0 iconst_2
                    1 istore_1
                    2 iconst_3
                    3 istore_2
                    4 iload_1
                    5 iload_2
                    6 iadd
                    7 istore_3
                    8 iload_3
                    9 ireturn


                   public void testGetSum(){
                       int i = getSum();
                       int j = 10;
                   }

                    0 aload_0  //直接将getsum方法的返回值加载到操作数栈中
                    1 invokevirtual #2 <com/sjd/controller/Test.getSum>
                    4 istore_1
                    5 bipush 10
                    7 istore_2
                    8 return




               3、动态链接 （或指向运行时常量池的方法引用）
                在java源文件被编译到字节码文件时，在调用时，所有的属性和方法的引用都作为符号引用保存在class文件的常量池里，
                比如一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用
                就是为了将这些符号引用转换为调用方法的引用；当jvm运行时，会将保存在class文件里的常量池放到方法区的常量池；

                为什么需要常量池?
                为了提供一些符号和常量，便于指令的识别
                jvm在运行程序时，会将变量以及方法的引用都作为常量存到常量池并分配一个符号引用，这样；
                class文件还比较小，用指令作为调用符号；

                      int num = 20;
                       public void methodA(){
                           System.out.println("Test.methodA");
                       }
                        解析后：
                        0 getstatic #3 <java/lang/System.out>  （这个就是具体指代常量池中代表的）
                        3 ldc #4 <Test.methodA>
                        5 invokevirtual #5 <java/io/PrintStream.println>
                        8 return


                       public void methodB(){
                           System.out.println("Test.methodB");
                           methodA();
                           num++;
                       }

                    解析后：
                     0 getstatic #3 <java/lang/System.out>
                     3 ldc #6 <Test.methodB>
                     5 invokevirtual #5 <java/io/PrintStream.println>
                     8 aload_0
                     9 invokevirtual #7 <com/sjd/controller/Test.methodA>
                    12 aload_0
                    13 dup
                    14 getfield #2 <com/sjd/controller/Test.num>
                    17 iconst_1
                    18 iadd
                    19 putfield #2 <com/sjd/controller/Test.num>
                    22 return
              方法的调用：
                在jvm中，经符号引用转换为调用方法的直接引用与方法的绑定机制有关
                    静态绑定
                        当一个字节码文件被装载进jvm内部时，如果被调用的方法在编译期可知，且运行期保持不变，这种情况下将调用方法的
                        符号引用转换为直接引用的过程称之为静态绑定
                    动态绑定
                        如果被调用方法在编译期间无法被确定下来，也就是说，只能够在程序运行期间将调用方法的符号引用转换为直接引用，
                        由于这种转换过程具有动态性，因此被称之为动态绑定。

                        理解：具有多态的或者子类的方法时，使用父类或者接口调用方法时，这时在编译期就不能确定调用的是父类还是子类，
                        这就是晚期绑定，或者也就是动态绑定；
                    如果在java中不希望某个函数用友虚函数的特征时，可以使用final来标注这个方法
                    非虚方法有哪些
                        静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法
                    其它称为虚方法
                    子类对象的多态性的使用前提：1、有类的继承关系 2、方法重写了

                    方法的调用：关于invokedynamic指令
                        invokedynamic指令，这是java为了实现【动态类型语言】支持而做的一种改进
                        但是在 java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM底层字节码工具来产生invokedynamic指令，
                        知道lambda表达式的出现，invokedynamic指令的生成，在java中才有了直接生成方式；

                        动态类型语言和静态类型语言：
                            区别在于对类型的检查是在编译期间还是运行期间，满足前者就是静态类型语言，反之就是动态类型语言；
                            再直白一点就是：静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，
                            变量值才有类型信息，这是动态语言的一个重要特征

               4、方法返回地址（或方法正常退出或者异常退出的定义）
                    存放调用该方法的pc寄存器的值；本质上，方法的退出就是当前栈帧出栈的过程，此时，需要回复上层方法的局部变量表，操作数栈、
                    将返回值压入调用者栈帧的操作数栈，设置pc寄存器值等，让调用者方法继续执行下去。
                    正常完成和异常退出的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值



               5、一些附加信息
                    忽略



jvm优化在哪里   方法区和堆是线程共同享有的，这是jvm优化的内存区；
    一个进程对应着一个jvm实例，一个jvm实例对应着一个运行时数据区，一个运行时数据区只有一个堆和方法区；
    jvm其实是一种规范，他的具体实现其实是有七种，其中sun公司实现的jvm叫hotspot，平常如果我们称的jvm就默认是sun公司的；

    查看jvm内存使用情况的工具：C:\Program Files\Java\jdk1.8.0_131\bin\jvisualvm.exe
    在方法结束后，堆中的对象不会被马上移除，仅仅在垃圾收集的时候才会被移除。堆是GC执行垃圾回收的重点区域；
    堆
        是存储的单位，数据怎么存放，放在哪；由三个区组成：新生区、养老区和永久存储区

        新生区由伊甸区、幸存0区和幸存1区；新生区是类的诞生、成长和消亡的区域，一个类在这里诞生，应用，最后被垃圾回收器结束生命
        新生区又分为两个部分：伊甸区和幸存者区，所有的类都是在伊甸区被new出来，幸村区有两个，0区和1区，，当伊甸区空间用完时，
        程序又要创建对象，jvm垃圾回收器将对伊甸园区进行垃圾回收，将伊甸区里的没有对象引用的对象进行销毁，然后将伊甸区的剩余对象移到幸存0区，
        如果0区满了就移动到1区，此时伊甸园区是空的；如果1区满了，在移动到养老区，如果养老区也满了，那么这时候将产生Gc（fullGc），进行养老区的内存清理，
        若养老区执行了full gc之后发现依然无法进行对象的保存，就会产生outOfMemoryError: Java heap space说明java虚拟机的堆内存不够，原因有二：
        1、java虚拟机的堆内存设置不够，可以通过-xms、-xmx来调整
        2、代码中创建了大量的大对象（内存连续的且较大的对象，例如较长字符串，数组），并且长时间不能被垃圾回收器收集(存在被引用)

        如果new的对象伊甸园区放不下去，就直接放入老年代的；老年代也放不下，那老年代就进行fullGC，如果gc完还放不下，那就outofmemoryerror吧

           System.out.println(Runtime.getRuntime().maxMemory()/1024/1024);这个可以查看jvm可用的最大内存
           byte[] b = new byte[1024 * 1024 * 2000];这个就可能发生内存溢出错误;需要占用大量连续内存空间的jaa对象是大对象，比如很长的字符串和数组

        养老区
            养老区用于保存从新生区筛选出来的java对象，一般池对象都在这个区域活跃

        永久区
            永久区是一个常驻内存区域，用于存放jdk所携带的class，interface的元数据，也就是说他存储的运行环境必须的类信息，被装载
            进此区域的数据是不会垃圾回收器回收掉的，关闭jvm才会释放此区域占用的内存
            如果产生outOfMemoryError:permGen space,说明是java虚拟机对永久代内存设置不够。一般出现这种情况，都是程序
            启动需要大量的第三方jar包。例如在一个tomcat下部署了太多的应用，或者大量的动态反射生成的类不断被加载，
            最终导致permGen占满


        堆内存调优简介
           堆空间设置大小
            -Xms  设置初始分配大小，默认为物理内存的 1/64  不涉及永久代区
            -Xmx  最大分配内存，默认为物理分配内存的 1/4  不涉及永久代区
            开始发设置中建议将初始堆内存和最大堆内存设置成相同的值，否则频繁扩容造成系统压力


            Runtime.getRuntime().maxMemory()//返回java虚拟机试图使用的最大内存量
            Runtime.getRuntime().totalMemory()//返回java虚拟机中的当前的内存总量，初始内存

            查看设置的参数：方式一 jps  /  jstat -gc 进程id
                          方式二 -XX:PrintGCDetails 输出详细的GC处理日志

            配置新生代与老年代在堆结构中的占比
                默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3  （不包含永久代）
                可以修改-XX:NewRatio =4,表示新生代占1，老年代占4，新生代整个堆的1/5 （不包含永久代）

            -XX:SurvivorRatio 用来调整新生代中的伊甸区和两个幸存区的比例，默认比例时8:1:1

       对象分配过程：概述


       jvm在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分的时候回收都是指新生代。
       因此GC按照回收的区域又分了两种类型，一种是普通GC(minor GC),一种是全局GC(major GC or Full GC),
       普通GC只针对新生代区里的伊甸园区，伊甸园区满的时候会触发minor GC，幸存区满不会触发minor GC；
       但是不意味着没有垃圾回收，当伊甸园区满的时候会将幸存者区也连带回收；
       全局GC针对老年代的GC，偶尔伴随对新生代的GC以及对永久代的GC；

       频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集


        MinorGC、MagorGC、FullGC
            jvm在进行GC时，并非每次都对上面三个内存（新生代、老年代、方法区）区域一起回收的，大部分时候回收的都是指老年代。
            针对hot spot vm的实现，它里面按照回收的区域又分为两大种类型：一种是部分收集(Partial GC),一种是整堆收集(Full GC)
            部分收集：不是完整收集整个java堆的垃圾收集。其中又分为：
                新生代收集(Minor GC),只是新生代(eden\s0\s1)的垃圾收集
                    触发机制：当新生代空间不足时，会触发  Minor GC，这里的新生代满指的是Eden代满，幸存区满不会触发GC（每次Minor GC会清理年轻代的内存）
                            因为Java对象大多数都具有朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也比较快。
                            Minor GC会引发STW(暂停用户线程)，等垃圾回收结束，用户线程才恢复运行，因为Minor GC速度很快，对性能影响较小。

                老年代收集(Magor GC),只是老年代的垃圾收集
                    目前，只有CMS GC会有单独收集老年代的行为。
                    注意，很多时候Magor GC会和Full GC混淆使用，需要具体分辨的是老年代回收还是整堆回收。
                    触发机制：老年代空间不足时，则触发Magor GC;Magor GC的速度一般会比Minor GC慢10倍以上，STW时间更长，
                        如果Magor GC后内存还是不足，则会OOM
                混合收集(Mixed GC)，收集整个新生代以及部分老年代的垃圾收集。


            整堆收集（Full GC）:收集整个java堆和方法区的垃圾收集
                触发机制：1、调用system.gc()，系统建议执行Full GC，但是不必然执行
                         2、老年代空间不足
                         3、方法去空间不足

                         说明：full gc是开发中或调优中尽量要避免的，这样暂停时间会短一些

            堆空间的分代思想：其实不分代是完全可以的，分代的唯一理由是优化GC性能，进而快速腾出空间出来

            堆空间内存分配策略：
                1、优先分配到Eden
                2、大对象直接分配到老年代(没有经过Minor GC，直接进入了老年代)
                    尽量避免程序中出现过多大对象
                3、长期存活的对象分配到老年代
                4、动态对象年龄判断
                    如果幸存区中相同年龄的所有对象大小的总和大于幸存区空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，
                    无需等到MaxTenuringThreshold中要求的年龄。
                5、空间分配担保
                    -XX:HandlePromotionFailure

            堆空间的参数设置：
                -XX:+PrintFlagsInitial 查看所有参数的默认默认值(即使修改了，也看到的是默认值)
                -XX:+PrintFlagsFinal    查看所有参数的最终值(可能初始值被修改，这样可以查看到最终值)
                -Xms:初始堆空间内存(默认为物理内存的1/64)
                -Xmx:最大堆空间内存(默认物理内存的1/4)
                -Xmn:设置新生代的大小(初始值和最大值)
                        例：-Xmn2g：设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。
                        持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，
                        Sun官方推荐配置为整个堆的3/8
                -XX:NewRatio 配置新生代与老年代在堆结构中的占比
                -XX:SurvivorRatio   设置新生代中的Eden和S0/S1空间的比例
                -XX:MaxTenuringThreshold    设置新生代中垃圾的最大年龄
                -XX:PintGcDetails   输出详细的GC处理日志
                -XX:HandlePromotionFailure 是否设置空间分配担保

        堆是分配对象存储的唯一选择吗？
            不是：如果经过了逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配，这样就无需在堆上
                分配内存，也无需进行垃圾回收了，这也是最常见的对象的堆外存储技术；
        逃逸分析的基本行为就是分析对象动态的作用域：
                当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸；就看new的对象实体，而不是对象引用，是否有可能在方法外被调用
                没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间被移除；
                jdk 6u23后 hotspot默认开启了逃逸分析，栈上分配；
                使用-XX:+PrintEscapeAnalysis 查看逃逸分析的筛选结果
            结论：开发中能使用局部变量的，就不要使用在方法外定义了；
            使用逃逸分析，编译器可以对代码做如下优化：

            ***基于逃逸分析，编译器可对代码做如下优化：
                1、栈上分配
                    见上面分析
                2、分离对象或标量替换
                    标量：是指一个无法再分解成更小的数据的数据，java的基本数据类型就是标量；
                        相对的，那些还可以分配的数据就是聚合量，Java中的对象就是聚合量，因此可以分解成聚合量和标量；
                        在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把对象拆解成若干个其中包含的
                        若干个成员变量来代替，这个过程就是标量替换；

                    标量替换参数设置：-XX:+EliminateAllocations  开启了标量替换（默认打开的），允许将对象打散分配到栈上




       GC算法总体概述:
           复制算法：MinorGC
            zaiGC开始的时候，对象只会存在Eden区和名为From的Survivor区，Survivor区To是空的，紧接着进行GC，Eden区中所有存活的对象
            都会被复制到to，而在from区，仍存活的对象会根据他们的年龄值来决定去向，年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置，默认值 15)
            的对象会被移送到老年代中，没有达到阈值的对象会被复制到to区；经过这次GC后，Eden区和from区已经被清空，这个时候from区和to区会
            交换他们的角色，即from变成to，to变成from，不管怎样，都会保证to区是空的，Minor GC会一直重复这样的过程，直到to区被填满，to区被填满后，
            会将所有对象直接移动到老年代中。一般eden区内存和两个Survivor区内存是8：1：1；

            优点：不会产生内存碎片，完整度高
            缺点：浪费了10%的内存


           标记清除/标记整理算法：FullGC又叫MajorGC
             标记：从根集合开始扫描，对存活对象进行标记
             清除：扫描整个内存空间，回收未被日标记的对象

             缺点：效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址，从效率上来说，标记/整理算法要低于复制算法



















