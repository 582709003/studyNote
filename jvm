jvm
    位置：
        jvm在jre里，在操作系统之上（操作系统也是软件），操作系统在硬件体系之上，它与硬件没有直接交互
        class文件可以被反编译成java字节码指令，在jvm中执行的指令我们称之为字节码指令，执行之后字节码指令会变成不同造作系统对
        应的机器码指令
    作用：java虚拟机就是二进制字节码(另一种表现形式就是java字节码指令)的运行环境，jvm负责装载字节码到其内部，然后将字节码
        解释/编译为对应操作系统上的机器指令执行；
        (不同操作系统所对应的jvm里的执行引擎将同一个字节码文件转换成适配的操作系统的机器指令，是唯一可以被cpu识别的指令）。
        每一条java指令，java虚拟机规范中都有详细的定义，如怎么取操作数，处理结果放在哪里。
        执行引擎工作其实就是将字节码指令翻译成机器指令
    特点：一次编译，到处运行；自动内存管理；自动垃圾回收功能；

    java执行过程：java源码--java前端编译器（javac命令）--生成字节码文件--类装载器加载到jvm---字节码校验器---翻译机器指令
    或者编译进而生成对应操作系统的机器指令（JIT编译器主要负责将热点代码即时编译成机器指令并且缓存到方法区(方法区里的代码缓存区)，
    因为使用频率较高，如果每一次都解释的话效率不高）

    javap -v -p Test.class 解析class文件得到java字节码指令语言(其实源码在编译成字节码文件后的效果就是字节码指令)

    总结：jvm由于跨平台性设计，java的指令都是根据栈来设计的，优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的
          功能需要更多的指令;

    jvm生命周期
        虚拟机的启动：java虚拟机的启动是通过引导类加载器（bootStrap class loader）加载一个初始类来完成的，这个初始类由不同
                    虚拟机的具体实现（如hotpot或者jrocket的虚拟机）指定的；

        虚拟机的执行：一个运行的java虚拟机有一个清晰的任务，执行java程序；
                    程序开始执行时他才运行，程序结束时他就停止；
                    执行一个所谓的java程序时，真真正正执行的是一个叫做java虚拟机的进程；

        虚拟机的退出：程序正常执行结束；
                    程序在执行过程中遇到了异常或错误而正常终止；
                    由于操作系统出现错误而导致java虚拟机的进程终止；
                    System类的exit方法；
                    JNI也可以加载或卸载jvm；

类加载器子系统的作用
    1、类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识
    2、classloader只负责class文件的加载，至于它是否可以运行，则有执行引擎决定
    3、加载的类信息存放于一块称为方法区的内存空间，除了类信息外，方法区中还会存放运行时常量池信息，可能还包括字符串的字面量和
        数值常量(这部分常量信息是class文件中的常量池部分的内存映射)

类的加载过程
    类的加载(loading)
        1、通过一个类的全限定名获取定义此类的二进制字节流
        2、将这个字节流所代表的静态存储结构转化成方法区的运行时数据结构
        3、在内存中生成一个代表这个类的java.lang.Class对象，作为在方法区里这个类的各种数据的访问入口

     类的链接linking
        verify---prepare---resolve
        verify(验证)：目的在于确保class文件的字节流中包含的信息符合当前虚拟机的要求，保证被加载的正确性。
                    主要有四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证；
        prepare(准备)：准备阶段就是为类变量(非final的静态变量)分配内存并且设置该静态变量的默认初始值，即零值；
                      这里不包含用final修饰的static，因为final修饰的静态变量其实是常量，它在编译的时候就已经被分配了，
                      所以不需要分配了；
                      准备阶段会显式的初始化为确切的值；只对static修饰的静态变量进行内存分配、赋默认值（如0、0L、null、false等）。
                      对final的静态字面值的常量如果是确定的值，那么直接赋初值，不会触发初始化；但是如果只要赋的值不是确定
                      （例如 public final static  int v= new Random().nextInt()，后面的这个值就是不确定的；
                      引用对象会将内存地址赋值给他，这个是确定的）的，就会触发初始化
                      这里不会为实例变量分配初始化，静态变量会分配在方法区中（1.7以及之前方法区，1.8后放在堆中），
                      而实例变量会随着new对象一起分配到堆中

        resolve(解析)：将运行时常量池里的符号引用转换成直接引用的过程；
                      可以这么理解：当java文件在编译成class文件的时候他还不清楚这个类里面涉及到的其他类究竟将来会在内存里面的哪个地方，
                      所以就先用符号引用代替；当当前类初始化完成之后，类里面涉及到的其他类肯定是已经加载到内存里了，
                      这时候肯定是可以找到这些类在方法区的内存地址，所以就在当前类初始化完后就去找其他类的内存地址，方法的内存地址，字段的内存地址
                      找到后就转化成直接引用了；
                      栈帧空间里的动态链接其实就是获取到该类的运行时常量里的直接引用，而在栈桢里我们需要使用这个动态链接的指引
                      去找到创建对象的原材料--类型信息，创建类中属性的原材料--字段信息，还有方法--方法信息，然后将创建属性和对象
                       关联起来，方法也和对象关联起来，java中类型、字段、方法其实都是独立的，所以才会有class对象，filed对象，method对象；
                      实际上，解析操作往往会伴随着jvm在执行完初始化之后再执行
     类的初始化
        初始化阶段就是执行类构造器方法(这个不是我们常说的类的构造器)<clinit>()的过程。
        此方法不需要我们定义，是javac编译器自动收集类中的所有静态变量的赋值动作和静态代码块中的语句合并而来。
        构造器方法中指令按语句再与那文件中出现的顺序执行。子类在加载clinit前会先加载父类的；一个类只会加载一次


     类的加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识；如果加载出现问题就会报错；
     classloader只负责class文件的加载，至于他是否可以运行，由执行引擎决定；

     类的加载器类型：
                BootStrap classLoader：引导类加载器非java语言编写的，核心类库(jre/lib/rt.jar、resources.jar、sun.boot.class.path路径下的内容)
                                       使用引导类加载器进行加载，用于提供jvm自身需要的类；不继承classLoader,没有父加载器；
                                       加载扩展类和应用类类加载器，并指定为他们的父类加载器；出于安全考虑，引导类只加载包名为java、javax、sun等开头的类
                                       URL[] urLs = Launcher.getBootstrapClassPath().getURLs();
                                               for (int l = 0; l < urLs.length; l++) {
                                                   System.out.println(urLs[l]);
                                               }
                                               获取加载的类的路径

                Extension classLoader：扩展类加载器  java语言编写，由ExtClassLoader实现；父类加载器为启动（引导）类加载器；
                                        从java.ext.dirs系统属性所指定的目录中加载类库；
                                        或从jdk的安装目录jre/lib/ext子目录下加载类库；如果用户创建的jar放在
                                        此目录下，也会自动由扩展类加载器加载

                Appliction classLoader:应用加载器java语言编写，由AppClassLoader实现；父类加载器为启动（引导）类加载
                                        自定义类使用系统/应用类加载器进行加载  他负责加载环境变量classpath或
                                        系统属性 java.class.path 指定路径下的类库；
                                        该类加载器是程序中默认的类加载器，一般来说，java应用的类都是由他加载；
                                        ClassLoader.getSystemClassLoader() 可以获得这个加载器

                        注意：jvm规范认为间接或直接继承了ClassLoader类的加载器都属于自定义类加载器

                双亲委派机制：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类加载器
                            去加载；如果父类加载器还存在父类加载器，则进一步向上委托，以此递归，最终到引导类加载器；
                            如果父类加载器可以完成加载则返回，如果不能加载就返回给子类加载器加载

            在jvm中表示两个class对象是否为同一个类需要两个必要的条件
                1、类的完整类名必须一致，包括包名
                2、加载这个类的类加载器必须相同

            jvm必须知道一个类是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户加载器加载的，那么jvm会将这个类加载器
            的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，jvm需要保证这两个类型的类加载器是相同的

            类的主动使用和被动使用
                主动使用：(会调用<clinit>方法)
                    1、创建类的实例，比如new 关键字，或者通过反射、克隆、反序列化
                    2、访问某个类和接口的静态变量(这个静态变量是当前接口或类真正声明的字段)(final修饰的特殊考虑)，
                        或者对该变量的赋值
                    3、调用类的静态方法，即当使用了invokestatic指令
                    4、反射（Class.forName("com.xxx.xxx")）
                    5、初始化一个类的子类，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
                    6、java虚拟机启动时被标注为启动类的类

                    类加载器的加载方式
                        这里的类加载不是指类加载阶段，而是指整个类加载过程，即类加载阶段到初始化完成。
                        （1）隐式加载
                            创建类对象
                            使用类的静态域
                            创建子类对象
                            使用子类的静态域
                            在JVM启动时，BootStrapLoader会加载一些JVM自身运行所需的class
                            在JVM启动时，ExtClassLoader会加载指定目录下一些特殊的class
                            在JVM启动时，AppClassLoader会加载classpath路径下的class，以及- - main函数所在的类的class文件
                        （2）显式加载
                            ClassLoader.loadClass(className)，只加载和链接、不会进行初始化
                            Class.forName(String name, boolean initialize,ClassLoader loader);
                            使用loader进行加载和链接，根据参数initialize决定是否初始化。

             被动使用：除以上情况外的所有对类的使用都是被动使用，且不会导致类的初始化，即不会执行<clinit>方法；
                      也就是说：并不是在代码中出现的类，就一定会被加载或者初始化，如果不符合主动使用的条件，类就不会初始化。
                      1、当访问一个静态字段时，只有真正声明这个字段的类才会被初始化
                            当通过子类引用父类的静态变量，不会导致子类的初始化，但是会完成加载；但是父类会初始化
                      2、通过数组定义类引用，不会触发此类的初始化
                        Parent[] p = new Parent[10];这里parent没有进行初始化
                      3、引用某一个类里面的常量不会触发此类或接口的初始化
                      4、调用classLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化
                        注意：没有初始化的类不意味着没有加载
                        验证：-XX:+TraceClassLoading 查看类的加载信息

类的使用：
    任何一个类在使用之前一定是经过了加载、链接 和初始化三个阶段；

类的卸载：
    在类的加载器内部(其实也是一个对象)实现中，用一个java集合来存放这个类加载器加载过的类的引用。另一方面，一个类总是会引用他的类
    加载器，调用Class对象的getClassLoader()方法，就能获得他的类加载器。由此可见，代表某个类的Class实例与
    其类的加载器之间为双向关联关系；
    一个类的实例对象总是引用着代表这个类的Class对象，在object类中定义了getClass()方法，这个方法返回了代表这个实例对象所属
    的Class对象的引用；此外，所有的java类都有一个静态属性class，他引用的是代表这个类的Class对象；
    一个类何时结束生命周期取决于代表这个类的Class对象何时结束生命周期


    加载的类信息存放于方法区

    jvm里面是有方法区、java栈、本地方法栈（native method stack）、堆、程序计数器，执行引擎；
    jvm调用本地方法接口（JNI）来调用操作系统，调用本地方法接口时会使用本地方法库；

    栈里面没有垃圾，用完就销毁了；程序计数器也没有垃圾；
    jvm调优是针对堆以及方法区进行调优，有图

 jvm内部组成(有图)
    1、classloader类加载器
        复杂加载class文件，class文件在文件开头有特定的文件按标识，并且classLoader只负责class文件加载
        什么是类的加载
            类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，
            用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，
            并且向Java程序员提供了访问方法区内的数据结构的接口。
    2、Java Native interface
        本地接口的作用是融合不同的编程语言为java所用，初衷是融合C/C++程序；该方法的实现由非java语言实现，并不提供实现体；
        调用c/c++/其他本地代码,该接口提供了java与os本地代码互相调用的功能（自我理解：本地方法库是存在于我们计算机硬盘上的.dll文件）
        当java调用JNI接口时，会在执行引擎执行时加载本地方法库中的接口由非java语言写的实现体，在本地方法栈里面加载的native方法

    3、方法区
        方法区空间被所有方法共享，所有定义的方法信息都保存在这片区域，此区属于共享区间
        静态变量、常量、类信息、运行时常量池存在方法区中，实例变量存在堆内存中； 方法区和堆一样，是各个内存共享的内存区域，
        它用于虚拟机加载的类信息、普通常量、静态常量、编译器编译后的代码等等，对于hotpot虚拟机，
        很多开发者习惯将方法区称为永久代，但严格本质上说两者不同，或者说使用永久代实现方法区而已，永久代是方法区的一种实现，
        jdk1.7的版本中，已经将原本方法区的字符串常量池移到堆里面，1.8版本中，方法区已经移到元空间(本地内存)中；
        常量池是方法区的一部分，class文件除了有类的版本，字段、方法
        接口等描述信息外，还有一项信息就是常量池，这部分信息将在类加载后进入方法区的运行时常量池中存放;
----------------
        1、方法区还有一个别名叫“非堆”，目的就是要和堆分开；所以方法区看作是独立于java堆的内存空间；
        2、方法区和堆一样，是各个线程共享的内存区域
        3、方法区在jvm启动的时候被创建，并且他的实际的物理内存空间中和java堆区一样都可以是不连续的
        4、方法区的大小，和堆空间一样，可以是固定的也可以是可扩展的
        5、方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类(加载了大量的第三方的jar包；tomcat部署的工程过多；
           大量动态的生成发射类)（使用时才会加载类，否则就保留在文件系统内），
            导致方法区溢出，虚拟机同样会报内存溢出错误，OOM：PermGen space 或者 OOM：MetaSpace
            报OOM之前通常触发过GC，gc完还是没有多余的内存才会报OOM；
            但是也有可能直接报OOM，比如分配一个超大对象直接比内存还大，jvm可以判断出即使gc了也没多余内存，就直接报OOM

        6、关闭jvm就会释放这个区域的内存

        方法区的演进
            在jdk1.7之前，习惯上把方法区称为永久代，jdk1.8后改成了元空间；本质上，方法区和永久代并不等价，仅仅是对hotspot而言；
            元空间的本质和永久代类似，都是对jvm规范中方法区的实现。不过元空间和永久代最大区别在于：元空间不在虚拟机设置的内存中，
            而是使用本地内存；

        方法区的垃圾收集主要是回收两大部分：常量池中的废弃的常量和不再使用的类(类，接口，枚举，注解)

        设置方法区大小与OOM
            方法区的大小不必是固定的，jvm可以根据应用的需要动态调整。
            jdk1.7以前：
                通过-XX:PermSize来设置永久代初始分配空间。默认值是20.75M
                通过-XX:MaxPermSize来设置永久代最大可分配空间，32位机器默认是64M，64位机器默认是82M
                当jvm加载的类信息容量超过这个值，会报OOM：PermGen
            jdk1.8以及以后：
                元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定，替代上述原有的两个参数。
                默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。

                与永久代不同，如果不指定大小，默认情况下，虚拟机会耗用所有的系统可用内存。如果元数据区发生溢出，虚拟机一样抛出
                异常OOM:Metaspace;

                -XX:MetaspaceSize:设置初始的元空间大小，对于一个64位的服务器端jvm来说，其默认的-XX:MetaspaceSize值位21m,
                这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不在存活），
                然后这个高水位线将会重置，新的高水位线的值取决于GC后释放了多少元空间，如果释放的元空间不足，那么在不超过
                MaxMetaspaceSize时，适当提高该值，如果释放空间过多，则适当降低该值；

                如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次，通过垃圾回收器的日志可以观察到full GC多次调用，
                为了避免频繁GC，建议将-XX:MetaspaceSize设置为一个相对较高的值；

         如何解决这些OOM？
            1、要解决oom或者heap space的异常，一般的手段是首先通过内存映像分析工具对dump出来的堆转储快照进行分析，重点是
            内存中的对象是否是必要的，也就是弄清楚到底是出现了内存泄露(memory leak)
            (内存泄露：就是对象有引用但是没有使用，这样的对象过多导致内存溢出)还是内存溢出(memory overflow)。
            2、如果是内存泄露，可进一步通过工具查看泄露对象到GC ROOTS的引用链，于是就能找到泄露的对象是通过怎样的路径与GC ROOTS
            相关联并导致垃圾收集器无法自动回收他们的。掌握了泄露对象的类型信息，以及GC ROOTS的引用链信息，就可以比较准确的定位
            出泄露代码的准确位置。
            3、如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须是活着的，那就应当检查jvm的堆参数(-Xmx 与-Xms)，与机器
            物理内存对比看，是否还可以调大，从代码上检查某些对象周期是否过长

        方法区的内部结构
            注意：被加载到方法区的类里面会记录着加载此类的类加载器信息
            静态变量、类型信息、字段信息、方法信息、运行时常量池存在方法区中（jdk1.8及以后），代码缓存（jit编译后的机器码缓存）
                类信息
                    当前类的类型信息：
                        对每个加载的类(包括类，接口，枚举，注解)，jvm必须在方法区存储以下类型信息
                        1、这个类的完整有效名称（包名加类名）
                        2、这个类的直接父类的完整有效名称（接口和object没有父类）
                        3、这个类的修饰符(pulic,abstract,final等)
                        4、这个类直接接口的一个有序列表(就是为实现的直接接口排个顺序，并且记录到有序列表)
                    当前类的域(属性)信息：
                        jvm必须在方法区中保存类的所有域的相关信息以及域的声明顺序。
                        域的相关信息包括：域名称、域类型、域的所有修饰符
                        static final修饰的变量在链接的准备阶段时就已经附上值了
                    当前类的方法（method）信息
                        jvm必须保存所有方法的以下信息
                            1、方法名称
                            2、方法的返回类型
                            3、方法的参数数量和类型(或void)
                            4、方法的修饰符
                            5、方法的字节码，操作数栈、局部变量表、以及形参的大小(abstract和native方法除外)
                            6、异常表(abstract和native方法除外)，每个异常处理的开始位置，结束位置，代码处理在程序计数器中的偏移地址、
                                被捕捉的异常类的常量池索引
                    运行时常量池
                        存放该类型所用到的常量的有序集合，包括直接常量（如字符串、整数、浮点数的字面量）和对所有方法体中使用到的其他类
                        的类型、字段、方法的符号引用。常量池中每一个保存的常量都有一个索引，就像数组中的字段一样。因为常量池中保存了类
                        使用到的所有类型、字段、方法的符号引用，所以它也是动态连接（栈中对应的方法指向这个引用）的主要对象
                        （在动态链接中起到核心作用）。
                        注意： jdk1.8之后，无永久代，类型信息、字段、方法，常量保存在本地内存的元空间，但字符串常量池、
                                静态变量的引用仍存在堆里；
                        为什么字符串常量池移到堆里存放？
                            因为原先放在永久代里的话，永久代因为回收效率较低，只有在full gc时才会触发，而full gc只有在老年代、
                            永久代空间不足时才会触发，这就导致字符串常量池回收效率不高，而我们开发中会创建大量的字符串，
                            回收效率低会导致永久代内存不足。放在堆里能及时回收内存。
                            自我理解：程序中的变量名在内存中其实是以内存地址（引用类型）或者直接以数值（基本数据类型）存在；

                    静态变量
                        jdk1.8，静态引用对应的对象始终都存在堆空间，并且jdk1.7之后jvm把静态变量与变量的类型在java语言一端
                        的映射class对象存放在一起，存储于堆中

                    指向类加载器的引用
                        JVM 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，
                        那么 JVM 会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。JVM 在动态链接的时候需要这个信息。
                        当解析一个类型到另一个类型的引用的时候，JVM 需要保证这两个类型的类加载器是相同的。这对 JVM 区分名字空间的
                        方式是至关重要的。

                    指向 Class 实例的引用
                        JVM 为每个加载的类和接口都创建一个 java.lang.Class 实例（JDK6 存储在方法区，JDK6 之后存储在 Java 堆），
                        这个对象存储了所有这个字节码内存块的相关信息，如平时使用的 this.getClass().getName()
                        this.getClass().getDeclaredMethods() this.getClass().getDeclaredFields()，可以获取类的各种信息，
                        都是通过这个 Class 引用获取。

                方法区的垃圾收集器主要回收两方面内容 常量池和不再使用的类型
                  先来说说方法区内常量池中主要存放的两大类常量:字面量和符号引用
                    字面量比较接近JAVA语言的常量概念，如文本字符串和被final修饰的常量值；
                    符号引用则属于编译原理方面的概念，包括下面三类常量
                        1、类和接口的全限定名
                        2、字段的名称和描述符
                        3、方法的名称和描述符
                回收的策略：只要方法区中的常量没有被任何地方引用，就可以被回收

            判定一个类型是否属于不再被使用的类的条件就比较苛刻了，需要同时满足下面三个条件
            1、该类所有的实例都已经被回收，包括派生的子类对象
            2、加载该类的类加载器已经被回收
            3、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
            java虚拟机对满足上述的三个条件的无用类及逆行回收，但是仅仅是被允许，而不是必然会被回收；关于是否对类型进行回收，
            hospot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:TraceClass-Loaading、
            -XX:TraceClass-Unloaading查看类加载和卸载信息
            在大量使用反射、动态代理、CGlib等字节码框架等频繁自定义类加载器的场景中，通常都需要虚拟机具备类型卸载的能力，
            以保证不会堆方法区造成过大的压力

                方法区运行时常量池vs字节码文件常量池
                    方法区中有一个运行时常量池
                    字节码文件中有一个常量池；
                    字节码文件在被加载到jvm后常量池就到了方法区的运行时常量池

                    常量池：
                        一个有效的字节码文件中除了包含类的版本信息，字段，方法，以节接口等描述信息外，还包含一项信息
                        那就是常量池表，用于存放编译器生成的各种字面值和对类型、域和方法的符号引用；
                        注意：
                            如果int类型的数值如果比较简单的话，是不会将该值放入常量池中的，可以直接通过JVM指令将值赋值给相应字段；
                            bipush 将单字节的常量值(-128~127)推送至栈顶
                            sipush 将一个短整型常量值(-32768~32767)推送至栈顶
                            该系列命令负责把一个整形数字（长度比较小）送到到栈顶。该系列命令有一个参数，用于指定要送到栈顶的数字。
                            注意该系列命令只能操作一定范围内的整形数值，超出该范围的使用将使用ldc命令系列。
                            看到这里我们就恍然大悟了，原来JVM字节码的指令是可以存储一定范围的值的，不需要将该范围内的值放置到常量池
                            当中，然后搞个索引指向常量池中；我们将int的值设置为32768，大于short型的最大值，可以看到，int型的数值
                            出现在了常量池当中。

                        为什么要常量池？
                            使用常量池使用符号引用会大大减少字节码文件的大小，同一个字面值也不用创建多个；
                        常量池有什么？
                            数值型字面量
                            字符串值
                            类引用
                            字段引用
                            方法引用
                        小结：
                            常量池，可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型
                     运行时常量池
                        常量池表是class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类被加载时存放到方法区的运行时常量池;
                        在加载类和接口到虚拟机后，就会创建对应的运行时常量池。
                        jvm为每个已加载的类型(类或接口)都维护一个常量池。池中的数据项像数组一样，是通过索引访问的；
                        运行时常量池中包含多种不同的常量，包括编译期间就已经明确的数值字面量(static final修饰的变量在编译期间
                        就已赋值了)，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实的内存地址；
                        运行时常量池相对于class文件常量池的另一个重要的特征是：具备动态性





    4、PC Register 程序计数器
        每个线程都有一个程序计数器，就是一个指针，存储的是下一个要执行的java字节码指令的地址，由执行引擎读取下一条指令，
        指向方法区中的方法字节码（下一个将要执行的指令代码），
        由执行引擎去pc计数器里取下一条指令的地址然后找到指令进行执行下一条指令，是一个非常小的内存空间；
        为什么使用pc计数器记录当前线程的执行地址呢？
        因为cpu需要不停的切换各个线程，这时候切换回来之后们就得知道从哪继续执行；
        jvm的字节码解释器(执行引擎)就需要通过改变pc计数器的值来明确下一条应该执行什么样的字节码指令；
        为了能够准确地记录各个线程正在执行的当前字节码指令的地址，最好的办法就是为每一个线程都分配一个pc寄存器，这样一来，
        各个线程之间便可以独立进行计算，从而不会出现相互干扰的情况

    5、本地方法栈
        会在执行引擎执行时加载本地方法库中的接口由非java语言写的实现体，在本地方法栈里面加载的native方法；

    6、栈
        跨平台，指令集小，编译器容易实现，但是性能下降，实现同样的功能需要更多的指令
        栈也叫内存，主管java程序运行，程序如何运行，栈是运行时的单位，在线程创建时创建，他的生命周期和线程是一致的，
        线程一结束该栈就over；基本类型的变量和对象的引用变量，部分结果都在栈中分配；栈中存储本地变量：输入参数，
        输出参数以及方法内的变量；栈操作：记录出栈，入栈的操作；栈帧数据：包括类文件(入参可能是引用对象)、方法等，
        并参与方法得调用和返回；
        栈不存在垃圾回收问题，但是这里可能会出现栈溢出异常   stackOverFlowError

        java虚拟机规范允许java栈的大小是动态的或者是固定不变的；
            如果采用固定大小，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定，如果线程请求分配的栈容量超过
            java虚拟机栈容量允许的最大量java虚拟机将会抛出一个stackOverFlowError
            如果采用动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存时，java虚拟机会
            抛出outOfMemoryError

        如何设置栈的大小
            我们可以使用参数-Xss来设置线程的最大栈空间,默认单位字节，栈的大小直接决定了函数调用的最大可达深度
            -Xss1024k
            -Xss1m
            -Xss1048576
        每个线程都有自己的栈，栈中的数据都是以栈帧的格式保存，在这个线程上正在执行的每个方法都各自对应着一个栈桢，
        栈帧是一个内存块，是一个数据集；
        不同线程所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧；
        如果当前的方法调用了其他方法，方法返回之际，当前栈帧会返回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，
        使得前一个栈帧重新成为当前栈帧；
        如果方法出现异常，并且没有处理的话，会导致栈帧弹出；

        栈的内部结构：
            栈帧中存储着：
               1、局部变量表
                定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量值，是值，不是变量名，这些数据也包括各类
                基本数据类型，对象引用以及返回地址（returnAdrees）类型;
                局部变量表所需的容量大小是在编译期就已经确定下来的，并保存在方法的code属性的maximum local variables数据项中
                在运行期是不会改变局部变量表的大小的

                方法嵌套调用的次数由栈的大小决定，一般来说，栈越大，方法嵌套次数越多；
                局部变量中的变量只在当前方法调用中有效，在方法执行时，虚拟机通过局部变量表完成参数值到参数变量列表的传递过程。
                当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁；

                非静态方法默认第一个局部变量就是当前对象 this

                关于slot的理解
                    参数值的存放总是在局部变量数组index0开始，到数组长度-1索引结束
                    局部变量表最基本的单位是slot(变量槽)
                    局部变量表中存放编译器可知的各种基本数据类型，引用类型，returnAddress类型的变量；
                    在局部变量表中，32位类型只占用一个slot(包括returnAddress类型)，64位的类型(long和double)占用两个slot
                    byte short char 在存储前被转换成int，boolean也被转为int，0表示false，非0表示true；
                    long和double则占据两个slot;
                    jvm会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中的局部变量值；
                    当一个实例方法被调用时，他的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上；
                    如果需要访问局部变量表中的一个64位的局部变量值时，只需要使用前一个索引即可；
                    如果当前栈帧是由构造方法或者实例方法创建的，那么该对象的引用this将会放在index为0的slot处，
                    其余的参数按照参数表顺序继续排列；


               2、操作数栈（或表达式栈）
                每一个独立的栈帧中除了
                局部变量表外，还包含一个后进先出的操作数栈；操作数栈在方法执行过程中，根据字节码指令
                往栈中写入数据或提取数据即压栈和弹栈。
                操作数栈主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。
                操作数栈就是jvm执行引擎的一个工作区，当一个方法执行的时候，一个新的栈帧也会被创建出来，这个方法的操作数栈就是空的；
                每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期间就已经确定了，保存在code属性
                的max_stack中；
                栈中的任何元素都可以是任意的java 数据类型
                32bit类型占用一个栈单位深度
                64bit类型占用两个栈单位深度
                操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的出栈和出栈操作来完成一次数据访问；

                具体来说就是：执行每一条指令之前，java虚拟机要求该指令的操作数已被压入操作数栈中，在执行指令时，java
                虚拟机会将该指令所需的操作数弹出进行诸如计算等操作，并且将指令的结果重新压入栈中

（这玩意就是指令地址）0 iconst_2  //将2存放到操作数栈(临时存储)，入栈
                1 istore_1  //将2取出并且存放到局部变量里，此时操作数栈就空了，出栈
                2 iconst_3  //将3存放到操作数栈(临时存储)，入栈
                3 istore_2  //存放到局部变量里，此时操作数栈就空了，出栈
                4 iload_1   //从局部变量表里取出来并且放到操作数栈
                5 iload_2   //从局部变量表里取出来并且放到操作数栈
                6 iadd      //将两个数取出来经过执行引擎的解释成机器指令，并拿到cpu进行计算，将结果又放到操作数栈
                7 istore_3  //将执行结果存放到局部变量
                8 return
                工作过程理解：经过执行引擎的翻译成机器指令，到cpu执行之后得到数据，再将数据压倒操作数栈里数据送到局部变量

                 如果被调用的方法有返回值，其返回值将会被压入当前栈帧的操作数栈中，并更新pc计数器中下一条需要执行的字节码指令；
                 public int getSum(){
                       int j = 2;
                       int k = 3;
                       int i = j + k;
                       return i;
                   }
                    0 iconst_2
                    1 istore_1
                    2 iconst_3
                    3 istore_2
                    4 iload_1
                    5 iload_2
                    6 iadd
                    7 istore_3
                    8 iload_3
                    9 ireturn


                   public void testGetSum(){
                       int i = getSum();
                       int j = 10;
                   }

                    0 aload_0  //直接将getsum方法的返回值加载到操作数栈中
                    1 invokevirtual #2 <com/sjd/controller/Test.getSum>
                    4 istore_1
                    5 bipush 10
                    7 istore_2
                    8 return




               3、动态链接 （或指向运行时常量池的方法引用）
                在java源文件被编译到字节码文件时，在调用时，当前字节码文件中的每个方法里的所有的属性和方法的引用都作为符号
                引用保存在class文件的常量池里，比如在一个方法里调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来
                表示的，那么动态链接的作用就是为了将该类的运行时常量池里的这些符号引用转换为方法体里加载的类的实例对象的直接
                引用(内存地址)；当jvm运行时，会将保存在class文件里的常量池放到方法区的常量池；

                为什么需要常量池?
                为了提供一些符号和常量，便于指令的识别
                jvm在运行程序时，会将变量以及方法的引用都作为常量存到常量池并分配一个符号引用，这样；
                class文件还比较小，用指令作为调用符号；

                      int num = 20;
                       public void methodA(){
                           System.out.println("Test.methodA");
                       }
                        解析后：
                        0 getstatic #3 <java/lang/System.out>  （这个就是具体指代常量池中代表的）
                        3 ldc #4 <Test.methodA>
                        5 invokevirtual #5 <java/io/PrintStream.println>
                        8 return


                       public void methodB(){
                           System.out.println("Test.methodB");
                           methodA();
                           num++;
                       }

                    解析后：
                     0 getstatic #3 <java/lang/System.out>
                     3 ldc #6 <Test.methodB>
                     5 invokevirtual #5 <java/io/PrintStream.println>
                     8 aload_0
                     9 invokevirtual #7 <com/sjd/controller/Test.methodA>
                    12 aload_0
                    13 dup
                    14 getfield #2 <com/sjd/controller/Test.num>
                    17 iconst_1
                    18 iadd
                    19 putfield #2 <com/sjd/controller/Test.num>
                    22 return
              方法的调用：
                在jvm中，经符号引用转换为调用方法的直接引用(对象的内存地址)与方法的绑定机制有关
                    静态绑定
                        当一个字节码文件被装载进jvm内部时，如果被调用的方法在编译期可知，且运行期保持不变，这种情况下将调用
                        方法的符号引用转换为直接引用的过程称之为静态绑定
                    动态绑定
                        如果被调用方法在编译期间无法被确定下来，也就是说，只能够在程序运行期间将调用方法的符号引用转换为直接引用，
                        由于这种转换过程具有动态性，因此被称之为动态绑定。

                        理解：具有多态的或者子类的方法时，使用父类或者接口调用方法时，这时在编译期就不能确定调用的是父类还
                        是子类，这就是晚期绑定，或者也就是动态绑定；
                    如果在java中不希望某个函数拥有虚函数的特征时，可以使用final来标注这个方法
                    非虚方法有哪些
                        静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法
                    其它称为虚方法
                    子类对象的多态性的使用前提：1、有类的继承关系 2、方法重写了

                    方法的调用：关于invokedynamic指令
                        invokedynamic指令，这是java为了实现【动态类型语言】支持而做的一种改进
                        但是在 java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM底层字节码工具来产生invokedynamic指令，
                        知道lambda表达式的出现，invokedynamic指令的生成，在java中才有了直接生成方式；

                        动态类型语言和静态类型语言：
                            区别在于对类型的检查是在编译期间还是运行期间，满足前者就是静态类型语言，反之就是动态类型语言；
                            再直白一点就是：静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，
                            js里面var a  这个a就是需要根据后面的的值才能确定a的类型；而java就属于静态类型的语言
                            变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征

               4、方法返回地址（或方法正常退出或者异常退出的定义）
                    存放调用该方法的pc寄存器的值；本质上，方法的退出就是当前栈帧出栈的过程，此时，需要恢复上层方法的局部变量表，操作数栈、
                    将返回值压入调用者栈帧的操作数栈，设置pc寄存器值等，让调用者方法继续执行下去。
                    正常完成和异常退出的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值



               5、一些附加信息
                    忽略



    jvm优化在哪里   方法区和堆是线程共同享有的，这是jvm优化的内存区；
    一个进程对应着一个jvm实例，一个jvm实例对应着一个运行时数据区，一个运行时数据区只有一个堆和方法区；
    jvm其实是一种规范，他的具体实现其实是有七种，其中sun公司实现的jvm叫hotspot，平常如果我们称的jvm就默认是sun公司的；

    查看jvm内存使用情况的工具：C:\Program Files\Java\jdk1.8.0_131\bin\jvisualvm.exe
    在方法结束后，堆中的对象不会被马上移除，仅仅在垃圾收集的时候才会被移除。堆是GC执行垃圾回收的重点区域；

    7、堆
        是存储的单位，数据怎么存放，放在哪；由三个区组成：新生区、养老区和永久存储区

        新生区由伊甸区、幸存0区和幸存1区；新生区是类的诞生、成长和消亡的区域，一个类在这里诞生，应用，最后被垃圾回收器结束生命
        新生区又分为两个部分：伊甸区和幸存者区，所有的类都是在伊甸区被new出来，幸存区有两个，0区和1区，当伊甸区空间用完时，
        程序又要创建对象，jvm垃圾回收器将对伊甸园区进行垃圾回收(YGC/Minor GC)，将伊甸区里的没有对象引用的对象进行销毁，
        然后将伊甸区的剩余对象移到幸存0区，此时伊甸园区是空的；然后再加载新的对象放到伊甸园区；如果伊甸区再次触发垃圾回收，此时上次
        0区幸存下来的对象也进行被动GC，然后将伊甸园区和幸存0区幸存下来的对象都放到幸存者1区；如果再次经历垃圾回收，此时会重新放入幸存者0区，接着再去幸存者1区。
        啥时候能去养老区呢？可以设置次数，默认是15次；

        如果0区或1区满了，再移动到养老区，如果养老区也满了，那么这时候将产生Gc（fullGc），进行养老区的内存清理，
        若养老区执行了full gc之后发现依然无法进行对象的保存，就会产生outOfMemoryError: Java heap space说明java虚拟机的堆内存不够，
        原因有二：
            1、java虚拟机的堆内存设置不够，可以通过-xms、-xmx来调整
            2、代码中创建了大量的大对象（内存连续的且较大的对象，例如较长字符串，数组），并且长时间不能被垃圾回收器收集(存在被引用)

        如果new的对象伊甸园区放不下去，然后经过YGC后还是放不下去，那就直接放入老年代的；如果老年代也放不下，那老年代就进行fullGC，
        如果gc完还放不下，那就outofmemoryerror吧


           System.out.println(Runtime.getRuntime().maxMemory()/1024/1024);这个可以查看jvm可用的最大内存
           byte[] b = new byte[1024 * 1024 * 2000];这个就可能发生内存溢出错误;需要占用大量连续内存空间的jaa对象是大对象，比如很长的字符串和数组

        养老区
            养老区用于保存从新生区筛选出来的java对象，一般池对象都在这个区域活跃

        永久区
            永久区是一个常驻内存区域，用于存放jdk所携带的class，interface的元数据，也就是说他存储的运行环境必须的类信息，被装载
            进此区域的数据是不会垃圾回收器回收掉的，关闭jvm才会释放此区域占用的内存
            如果产生outOfMemoryError:permGen space,说明是java虚拟机对永久代内存设置不够。一般出现这种情况，都是程序
            启动需要大量的第三方jar包。例如在一个tomcat下部署了太多的应用，或者大量的动态反射生成的类不断被加载，
            最终导致permGen占满


        堆内存调优简介
           堆空间设置大小
            -Xms  设置初始分配大小，默认为物理内存的 1/64  不涉及永久代区
            -Xmx  最大分配内存，默认为物理分配内存的 1/4  不涉及永久代区
            开始发设置中建议将初始堆内存和最大堆内存设置成相同的值，否则频繁扩容造成系统压力


            Runtime.getRuntime().maxMemory()//返回java虚拟机试图使用的最大内存量
            Runtime.getRuntime().totalMemory()//返回java虚拟机中的当前的内存总量，初始内存

            查看设置的参数：方式一 jps  /  jstat -gc 进程id
                          方式二 -XX:PrintGCDetails 输出详细的GC处理日志

            配置新生代与老年代在堆结构中的占比
                默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3  （不包含永久代）
                可以修改-XX:NewRatio =4,表示新生代占1，老年代占4，新生代整个堆的1/5 （不包含永久代）

            -XX:SurvivorRatio 用来调整新生代中的伊甸区和两个幸存区的比例，默认比例时8:1:1

       对象分配过程：概述


       jvm在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分的时候回收都是指新生代。
       因此GC按照回收的区域又分了两种类型，一种是普通GC(minor GC),一种是全局GC(major GC or Full GC),
       普通GC只针对新生代区里的伊甸园区，伊甸园区满的时候会触发minor GC，幸存区满不会触发minor GC；
       但是不意味着没有垃圾回收，当伊甸园区满的时候会将幸存者区也连带回收；
       全局GC针对老年代的GC，偶尔伴随对新生代的GC以及对永久代的GC；

       频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集


        MinorGC、MagorGC、FullGC
            jvm在进行GC时，并非每次都对上面三个内存（新生代、老年代、方法区）区域一起回收的，大部分时候回收的都是指新生代。
            针对hot spot vm的实现，它里面按照回收的区域又分为两大种类型：一种是部分收集(Partial GC),一种是整堆收集(Full GC)
            部分收集：不是完整收集整个java堆的垃圾收集。其中又分为：
                新生代收集(Minor GC),只是新生代(eden\s0\s1)的垃圾收集
                    触发机制：当新生代空间不足时，会触发  Minor GC，这里的新生代满指的是Eden代满，幸存区满不会触发GC（每次Minor GC会清理年轻代的内存）
                            因为Java对象大多数都具有朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也比较快。
                            Minor GC会引发STW(暂停用户线程)，等垃圾回收结束，用户线程才恢复运行，因为Minor GC速度很快，对性能影响较小。

                老年代收集(Magor GC),只是老年代的垃圾收集
                    目前，只有CMS GC会有单独收集老年代的行为。
                    注意，很多时候Magor GC会和Full GC混淆使用，需要具体分辨的是老年代回收还是整堆回收。
                    触发机制：老年代空间不足时，则触发Magor GC;Magor GC的速度一般会比Minor GC慢10倍以上，STW时间更长，
                        如果Magor GC后内存还是不足，则会OOM

                混合收集(Mixed GC)，收集整个新生代以及部分老年代的垃圾收集。

            整堆收集（Full GC）:收集整个java堆和方法区的垃圾收集
                触发机制：1、调用system.gc()，系统建议执行Full GC，但是不必然执行
                         2、老年代空间不足
                         3、方法区空间不足

                         说明：full gc是开发中或调优中尽量要避免的，这样暂停时间会短一些

            堆空间的分代思想：其实不分代是完全可以的，分代的唯一理由是优化GC性能，进而快速腾出空间出来

            堆空间内存分配策略：
                1、优先分配到Eden
                2、大对象直接分配到老年代(没有经过Minor GC，直接进入了老年代)
                    尽量避免程序中出现过多大对象
                3、长期存活的对象分配到老年代
                4、动态对象年龄判断
                    如果幸存区中相同年龄的所有对象大小的总和大于幸存区空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，
                    无需等到MaxTenuringThreshold中要求的年龄。
                5、空间分配担保
                    -XX:HandlePromotionFailure

            堆空间的参数设置：
                -XX:+PrintFlagsInitial 查看所有参数的默认默认值(即使修改了，也看到的是默认值)
                -XX:+PrintFlagsFinal    查看所有参数的最终值(可能初始值被修改，这样可以查看到最终值)
                -Xms:初始堆空间内存(默认为物理内存的1/64)
                -Xmx:最大堆空间内存(默认物理内存的1/4)
                -Xmn:设置新生代的大小(初始值和最大值)
                        例：-Xmn2g：设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。
                        持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，
                        Sun官方推荐配置为整个堆的3/8
                -XX:NewRatio 配置新生代与老年代在堆结构中的占比
                -XX:SurvivorRatio   设置新生代中的Eden和S0/S1空间的比例
                -XX:MaxTenuringThreshold    设置新生代中垃圾的最大年龄
                -XX:PintGcDetails   输出详细的GC处理日志
                -XX:HandlePromotionFailure 是否设置空间分配担保

        堆是分配对象存储的唯一选择吗？
            不是：如果经过了逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成“栈上分配”，这样就无需在堆上
                分配内存，也无需进行垃圾回收了，这也是最常见的对象的堆外存储技术；
        逃逸分析的基本行为就是分析对象动态的作用域：
                1、当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸；就看new的对象实体，而不是对象引用，是否有可能在方法外被调用；
                2、当一个对象再方法中被定义后，他被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中
                没有发生逃逸的对象，就可以分配到栈上，随着方法执行的结束，栈空间被移除；
                jdk 6u23后 hotspot默认开启了逃逸分析，栈上分配；
                使用-XX:+PrintEscapeAnalysis 查看逃逸分析的筛选结果

            结论：开发中能使用局部变量的，就不要使用在方法外定义了；
            使用逃逸分析，编译器可以对代码做如下自动优化：
            ***基于逃逸分析，执行引擎的编译器可对代码做如下优化：
                1、栈上分配
                    JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就有可能被优化成栈上分配；
                    分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收了；
                2、分离对象或标量替换
                    标量：是指一个无法再分解成更小的数据的数据，java的基本数据类型就是标量；
                        相对的，那些还可以分配的数据就是聚合量，Java中的对象就是聚合量，因此可以分解成聚合量和标量；
                        在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把对象拆解成若干个其中包含了
                        若干个成员变量来代替，这个过程就是标量替换；
                     好处：可以大大的减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了

                    标量替换参数设置：-XX:+EliminateAllocations  开启了标量替换（默认打开的），允许将对象打散分配到栈上

        代码优化以及堆的小结
            逃逸分析并不成熟；对象实例都是分配在堆上

对象的实例化
    创建的对象的几种方式
        1、new
        2、Class的newInstance   反射，只能调用空参的构造器
        3、Constructor的newInstance(xxx) 可以调用无参/有参的构造器
        4、使用clone() 不调用构造器，但是当前的类需要使用Cloneable接口，实现clone()
        5、使用反序列化
        6、第三方库Objenesis
    创建对象的步骤
        1、判断对象对应的类是否加载、链接、初始化
        2、为对象分配内存
        3、处理并发安全问题
        4、初始化分配到的空间：所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用
        5、设置对象的对象头：将对象的所属类(即类的元数据信息)、对象的hashcode和对像的GC信息、锁信息等数存储在对象的对象头中，这个过程
                          的具体设置方式取决于jvm实现
        6、执行init方法进行初始化：初始化成员变量，执行实例化代码块、类的构造器的调用，并把堆内对象的首地址赋值给引用变量
    对象的内存布局
        1、对象头
            包括两部分
                        1、运行时元数据：哈希值（内存地址）、gc分代的年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳
                        2、类型指针：指向元数据，确定该对象的所属类型
        2、实例数据
            它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承的字段）
            父类的变量会出现在子类的前面；相同宽度的字段分配在一起；

    对像的访问定位
        访问方式主要有两种：1、句柄访问
                         2、直接引用（hotspot采用的就是这种方式）
                                引用就是内存地址指向对象在堆里的内存，真正的对象里面保存着对象的类型指针，指向方法区里的类型

    执行引擎的作用以及工作过程
        执行引擎的任务就是将字节码指令解释/编译位对应平台上的本地机器指令才可以，简单来说，jvm中的执行引擎充当了将高级语言翻译为机器语言的翻译者；
        执行引擎在执行过程中究竟执行什么样的字节码指令完全依赖于PC寄存器；

    Java代码编译和执行的过程
        任何高级语言转变成机器码的过程都是要经过编译过程以及汇编过程

    JAVA是半解释半编译的语言
    因为执行引擎是通过解释器和编译器进行代码的执行的
    解释器：真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容翻译为对应平台的本地机器指令执行；
            当JAVA虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将字节码中的内容翻译成对应平台的本地机器指令执行。
    编译器：将字节码直接翻译成机本地器识别的机器指令

    为什么还需要解释器而不全是用编译器呢？
    当程序启动后，解释器可以马上发挥作用，省去编译时间，立即执行。编译器要想发挥作用，把代码编译成本地代码，
    需要一定的执行时间，但编译为本地代码后执行效率高。
    当JAVA虚拟机启动时，解释器可以首先发挥作用，二不必等待即时编译器全部编译完成后在执行，这样可以省去许多不必要的编译时间，
    随着时间的推移，编译器发挥作用，根据热点探测功能，把越来越多的代码编译成本地代码，获得更高的执行效率。

    热点代码探测何时JIT
    JAVA语言的编译期其实是一段不确定的操作过程，因为它可能是一个前端编译器 把JAVA文件编译成字节码文件的过程；
    也可能是指虚拟机的后端运行期编译器，把字节码转变成机器码的过程；还可能是指使用静态提前编译器把JAVA文件编译
    成本地机器码的过程；

    热点代码：关于那些何时使用JIT需要根据代码的被调用频率而定，关于那些需要被编译成本地代码的字节码也被称之为热点代码
    ，JIT编译器会针对那些热点代码做出深度优化，将其编译成对应平台的本地机器指令，以提升JAVA性能。

    一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以称之为热点代码，因此都可以通过JIT编译器翻译成
    本地机器指令。
    一个方法要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准，必须明确一个阈值，这主要靠热点探测功能，
    hotspot热点探测功能是基于计数器的热点探测。
    hotspot将会为每一个方法都建立两个不同类型的计数器，分别是方法调用计数器和回边计数器。

    方法计数器：统计方法的调用次数
    回边计数器：统计方法体内循环体的执行循环次数
    热度衰减半衰周期
      如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法被调用的次数，
      当超过一定的时间限度，如果方法的调用次数任然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会减少一半，
      这个过程称为方法调用计数器热度衰减，而这段时间就称作此方法统计的半衰周期进行。热度衰减的动作是在虚拟机进行垃圾回收时顺便
      进行的，可使用虚拟机参数-XX:-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行
      时间足够久，绝大部分方法都会被编译成本地代码。
    另外，还可以使用-XX:CountetHalfLifeTime参数设置半衰周期的时间，单位秒。

    回边计数器
      它的作用是统计一个方法中循环体代码执行的次数。
    缺省情况下，hotspot采用解释器和编译器并存的架构，当然开发人员可以根据具体应用场景，通过命令显式为JAVA虚拟机指定运行
    时的模式
      java -Xint -version:完全采用解释器模式执行程序
      java -Xcomp -version:完全采用即时编译器模式执行程序，如果即时编译器出现问题，解释器会介入执行
      java -Xmixed -version:采用解释加编译混合模式，默认

    hotspot虚拟机内嵌了两个即时编译器，分别是client以及Server编译器，简称c1和c2，
    c1(client)编译器会对字节码进行简单可靠的优化，耗时短，以达到更快的编译速度。
    c2（server）编译器会进行耗时较长的优化，以及激进优化，但代码的执行效率更高。
    一般来讲，JIT编译器编译出来的机器码性能比解释器高。
    C2编译器启动时长比c1编译器慢，系统稳定后，C2执行速度远远快于C1编译器。

------------------------------------------
    String 类型jdk1.8以及之前使用char数组存储，jdk1.9时改用byte数组保存，相关的类也是使用同样的改变;
        字符串常量池中是不会存储相同内容的字符串的；
        String pool是一个固定大小的HashTable，默认值大小长度是1009，如果放进String pool的String非常多，就会造成
        hash冲突严重，从而导致链表很长，而链表很长直接会造成调用String.intern时性能会大幅下降。
            使用-XX:StringTableSize可设置StringTable的长度
            在jdk1.6中StringTable的大小是固定的，就是1009 的长度，所以如果字符串常量池中的字符串过多会造成效率下降很快，
            StringTablleSize设置没有要求；
            在jdk7中，StringTable的长度默认值是60013，1009是可设置的最小值；

    String的内存分配
        String类型的常量池比较特殊，它的主要使用方法有两种
            1、直接使用双引号声明出来的String对象会直接存储在常量池中；
            2、如果不是使用双引号声明的String对象，可以使用String提供的intern方法

    字符串的拼接操作
        1、常量与常量的拼接结果在常量池，原理时编译器优化
        2、常量池中不会出现相同内容的常量
        3、只要其中一个是变量，结果就在堆中，拼接的原理是StringBuilder，然后再toString成String对象
        4、如果拼接的结果调用intern方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址
        5、new String("asd");这个字符串存在堆里一份，是字符a、s、d数组，并且在字符串常量池也有一份asd的字面量

        String s1 = "javaee";
        String s2 = "hadoop";

        String s3 = "javaeehadoop";
        String s4 = "javaee" + "hadoop"; //编译成字节码的时候就直接变成了“javaeehadoop” ，称为编译期优化，放在常量池

        //如果拼接符号的前或者后出现了变量（没有final修饰），或者是以new的形式出现的，则类似于在堆空间new了一个字符串对象，具体内容是拼接后的内容
        String s5 = s1 + "hadoop";
        String s6 = "javaee" + s2;

        String s7 = s1 + s2;
        如下s1+s2的细节
        StringBuilder s = new StringBuilder();
        s.append("javaee");
        s.append("hadoop");
        s.toString();   -->类似于new String("javaeehadoop");



        //intern方法作用：判断字符串常量池中是否存在javaeehadoop值，如果存在，则返回常量池中javaeehadoop的地址；
        //如果字符串常量池中不存在javaeehadoop，则在常量池中加载一份javaeehadoop，并返回此对象的地址
        String s8 = s6.intern();

        final String s9 = "a";
        final String s10 = "b";
        String s11 = "ab";
        String s12 = s9 + s10;//被final修饰的变量就不能称为变量了，所以拼接符号两边都被final修饰的话，
        // 适用于编译期优化，也就是说在编译期间就拼接了，相当于“a” + “b”；但是要有一个是变量底层就还是使用StringBuilder；
        //平常如果可以的话建议使用final，因为在编译期间就可以编译了
        System.out.println(s11 == s12);//true

        拼接操作和append操作效率
            public static void main(String[] args) {
                long start = System.currentTimeMillis();
                method1(100000);//耗时 10969
                method2(100000);//耗时 8
                long end = System.currentTimeMillis();
                System.out.println(end -start);
            }

            public static void method1(int i){
                String src = "";
                for (int j = 0; j < i; j++) {
                    src= src + "a";//每循环一次都会创建一个stringBuider和一个String
                }
            }

            public static void method2(int i){
                //自始至终只会创建一个StringBuilder
                StringBuilder src = new StringBuilder();
                for (int j = 0; j < i; j++) {
                    src.append("a");
                }
            }
        StringBuilder改进空间：由于底层维护的是一个char数组，初始容量16，如果append的量比较大的话，就会扩容，继续append，
            又要扩容，扩容实际上是重新new了一个容量更大的char数组，这样如果屡次扩容，以前的插入数组也会在堆中占用内存；
            所以可以在基本确定拼接的字符串长度时，可以在new  StringBuilder时，就直接使用构造器StringBuilder(int capacity)

        intern()的理解
            如果不是用双引号声明的String对象，可以使用String提供的intern方法；intern方法会从字符串常量池中查询当前字符串是否存在，
            若不存在，就会将当前字符串放入常量池中。也就是说在任意的String对象上调用intern方法，其返回的结果所指向的类实例必须和直接以
            常量形式出现的字符串实例完全相同。
            String s1 = src.append("a").append("b").toString();//这个返回的是"ab"，但是其实在字符串常量池里没有这个值
            String s1 = src.append("a").append("b").toString().intern();//但是这样的话就会将"ab"放入字符串常量池，
                                                                        //并返回这个字符串在字符串常量池里的内存地址

        String s3=new String(“zhangsan”);
        String s4=new String(“zhangsan”);
        s = s3 + s4;
        两字符串相加本质就是()你可以用Xjad工具查看你编译后的代码：生成StringBuilder对象将其拼接起来再调用toString()方法返回新
        的字符串hellowzhangsan（hello就是s1指向常量池中的字符串复制过来的，zhangsan也是s2指向常量池中的字符串复制过来的，
        都放到StringBuilder对象中的数组里）(调用tostring()方法生成新的String，其实就是将StringBuilder中数组里的字符全都
        拷贝到新String里的数组里)，堆中字符串是一个value数组，里面装着hellozhangsan这些字符，但它不会把hellozhangsan整个字符串放
        到常量池中。

        StringBuilder src =  new StringBuilder();
       String s1 = src.append("a").append("b").toString(); //这里的toString其实没有在字符串常量池里创建“ab”字符串
       String s2 = "ab";
       System.out.println(s1 == s2);//false

        StringBuffer是一次性生成"abc"字符串，没有中间过渡的字符串；主要是StringBuffer底层的字节数组没有final修饰
        StringBuffer s2 = new StringBuffer();
        s2.append("a");
        s2.append("b");
        s2.append("c");

        使用intern()的执行效率：空间上使用的内存低，可以节省内存
        String s = new String("asd");//先在堆里开辟内存，然后将“asd”放入常量池，然后将堆里字符串的地址给s
        String s = new String("asd").intern();//先在堆里开辟内存，然后将“asd”放入常量池，然后将常量池的地址给s，
                                              //这样在堆里的内存由于没有引用就会被gc掉，只留下常量池开辟的内存，可以节省内存


    StringTable字符串常量池的垃圾回收：
        -XX:PrintStringTableStatistics 打印字符串常量池中的统计信息


       GC算法总体概述:
            垃圾标记阶段的算法之引用计数算法
                1、垃圾标记阶段：对象存活判断
                    在堆里存放着几乎所有的java对象实例，在GC执行垃圾回收前，首先需要区分出内存中那些是存活对象，哪些是已经死亡的，
                    只有被标记为已经死亡，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段；
                    那么在jvm中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何存活的对象继续引用时，就可以宣判为死亡；

                    判断对象存活一般有两种方式；引用计数算法和可达性分析算法
                    方式一：引用计数法
                        引用计数法比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。
                        对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1.只要对象A的
                        引用计数器的值为0，就表示对象A不可能再被使用，可进行回收；

                        优点：实现简单，垃圾对象便于表示；判定效率高，回收没有延迟性；

                        缺点：无法处理引用循环的情况，这是一条致命的缺陷，导致在java的垃圾回收器中没有使用此类算法。

                     方式二：可达性分析算法
                        该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。
                        所谓GC Roots根集合就是一组必须活跃的引用。
                        基本思路：
                            可达性分析算法是以根对象集合为起始点，按照从上而下的方式搜索被根对象集合所连接的对象是否可达。
                            使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接的连接着，搜索所走过的路径称为引用链。
                            如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象。
                            在可达性分析算法中，只有能够被根对象直接或间接连接的对象才是存活对象。

                        在Java语言中，GC roots包括以下几类元素
                            1、虚拟机栈中引用的对象
                                比如各个线程被调用的方法中使用到的参数、局部变量等
                            2、本地方法栈内引用的对象
                            3、方法区中类静态属性所引用的对象
                                比如：Java类的引用类型静态变量
                            4、方法区中常量引用的对象
                                比如：字符串常量池里的引用
                            5、所有被同步锁synchronized持有的对象
                            6、Java虚拟机内部的引用
                                基本数据类型对应的Class对象，一些常驻的异常对象(如空指针异常，内存溢出错误)，系统
                                类加载器。
                            7、反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码的缓存等。

                            小技巧：由于Root采用栈方式存放变量和指针，所以如果一个指针(引用)，他保存了堆内存里面的对象地址，但是自己
                            又不存放在堆内存里面，那他就是一个Root；

                            如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一致性的快照中进行，这点不满足的话结果的准确性
                            就不能保证；这个点也是导致GC进行时必须STOP THE WORLDd额一个重要原因

                        对象的finalization机制
                            Java语言提供了对象终止机制来允许开发人员提供对象被销毁前的自定义处理逻辑。
                            放垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。

                            finalize()方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、
                            套接字和数据库连接等。

                            永远不要主动调用finalize()方法，应该交给垃圾回收机制调用，里有包括以下几点
                                1、在finalize()时，可能会导致对象复活
                                2、finalize()方法的执行时间是没有保障 的，他完全由GC线程决定，极端情况下，若不发生GC，
                                则finalize()方法则没有机会执行
                                3、一个糟糕的finalize()方法会严重影响GC性能。

                                由于finalize方法的存在，虚拟机 中的对象一般处于三种可能状态

                                如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了，一般来说，此对象需要被回收；
                                但事实上也不是非死不可的，这时候他们处于缓刑阶段。一个无法触及的对象在某个条件下可能复活自己，如果这样，
                                那么对他的回收就是不合理的，，为此，虚拟机中的对象可能的三种状态，如下：
                                1、可触及的：从根节点开始，可以到达这个对象。
                                2、可复活的：对象的所有引用都被释放，但是对像有可能在finalize()中复活
                                3、不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象
                                不可复活，因为finalize()只会被调用一次。

                            判定一个对象ObjA是否可回收，至少要经过两次标记过程：
                                1、如果对象ObjA到GC roots没有引用链，则进行第一次标记。
                                2、进行筛选，判断此对象是否有必要执行finalize()方法
                                    1、如果对象ObjA没有重写过finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为没有
                                       必要执行，对象ObjA被视为不可触及的；
                                    2、如果对象ObjA重写了finalize()方法，且还未执行过，那么对象ObjA会被插入到F-QUEUE队列中，由一个虚拟机自动创建的、
                                       低优先级的Finalizer线程触发其finalize（）方法执行；
                                    3、finalize()方法是对象逃脱死亡的最后机会，稍后GC会对队列中的对象进行二次标记如果对象ObjA在finalize()方法中与
                                       引用链上的任何一个对象建立了联系，那么在二次标记时，那么对象ObjA会被移出“即将回收集合”，之后，对象再次出现没有引用的情况，
                                      。在这个情况下，finalize()不会被再次调用，对象ObjA直接变成不可触及的状态，也就是说，一个对象只能调用一次finalize方法；


              清除阶段
                1、标记清除算法
                    执行过程：当堆中的有效内存被耗尽的时候，就会停止整个程序（STW）,然后进行标记，清除
                    标记：收集器从引用根节点开始遍历，标记所有被引用的对象，一般是在对象的header中记录为可达对象；
                    清除：收集器对堆内存从头到尾进行线性遍历，发现某个对象在其header中没有标记为可达对象，则将其回收；

                    优缺点：
                        缺点：
                            1、效率不高
                            2、在进行Gc的时候，需要停止整个应用程序，导致用户体验差
                            3、这种方式清理出来的空闲内存是不连续的，容易产生内存碎片。需要维护一个空闲列表

                        注意：何为清除
                            这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里，下次有新对象
                            需要加载时，判断垃圾的位置空间是否足够，如果足够，就存放；

                2、复制算法
                    核心思想：将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象 复制到未被使用的
                            内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收
                            例如：新生区中的from区和to区的GC就是这样实现的
                     优点：
                        1、没有标记和清除过程，实现简单，运行高效
                        2、复制过去以后保证了内存的连续性，不会出现碎片问题

                     缺点：
                        1、需要两倍的内存空间
                        2、对于G1这种分拆称为大量region的GC，复制而不是移动，意味着GC需要维护region之间的对象引用关系，不管是内存
                           还是时间开销也不小
                            特别的：如果系统中的存活对象很多，那就不会很理想，因为复制算法需要复制的存活对象数量并不会很大，或者说非常低才行
                                    所以老年代就不适用于这个算法，效率很低

                    为对象分配内存：内存规整时，通过指针碰撞分配；
                                  内存不规整时，jvm会有一个空闲列表，把需要清除的对象地址保存在空闲的地址列表里，下次有新对象
                                  需要加载时，判断垃圾的位置空间是否足够，如果足够，就存放
                            何为指针碰撞：如果内存空间以规整和有序的方式分布，即有用和未用的内存都各自在一边，
                                        彼此之间维系着一个记录下一次分配的起始点的标记指针，当为新对象分配内存时，
                                        只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞。

                3、标记-压缩算法
                    复制算法的高效性是建立在存活对象少、垃圾对象多的前提下。这种情况在新生代区经常发生；
                    但是在老年代，常见的情况是存活对象多，所以如果依然坚持使用复制算法，复制的成本较高。因此基于老年代的垃圾回收特性，
                    需要使用其他算法--标记压缩算法
                    执行过程
                        1、第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象
                        2、内存不需要分成两部分，将所有存活对象压缩到内存的一端，按顺序排放，之后，清理边界外所有空间，不用进行复制，直接进行压缩到内存的一端
                    优点：
                        1、消除了标记清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，jvm需要持有一个
                           内存的起始地址即可
                        2、消除了复制算法中，内存减半的高昂代价
                    缺点：
                        1、从效率上来说，标记-整理算法要低于复制算法
                        2、移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址
                        3、移动过程中，需要全程暂停用户应用程序，即STW

                分代收集算法(目前主流采用)
                    目前几乎所有的GC都是采用分代收集算法执行垃圾回收的；
                    在hotspot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点；
                    年轻代：
                        特点：区域相对老年代较小，对象生命周期短，存活率低，回收频繁。
                        这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于
                        年轻代的回收
                    老年代：
                        特点：区域较大，对象生命周期长，存活率高，回收不及年轻代频繁。
                        这种情况存在大量存活率高的对象，复制算法明显变得不适合，一般是由标记-清除或者标记-压缩的混合实现。

          内存泄露
            也称作存储渗漏。严格来说，只有对象不会再被程序用到了，但是gc又回收不到他们的情况，才叫做内存泄漏。

            但实际情况很多时候有些不太好的实践或疏忽，会导致对象的生命周期变得很长甚至OOM，也就可以叫做宽泛意义上的
            内存泄露；譬如本可以声明在方法里面的对象被生命成了成员变量，或者是静态变量更甚至是静态常量，这样就大大延长了对象的
            生命周期。
            资源如果没有关闭，也会造成内存泄露；
          Stop the World
            STW事件和采用哪款GC无关，所有的GC都有这个事件；Stw是jvm在后台自动发起和自动完成的，在用户不可见的情况下，把用户
            正常的工作线程全部停掉。
            开发中尽量不要使用system.gc();会导致stw的发生
          程序中的并行与并发
            并发：在操作系统中，是指“一个时间段中”有几个程序都处于启动运行和运行完毕之间，且这几个程序都是在同一个处理器上运行。
                并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段，然后在这几个时间片段之间来回切换，
                每个时间片段执行某个线程的一段程序，，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户梵珏是多个
                应用程序同时进行

            并行：当系统有一个以上的CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程之间
                互不抢占CPU资源，可以同时进行，我们称之为并行。

                其实决定并行的因素不是cpu数量，而是cpu的核心数量，比如一个cpu多个核也可以并行；

       引用的类型
        强引用：可达的；就是new 出来的对象赋值给了一个变量，我们在开发时，99%都是强引用，强引用不回收；
        软引用：可达的；内存足够时，不会回收只被软引用关联着的可达对象；内存不够时，会回收只被软引用关联着的可达对象
        弱引用：可达的，垃圾回收器一旦发现了只具有弱引用的对象，不管当前内存是否足够，都会回收他的内存
            Product a  = new Prodect();
            Map<Product,Integer> map = new HashMap<>();
            map.put(a,1);
            a = null;
            此时map中的key和Gc roots,就是弱引用了；这个product就是弱可达对象


      吞吐量：
        吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间 + 垃圾收集时间)
        比如：虚拟机总共运行100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%;
        吞吐量优先意味着在单位时间内，STW的时间最短
      暂停时间：
        是指一个时间段内应用程序线程暂停，让Gc线程执行的状态
        例如，GC期间100毫秒的暂停时间意味着在这100ms期间没有应用程序线程是活动的
        暂停时间优先意味着尽可能让单次STW的时间最短

        在设计gc算法时，我们必须明确我们的目标，一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），
        或尝试找到二者的平衡。
        现在标准，在最大吞吐量优先的情况下，降低停顿时间。

垃圾回收器
    G1,ZGC


解读Class文件的三种方式
    1、字节码文件里面是什么？
        字节码文件是一种二进制的类文件，他的内容是jvm的指令，而不像C、C++经由编译器直接生成编译码

    2、什么是字节码指令
        jvm的指令由一个字节长度的、代表着某种特定操作含义的操作码（opcode）以及跟随其后的零至多个代表此操作
        所需参数的操作数(operand)所构成，虚拟机中许多指令并不包含操作数。

  class文件结构（解析后）
    魔数
        每个class文件开头的四个字节的无符号整数称为魔数；他的唯一作用就是确定这个文件是否为一个能被虚拟机接受的有效的合法的Class文件。
        魔数值固定OXCAFEBABE
    Class文件版本号
        紧接着魔数的四个字节就是Class文件的版本号，同样也是四个字节，第五和第六个字节代表编译的新版本号minor_version，而第七和第八个
        字节就是编译的主版本号major_version(就是jdk版本)
        他们共同构成了class文件的格式版本号
        java的版本号是从45开始的，jdk1.1之后的每个jdk大版本发布主版本号向上加1；
        不同版本的java编译器编译的class文件对应的版本是不一样的。目前高版本的java虚拟机可以执行低版本编译器生成的Class文件，
        但是低版本的jvm不能执行高版本编译的class文件，否则jvm会报unSupportedClassVersionError异常。(向下兼容)

    常量池
        在版本号之后，紧跟着的是常量池的数量(常量池计数器)，以及若干个常量池表项
        常量池中常量数量是不固定的，所以在常量池的入口处需放置一项u2类型的无符号数，代表常量池容量计数值(constant_pool_coount)
        与java语言习惯不一样的是，这个容量计数是从1开始；
        类型              名称                  数量
        u2              constant_pool_coount   1
        cp_info(表)      constant_pool        constant_pool_coount-1
        常量池表项中，用于保存保存编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中

        常量池表
            constant_pool是一种表结构，以1 到 constant_pool-1为索引，表明了后面有多少个常量项。
            主要存放字面量和符号引用
                字面量：文本字符串和声明为final的常量值
                符号引用：
                    1、类和接口的全限定名：
                        com/atguigu/test/Demo这个就是类的全限定名，仅仅是把包名的“.”替换为“/”，在使用时最后一般会加入一个
                        “;”，表示全限定名结束；
                    2、字段的名称和描述符

                    3、方法的名称和描述符

                    简单名称：简单名称是指没有类型和参数修饰的方法或者字段名称，上面例子中的类的add()方法和num字段的简单名称就
                             是add和num
                    描述符：描述符的作用就是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和方法的返回值。


    class文件版本
    常量池
    访问标志()
    类索引、父类索引、接口索引集合
    字段表集合
    方法表集合
    属性表集合














           复制算法：MinorGC
            zaiGC开始的时候，对象只会存在Eden区和名为From的Survivor区，Survivor区To是空的，紧接着进行GC，Eden区中所有存活的对象
            都会被复制到to，而在from区，仍存活的对象会根据他们的年龄值来决定去向，年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置，默认值 15)
            的对象会被移送到老年代中，没有达到阈值的对象会被复制到to区；经过这次GC后，Eden区和from区已经被清空，这个时候from区和to区会
            交换他们的角色，即from变成to，to变成from，不管怎样，都会保证to区是空的，Minor GC会一直重复这样的过程，直到to区被填满，to区被填满后，
            会将所有对象直接移动到老年代中。一般eden区内存和两个Survivor区内存是8：1：1；

            优点：不会产生内存碎片，完整度高
            缺点：浪费了10%的内存


           标记清除/标记整理算法：FullGC又叫MajorGC
             标记：从根集合开始扫描，对存活对象进行标记
             清除：扫描整个内存空间，回收未被日标记的对象

             缺点：效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址，从效率上来说，标记/整理算法要低于复制算法



垃圾回收相关概念
    System.gc()的理解：
        在默认情况下，通过 System.gc()或者RunTime.getRuntime().gc()的调用，会显式的调用Full Gc，同时对老年代和新生代
        进行回收，尝试释放被丢弃对象占用的内存。

        然后 System.gc()的调用无法保证对垃圾收集器的调用。
















