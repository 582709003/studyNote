springboot引入
    <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
    </plugin>
    插件，本地测试时，springboot就会默认将应用打成包含有启动需要的所有jar包以及环境的可执行jar包，
    然后将可执行jar包部署到springboot自带的内置tomcat

springboot特点
    1、依赖管理
       1、父项目做依赖管理
       2、开发导入stater场景启动器
       3、无需关注版本号，自动版本仲裁
       4、可以修改版本号
        <properties>
            //可以覆盖上面声明的版本号
            <java.version>1.8</java.version>
        </properties>

    2、自动配置
        1、自动配置tomcat
            譬如我们引入 <groupId>org.springframework.boot</groupId>
                       <artifactId>spring-boot-starter-web</artifactId>web应用场景就会自动引入tomcat依赖
        2、自动配好springmvc
            引入<groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-web</artifactId>就自动引入springmvc的所有组件并自动配好springmvc
                常用组件
        3、自动配好web常见功能
            如字符编码问题
        4、默认的额包结构
            主配置类所在包及其子包下的组件都会被默认扫描注册
        5、各种配置拥有默认值
        6、按需加载所有自动配置项
            引入了哪个stater，这些场景的自动配置才会生效
            所有stater启动器里面都会依赖spring-boot-starter，核心依赖，包括auto-configuration , logging和YAML。
            springboot所有自动配置功能都依赖这个
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-autoconfigure</artifactId>
            这个包里的配置类如果发红的话，说明还没有引入响应的stater，所以不会自动配置，带我们引入了这些stater后才会开启默认配置
            这个里面，这个里面有很多自动配置的包，可以打开看看

@Configration
    1、使用@Bean标注在方法上给容器注册组件，默认也是单例的
    2、配置类本身也是组件3
    @Configuration(proxyBeanMethods = true)
        proxyBeanMethods = true :使用代理bean的方法，当为true时，当调用配置类里面的诸如cat()以及user()生成bean的方法时，
        首先会去容器里面查找有没有此类型的对象，如果有就使用此对象；
        相反当为false时，直接调用cat()方法时，其实就是new了一个对象，而不是从容器里拿
        @Configuration(proxyBeanMethods = true)
        public class MyConfig {
            @Bean
            public User user(){
               User u = new User();
               u.setCat(cat());
                return u;
            }

            @Bean
            public Cat cat(){
                return new Cat();
            }
        }


  @Import注解须知
  1、@Import只能用在类上 ，@Import通过快速导入的方式实现把实例加入spring的IOC容器中，
        可以标注在容器里的组件上(能被ioc容器扫描到的组件上)
  2、加入IOC容器的方式有很多种，@Import注解就相对很牛皮了，@Import注解可以用于导入第三方包 ，当然@Bean注解也可以，
    但是@Import注解快速导入的方式更加便捷
  3、@Import注解有三种用法
  @Import的三种用法主要包括：
  1、直接填class数组方式
  2、ImportSelector方式【重点】
  3、ImportBeanDefinitionRegistrar方式



  2.1、第一种用法：直接填class数组
  直接填对应的class数组，class数组可以有0到多个。
  语法如下：
  @Import({ 类名.class , 类名.class... })
  public class TestDemo {

  }
  对应的import的bean都将加入到spring容器中，这些在容器中bean名称是该类的全类名 ，比如com.yc.类名

  2.2、第二种用法：ImportSelector方式【重点】
  这种方式的前提就是一个类要实现ImportSelector接口，假如我要用这种方法，目标对象是Myclass这个类，分析具体如下：
  创建Myclass类并实现ImportSelector接口
  public class Myclass implements ImportSelector {
  //既然是接口肯定要实现这个接口的方法
      @Override
      public String[] selectImports(AnnotationMetadata annotationMetadata) {
          return new String[]{"com.example2021.springboot.domin.Cat"};
      }
  }
  @Configuration(proxyBeanMethods = true)
  @Import(Myclass.class)
  public class MyConfig {
  }


  分析实现接口的selectImports方法中的：
  1、返回值： 就是我们实际上要导入到容器中的组件全类名【重点 】
  2、参数： AnnotationMetadata表示当前被@Import注解给标注的所有注解信息【不是重点】

2.3、第三种用法：ImportBeanDefinitionRegistrar方式
同样是一个接口，类似于第二种ImportSelector用法，相似度80%，只不过这种用法比较自定义化注册，具体如下：
第一步：创建Myclass2类并实现ImportBeanDefinitionRegistrar接口
public class Myclass2 implements ImportBeanDefinitionRegistrar {
    @Override
    参数分析：
    第一个参数：annotationMetadata 和之前的ImportSelector参数一样都是表示当前被@Import注解给标注的所有注解信息
    第二个参数表示bean的定义信息的注册器
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        RootBeanDefinition rbd = new RootBeanDefinition(User.class);
        registry.registerBeanDefinition("user",rbd);
    }
}

 @Configuration(proxyBeanMethods = true)
  @Import(Myclass2.class)
  public class MyConfig {
  }


  3、@Import注解的三种使用方式总结
  第一种用法：@Import（{ 要导入的容器中的组件 } ）：容器会自动注册这个组件，id默认是全类名
  第二种用法：ImportSelector：返回需要导入的组件的全类名数组，springboot底层用的特别多【重点 】,id默认是全类名
  第三种用法：ImportBeanDefinitionRegistrar：手动注册bean到容器,id是自定义的
  以上三种用法方式皆可混合在一个@Import中使用，特别注意第一种和第二种都是以全类名的方式注册，而第三中可自定义方式。
  @Import注解本身在springboot中用的很多，特别是其中的第二种用法ImportSelector方式在springboot中使用的特别多，尤其要掌握

@Bean注解注册的bean的id是以方法名称来作为beanid ,
@Import注解以当前类的完整路径地址注册 ，相比来说@Import注入类更加简单

@Conditional
    条件装配：满足Conditional指定的条件，则进行组件注入,又很多派生注解

@ImportResource
    原生配置文件导入；当有一个原生的spring.xml,文件里有很多bean的定义，但是这个文件即使写好之后放在类路径里，他也不会
    将配置文件申明的bean注入到容器；这时我们可以直接在配置类上使用这个注解引入原生的配置文件也是可以的；

@propertySource:加载指定路径的propert文件,application.properties文件会自动加载，但是一些自定义名字的属性文件加载不进来
                需要引入


属性配置绑定javaBean
    如何使用Java读取到的properties文件中的内容，并且把它封装到javaBean中
    1、@ConfigurationPropeties，默认从全局配置文件中获取值，在类上添加此注解并且添加@Component，
        只有在容器内的组件才能被springboot提供强大的功能
    2、在配置类上标注@EnableConfigurationProperties(Cat.class)，并且在Cat.class上添加@ConfigurationProperties注解，
        Cat类上不用添加@Component
      //1、开启cat的属性配置功能，也就是cat的@ConfigurationPropeties功能开启
      //2、将cat这个组件注入容器内
      这个注解一个使用场景：如果引用的cat.class是第三方jar包里的，这个cat.class类上只标注了@ConfigurationPropeties，
      那我们想把它引进容器咋办，我们只能通过在我们的配置类上添加@EnableConfigurationProperties(Cat.class)注解就可以了，
      并且还可以开启cat的自动属性配置功能


自动配置原理
    先从@SpringBootApplication这个注解看起
    此注解由
        @SpringBootConfiguration
        @EnableAutoConfiguration
        @ComponentScan  组成，其中@EnableAutoConfiguration重要

    @EnableAutoConfiguration
        由@AutoConfigurationPackage和@Import({AutoConfigurationImportSelector.class}) 组成
        先看@AutoConfigurationPackage注解

    @AutoConfigurationPackage
        由@Import(AutoConfigurationPackages.Registrar.class)组成
        这个是将自定义的组件注入容器内
        进入Registrar.class，由一个方法registerBeanDefinitions
        此方法是将某一个包下(主程序所在包)的所有组件批量注入到容器,

    @Import({AutoConfigurationImportSelector.class})
    这个是将启动器stater导入容器
        selectImports方法中获取所有要导入的组件，是通过getAutoConfigurationEntry方法获取的，然后封装成string数组返回，
        利用getAutoConfigurationEntry方法给容器中批量导入组件
        上面这个方法又通过getCandidateConfigurations这个方法获取到所有需要导入到容器的组件
        利用工厂加载器3
          private static Map<String, List<String>> loadSpringFactories(@Nullable ClassLoader classLoader) {
            获取到所有组件
       从META-INF/spring.factories这个地方加载组件，默认扫描我们当前系统里面所有这个META-INF/spring.factories位置的文件
        spring-boot-autoconfigure-2.3.4.RELEASE.jar这个包也有这个文件
        这个文件里面由127个自动配置的配置类，虽然有这么多配置默认全部加载，但并不是全部生效，最终会按照“条件装配”规则配置；
        例如
        @ConditionalOnBean({JobLauncher.class})   //JobLauncher.class 这个类都没有导入，所以这个配置类不会生效
        @EnableConfigurationProperties({BatchProperties.class})
        @Import({BatchConfigurerConfiguration.class})
        public class BatchAutoConfiguration {}

        springboot默认会在底层配置好所有的组件，但是如果用户自己配置了就以用户的优先，因为用户配置的组件会优先加载到容器里，
        所以当springboot自带的bean上添加了诸如@ConditionalOnMissingBean(xxx.class)时，此时xxx.class就已经优先加载，所以
        springboot自带的配置就不会再加载到容器
            @Bean
            @ConditionalOnMissingBean({ExitCodeGenerator.class})
            public JobExecutionExitCodeGenerator jobExecutionExitCodeGenerator() {
                return new JobExecutionExitCodeGenerator();
            }


        总结：
            1、springboot会优先加载所有的自动配置类
            2、每个自动配置类按照条件进行生效
            3、生效的配置类就会给容器注入很多组件
            4、只要容器中有这些组件，那么就相当于有这些功能了
            5、只要由用户自己配置的，就以用户配置的优先


       开发工具
        lombok：是为类在编译期添加get、set等方法
                也可以在类上添加@Slf4j,然后直接使用log.info("");  log.error(""); 等等


        dev_tools
           项目里导入jar包
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-devtools</artifactId>
                <version>2.4.3</version>
            </dependency>
            修改java文件，jsp文件，以及属性文件等之后重新编译一下就会重新启动tomcat


 springboot核心功能
    1、yaml文件基本语法
        key: value  kv之间有空格
        大小写敏感
        使用缩进表示层级关系
        缩进不允许使用tab，只允许空格
        缩进的空格数不重要，只要相同层级的元素左对齐即可
        # 表示注释
        字符串无需加引号，如果要加，''和""表示字符串内容会被转义/不转义

      数据类型如何书写
        对象：键值对的集合。map、hash、set、obeject
            行内写法
                k: {k1:v1,k2:v2,k3:v3} 不需要空格
            或者
            k:
              k1: v1  需要空格
              k2: v2

        数组:一组按次序排列的值，包括array、list、queue
            行内写法  k: [v1,v2,v3]
            或者
            k:
              - v1 需要空格
              - v2
              - v3

            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-configuration-processor</artifactId>
                <optional>true</optional>
            </dependency>
           这个jar包可以使我们在配置文件中配置 属性类（@ConfigurationProperties注解的类）里面的属性时有提示


 web开发
        springboot的web配置的介绍,目的是为spring容器中添加web组件
            1、当导入spring-web场景的starter时，就会注册WebMvcAutoConfiguration自动配置类
            2、这个自动配置类主要是有内部还有几个静态配置类，我们主要讲以下两个
                EnableWebMvcConfiguration和WebMvcAutoConfigurationAdapter
                1、EnableWebMvcConfiguration
                    这个类继承了DelegatingWebMvcConfiguration，这就和springmvc里配置@EnableWebmvc的效果是一样的
                    而EnableWebMvcConfiguration里面主要是针对springboot扩展了一些springboot特性的功能，譬如从
                    preperties文件中获取值创建conversionService等，然后再把使用preperties文件中获取的值创建的conversionService
                    重新封装到到RequestMappingHandlerMapping中，这样创建的FormattingConversionService我们就可以简单的通过
                    preperties文件修改他的属性
                2、WebMvcAutoConfigurationAdapter
                    WebMvcAutoConfigurationAdapter实现了WebMvcConfigurer，他其实就是springboot提供的一个
                    mvc配置器，这就和我们再springmvc那里，如果想要自定义一些mvc配置需要自定义个一个类然后实现
                    WebMvcConfigurer，然后放到ioc容器中，这样我们的配置就生效了；
                    DelegatingWebMvcConfiguration再执行过程中会获取到所有的WebMvcConfigurer类型的组件然后执行
                    addResourceHandlers、configureAsyncSupport、addFormatters等方法
                    WebMvcAutoConfigurationAdapter这个类是SpringBoot内部提供专门处理用户自行添加的配置，
                    里面不仅仅包含了修改视图的过滤还有其他很多的方法，包括我们后面章节要讲到的拦截器，过滤器，Cors配置等


    1、静态资源规则与定制化
        默认静态资源目录
            类路径下 /static(/public or /resources or /META-INF/resources)
            访问项目名/静态资源文件名即可
            测试：如果请求方法上的请求路径是aaa.jpg,同时静态资源名也有一个aaa.jpg的图片，那么请求会访问谁？
            会先访问动态资源
            原理：静态映射/**
            因为动态资源也是映射的所有请求，所以请求进来，先去controller，如果找不到，再去找静态资源

        静态资源访问前缀
            #默认无前缀，修改静态资源访问的前缀，/res 其实就相当与classpath，不需要新建res文件夹
            spring.mvc.static-path-pattern=/res/**

        改变默认的静态资源目录
            也就是说haha现在是默认的静态资源文件夹
            spring.resources.static-locations=["/haha"]

    2、欢迎页支持
        静态资源路径下放一个名为index.html的欢迎页，然后访问根路径可以自动跳转到这个index.html；静态资源访问前缀不能修改，
        修改的话就不能默认转到index.html，可以配置静态资源路径，但是不可以配置静态资源访问前缀,controller能处理/index

     favicon功能  网站小图标
        图标名称一定要是favicon.ico ,然后放在静态资源目录下,静态资源访问前缀不能修改，修改的话就不能找到图标

   3、静态资源配置管理
        springmvc启动默认加载xxxAutoConfiguration类(自动配置类)
        springmvc功能的自动配置类集中在这个WebMvcAutoConfiguration里面，当然“静态资源”的配置也在这里
        @Configuration(
            proxyBeanMethods = false
        )
        @ConditionalOnWebApplication(
            type = Type.SERVLET
        )
        @ConditionalOnClass({Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class})
        @ConditionalOnMissingBean({WebMvcConfigurationSupport.class})
        @AutoConfigureOrder(-2147483638)
        @AutoConfigureAfter({DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class})
        public class WebMvcAutoConfiguration {
        }



        @Configuration(
                proxyBeanMethods = false
            )
            @Import({WebMvcAutoConfiguration.EnableWebMvcConfiguration.class})
            @EnableConfigurationProperties({WebMvcProperties.class, ResourceProperties.class})
            @Order(0)
            public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer {
            }

       WebMvcProperties.class  ==spring.mvc
       ResourceProperties.class==spring.resources

       ****配置类中只有一个有参构造器且没有无参构造器的情况下，有参构造器的所有参数的值都会从容器中获取
        (addResourceHandlers方法的执行原理
            1、EnableWebMvcConfiguration配置类继承了DelegatingWebMvcConfiguration，而DelegatingWebMvcConfiguration
                又继承了WebMvcConfigurationSupport，这个类里注册了resourceHandlerMapping
                @Bean
                	@Nullable
                	public HandlerMapping resourceHandlerMapping(
                			@Qualifier("mvcUrlPathHelper") UrlPathHelper urlPathHelper,
                			@Qualifier("mvcPathMatcher") PathMatcher pathMatcher,
                			@Qualifier("mvcContentNegotiationManager") ContentNegotiationManager contentNegotiationManager,
                			@Qualifier("mvcConversionService") FormattingConversionService conversionService,
                			@Qualifier("mvcResourceUrlProvider") ResourceUrlProvider resourceUrlProvider) {

                		Assert.state(this.applicationContext != null, "No ApplicationContext set");
                		Assert.state(this.servletContext != null, "No ServletContext set");

                		ResourceHandlerRegistry registry = new ResourceHandlerRegistry(this.applicationContext,
                				this.servletContext, contentNegotiationManager, urlPathHelper);
                		//****这里就是调用了addResourceHandlers,但是具体实现是在DelegatingWebMvcConfiguration里
                		(
                		    @Override
                         	protected void addResourceHandlers(ResourceHandlerRegistry registry) {
                         		这里的configurers(
                         		  WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();
                         		  然后由于 标注@Autowired所以自动执行这个方法
                         		  @Autowired(required = false)
                                  	public void setConfigurers(List<WebMvcConfigurer> configurers) {
                                  		//然后这个configurers自动从容器查找WebMvcConfigurer类型的组件
                                  		//这样就找到了WebMvcAutoConfigurationAdapter
                                  		//然后就执行了这个类里面的addResourceHandlers方法，从这里就能看处理资源的源码
                                  		if (!CollectionUtils.isEmpty(configurers)) {
                                  			this.configurers.addWebMvcConfigurers(configurers);
                                  		}
                                  	}

                         		)
                         		this.configurers.addResourceHandlers(registry);
                         	}
                        )

                		addResourceHandlers(registry);
                		AbstractHandlerMapping handlerMapping = registry.getHandlerMapping();
                		if (handlerMapping == null) {
                			return null;
                		}
                		handlerMapping.setPathMatcher(pathMatcher);
                		handlerMapping.setUrlPathHelper(urlPathHelper);
                		handlerMapping.setInterceptors(getInterceptors(conversionService, resourceUrlProvider));
                		handlerMapping.setCorsConfigurations(getCorsConfigurations());
                		return handlerMapping;
                	}
        )


       资源处理的默认规则就在这个方法里
       public void addResourceHandlers(ResourceHandlerRegistry registry) {
                   if (!this.resourceProperties.isAddMappings()) {
                       logger.debug("Default resource handling disabled");
                   } else {
                       Duration cachePeriod = this.resourceProperties.getCache().getPeriod();
                       CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();
                       if (!registry.hasMappingForPattern("/webjars/**")) {//访问这个路径的默认访问到了classpath:/META-INF/resources/webjars/路径下的资源
                           this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{"/webjars/**"}).addResourceLocations(new String[]{"classpath:/META-INF/resources/webjars/"}).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl));
                       }

                       String staticPathPattern = this.mvcProperties.getStaticPathPattern();//访问/**这个路径默认访问到了"classpath:/META-INF/resources/", "classpath:/resources/", "classpath:/static/", "classpath:/public/"
                       if (!registry.hasMappingForPattern(staticPathPattern)) {
                           this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{staticPathPattern}).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(this.resourceProperties.getStaticLocations())).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl));
                       }

                   }
               }


         handlerMapping 处理器映射  保存了每一个handler能处理哪些请求


    4、rest映射以及源码分析
        步骤，首先在表单里提交时要提交一个<input type="hidden" name="_method" value="PUT">
        ajax请求时data : {_method : "DELETE", empId : empId}，
        然后在属性文件中配置spring.mvc.hiddenmethod.filter.enabled=true,就是开启restful分格请求；
        这样就会在容器中注入一个HiddenHttpMethodFilter对象
        就可以对这个进行拦截并做处理了；
        这个过滤器支持put、delete、patch请求



    5、请求映射原理
        每个请求进来最终都会调用dispatchservlet.class里面的doDispatch方法，
        mappedHandler = this.getHandler(processedRequest);//找到处理当前请求的handler
        handlerMappings里面保存了所有的请求和处理器的映射，应用启动时，springmvc扫描所有controller后将请求和handler
        对应之后保存到了这个handlermapping；

        所有的映射请求都在handlerMapping中
        1、springboot自动配置欢迎页 WelcomePageHandlerMapping.访问/就能访问到index.html页面
        2、springboot自动配置了默认的RequestMappingHandlerMapping
        3、请求进来，挨个尝试所有的handlermapping看是否有匹配的请求信息
            如果有，就在这个handlermapping里面找个这个handler
            如果没有就去下一个handlermapping重复上面的步骤
        4、如果我们需要自定义handlermapping也可以自定义

    6、springboot对请求参数的处理原理
        1、handlerMapping中找到能处理请求的handler(Controler.method)
        2、为当前handler找一个适配器,handlerAdapter
                1、handlerAdapter spring提供的几种类型
                       0、支持方法上标注的@RequestMapping RequestMappingHandlerAdapter
                       1、HandlerFunctionAdapter
                       2、HttpRequestHandlerAdapter
                       3、SimpleControllerHandlerAdapter
        3、执行目标方法
            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
            //执行目标方法
            mav = this.invokeHandlerMethod(request, response, handlerMethod);
            //
            1、参数解析器
                invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
                //this.argumentResolvers ,HandlerMethodArgumentResolver接口 参数解析器
                //(来确定将要执行的目标方法的每一个参数的值是什么)大概有二十几种，处理标注在请求参数上的注解，
                //譬如@PathVariable、@RequestParam等等，springmvc目标方法能写多少种参数类型，取决于参数解析器
                譬如有一个参数解析器RequestParamMethodArgumentResolver是用来解析标有@RequestParam参数的；
                HandlerMethodArgumentResolver接口有两个抽象方法
                    //当前解析器是否支持解析给定的参数
                    supportsParameter(MethodParameter parameter);
                    //如果支持就处理参数
                    resolveArgument;

                //支持就调用这个方法
                 boolean supportsParameter(MethodParameter var1);

                 //当前解析器是否支持解析这种参数
                @Nullable
                Object resolveArgument(MethodParameter var1, @Nullable ModelAndViewContainer var2, NativeWebRequest var3, @Nullable WebDataBinderFactory var4) throws Exception;

            2、返回值处理器
            //invokeHandlerMethod这个方法里还有一个returnValueHandlers 返回值处理器
                就是说能处理多少种类型的返回值由返回值处理器决定，默认有15种处理器
            if (this.returnValueHandlers != null) {
                invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
            }
            处理真正目标方法
            //ServletInvocableHandlerMethod类里真正处理目标的方法
              Object returnValue = this.invokeForRequest(webRequest, mavContainer, providedArgs);
              1、invokeForRequest再调用InvocableHandlerMethod的getMethodArgumentValues获取方法参数值
                protected Object[] getMethodArgumentValues(NativeWebRequest request,
                            @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {
                        //这里会获取方法的每一个参数的详细信息
                        MethodParameter[] parameters = this.getMethodParameters();
                        if (ObjectUtils.isEmpty(parameters)) {
                            return EMPTY_ARGS;
                        } else {
                            Object[] args = new Object[parameters.length];
                            for(int i = 0; i < parameters.length; ++i) {
                                MethodParameter parameter = parameters[i];
                                parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
                                args[i] = findProvidedArgument(parameter, providedArgs);
                                if (args[i] != null) {
                                    //遍历所有参数解析器，找到能够解析这个参数的解析器
                                    if (!this.resolvers.supportsParameter(parameter)) {
                                        throw new IllegalStateException(formatArgumentError(parameter, "No suitable resolver"));
                                    }
                                    try {
                                         //遍历所有参数解析器，找到能够解析这个参数的解析器,并使用这个参数解析器解析参数
                                        args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);
                                    } catch (Exception var10) {
                                        if (this.logger.isDebugEnabled()) {
                                            String exMsg = var10.getMessage();
                                            if (exMsg != null && !exMsg.contains(parameter.getExecutable().toGenericString())) {
                                                this.logger.debug(formatArgumentError(parameter, exMsg));
                                            }
                                        }
                                        throw var10;
                                    }
                                }
                            }
                            return args;
                        }
                    }



                2、如何确定每个参数值呢？遍历每一个参数，然后在针对每一个参数遍历每一个参数解析器
                    看哪个支持解析当前这个参数，找到这个解析器，找到这个解析器后，具体就让这个解析器用它对应的方式去找参数值
                @Nullable
                private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) {
                    //先从缓存里通过MethodParameter找是否之前有缓存过对应的参数解析器
                    HandlerMethodArgumentResolver result = (HandlerMethodArgumentResolver)this.argumentResolverCache.get(parameter);
                    if (result == null) {
                        Iterator var3 = this.argumentResolvers.iterator();
                        while(var3.hasNext()) {
                            HandlerMethodArgumentResolver resolver = (HandlerMethodArgumentResolver)var3.next();
                            if (resolver.supportsParameter(parameter)) {
                                result = resolver;
                                this.argumentResolverCache.put(parameter, resolver);
                                break;
                            }
                        }
                    }
                    return result;
                }

                3、找到这个解析器后开始让这个解析器去找参数值，譬如PathVariableMethodArgumentResolver去url上去找，找到后就赋值


        1、普通参数与基本注解
            1.1、注解
                @Pathvarible、@RequestHeader、@ModelAttribute、@RequestParam、@CookieValue、@RequestBody
                整个过程就是上面讲解的
        2、servlet API参数解析原理
            请求参数属于以下类型的
                WebRequest、ServletRequest、MultipartRequest、HttpSession、
                Principal、InputStream、Reader.class、HttpMethod、Locale、TimeZone、ZoneId
                过程和上面一样，会在所有参数解析器中查找解析器，找到一个servletRequestMethodArgumentResolver

        3、复杂参数的处理
            1、Map、Errors/BindingResult、Model......
                Map和model,modelMap类型的参数,会找到MapMethodProcessor或者ModelMethodProcessor参数处理器，
                具体处理参数(执行resolveArgument方法)的时候会返回ModelAndViewContainer里面的一
                个BindingAwareModelMap对象，它既是model也是map
                map,model里面的数据会被放在request请求域里
         4、自定义对象参数,封装pojo，使用的是ModelAttributeMethodProcessor这个参数解析器，这个里面需要用到数据绑定器
            自动类型转换与格式化，可以级联封装，页面提交的请求数据(get请求和post请求)都可以和对象属性进行绑定
            是由ServletModelAttributeMethodProcessor这个参数解析器进行处理的，譬如自定义的User对象
            BeanUtils判断是否为简单类型,通过这个方法发现不是简单类型，就用了这个解析器
                public static boolean isSimpleValueType(Class<?> type) {
                    return Void.class != type && Void.TYPE != type &&
                    (ClassUtils.isPrimitiveOrWrapper(type)
                    || Enum.class.isAssignableFrom(type)
                    || CharSequence.class.isAssignableFrom(type)
                     || Number.class.isAssignableFrom(type)
                     || Date.class.isAssignableFrom(type) ||
                      Temporal.class.isAssignableFrom(type)
                       || URI.class == type || URL.class == type
                       || Locale.class == type || Class.class == type);
                }

            这个解析器会为自定义的参数类型创建一个空对象(new一个对象并赋值给这个方法参数)
            //创建空对象
             attribute = this.createAttribute(name, parameter, binderFactory, webRequest),
             然后通过webDataBinder这个数据绑定器将request里的参数和这个空对象的属性及进行绑定;
             webDataBinder数据绑定器：将请求参数的值绑定到指定的javaBean里面,这个绑定器里封装了一个conversionService,
             这个是用来处理类型转换的

            关键代码
            ModelAttributeMethodProcessor类里的resolveArgument方法
            //获取参数绑定器,此时的参数绑定器里面已经initBinder了，而initializer正是
            ConfigurableWebBindingInitializer
            WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);

            public final WebDataBinder createBinder(NativeWebRequest webRequest, @Nullable Object target, String objectName) throws Exception {
                    WebDataBinder dataBinder = this.createBinderInstance(target, objectName, webRequest);
                    //此初始化器是ConfigurableWebBindingInitializer类型，在spring启动时会自动配置到
                    if (this.initializer != null) {
                        this.initializer.initBinder(dataBinder, webRequest);
                    }

                    this.initBinder(dataBinder, webRequest);
                    return dataBinder;
                }

                //而ConfigurableWebBindingInitializer初始化器放到RequestMappingHandlerAdapter
                //ConfigurableWebBindingInitializer初始化器里面有很多诸如类型转换器、属性编辑注册器等
                //这样就可以将初始化器里面的这些转换器等设置到参数绑定器
             @Bean
                public RequestMappingHandlerAdapter requestMappingHandlerAdapter(@Qualifier("mvcContentNegotiationManager") ContentNegotiationManager contentNegotiationManager, @Qualifier("mvcConversionService") FormattingConversionService conversionService, @Qualifier("mvcValidator") Validator validator) {
                    RequestMappingHandlerAdapter adapter = this.createRequestMappingHandlerAdapter();
                    adapter.setContentNegotiationManager(contentNegotiationManager);
                    adapter.setMessageConverters(this.getMessageConverters());
                    adapter.setWebBindingInitializer(this.getConfigurableWebBindingInitializer(conversionService, validator));
                    adapter.setCustomArgumentResolvers(this.getArgumentResolvers());
                    adapter.setCustomReturnValueHandlers(this.getReturnValueHandlers());
                    if (jackson2Present) {
                        adapter.setRequestBodyAdvice(Collections.singletonList(new JsonViewRequestBodyAdvice()));
                        adapter.setResponseBodyAdvice(Collections.singletonList(new JsonViewResponseBodyAdvice()));
                    }

            这样dataBinder里面就有了类型转换器等东西;
            如果要自定义数据绑定初始化器WebBindingInitializer，可以如下做
            1、自定义CustomDateWebBindingInitializer
        public class CustomDateWebBindingInitializer implements WebBindingInitializer {
            @Override
            public void initBinder(WebDataBinder binder) {
                binder.registerCustomEditor(Date.class, new MyCustomDateEditor());
            }
        }

            2、注册WebBindingInitializer
            @Configuration
            public class CustomDateEditorConfiguration {

                @Autowired
                (这个会覆盖之前的初始化器)
                public void setWebBindingInitializer(RequestMappingHandlerAdapter requestMappingHandlerAdapter) {
                    //将自定义的CustomDateWebBindingInitializer属性编辑器绑定到RequestMappingHandlerAdapter里面.
                    requestMappingHandlerAdapter.setWebBindingInitializer(new CustomDateWebBindingInitializer());
                }
            }
            这个自定义的数据绑定器的初始化器是为了给数据绑定器里提供一些自定义的类型转换器等组件的


        @Nullable
            public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {
                Assert.state(mavContainer != null, "ModelAttributeMethodProcessor requires ModelAndViewContainer");
                Assert.state(binderFactory != null, "ModelAttributeMethodProcessor requires WebDataBinderFactory");
                String name = ModelFactory.getNameForParameter(parameter);
                ModelAttribute ann = (ModelAttribute)parameter.getParameterAnnotation(ModelAttribute.class);
                if (ann != null) {
                    mavContainer.setBinding(name, ann.binding());
                }

                Object attribute = null;
                BindingResult bindingResult = null;
                if (mavContainer.containsAttribute(name)) {
                    attribute = mavContainer.getModel().get(name);
                } else {
                    try {
                        //创建一个请求方法上的自定义类型的空实例对象
                        attribute = this.createAttribute(name, parameter, binderFactory, webRequest);
                    } catch (BindException var10) {
                        if (this.isBindExceptionRequired(parameter)) {
                            throw var10;
                        }

                        if (parameter.getParameterType() == Optional.class) {
                            attribute = Optional.empty();
                        }

                        bindingResult = var10.getBindingResult();
                    }
                }

                if (bindingResult == null) {
                    //创建一个webDataBinder数据绑定器
                    WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);
                    if (binder.getTarget() != null) {
                        if (!mavContainer.isBindingDisabled(name)) {
                            //绑定参数
                            this.bindRequestParameters(binder, webRequest);
                        }

                        this.validateIfApplicable(binder, parameter);
                        if (binder.getBindingResult().hasErrors() && this.isBindExceptionRequired(binder, parameter)) {
                            throw new BindException(binder.getBindingResult());
                        }
                    }

                    if (!parameter.getParameterType().isInstance(attribute)) {
                        attribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);
                    }

                    bindingResult = binder.getBindingResult();
                }

                Map<String, Object> bindingResultModel = bindingResult.getModel();
                mavContainer.removeAttributes(bindingResultModel);
                mavContainer.addAllAttributes(bindingResultModel);
                return attribute;
            }


             //绑定参数过程
             this.bindRequestParameters(binder, webRequest);
            调用WebRequestDataBinder的bind方法，这里面将请求参数封装成
            MutablePropertyValues mpvs = new MutablePropertyValues(request.getParameterMap());
            然后调用this.doBind(mpvs)，然后再调用this.applyPropertyValues(mpvs)，这个方法再调用属性访问器的设置属性值的方法
            this.getPropertyAccessor().setPropertyValues(mpvs, this.isIgnoreUnknownFields(), this.isIgnoreInvalidFields());
            然后将之前封装好的请求参数进行遍历设置值；那么如何设置值呢？
            遍历每一个参数然后调用 this.setPropertyValue(pv);进而调用processLocalProperty方法
            这个方法再调用
            this.convertForProperty(tokens.canonicalName, oldValue, originalValue, ph.toTypeDescriptor());
            获取经过转换后的值，因为它又调用了convertIfNecessary，将请求参数转换成目标对象里面的值


            WebMvcConfigurationSupport这个配置类里初始化了转换器，且可以自定义类型转换器
            @Bean
                public FormattingConversionService mvcConversionService() {
                    FormattingConversionService conversionService = new DefaultFormattingConversionService();
                    this.addFormatters(conversionService);
                    //这个里面有很多converter
                    return conversionService;
                }
               //添加自定义的cnverter
                 //webmvcConfigur定制化springmvc的功能,这里不是覆盖了springboot设置的属性，而是额外添加
                   @Bean
                   public WebMvcConfigurer webMvcConfigurer() {
                       return new WebMvcConfigurer() {
                           @Override
                           //添加类型转换器或者格式化器
                           public void addFormatters(FormatterRegistry registry) {
                               registry.addConverter(new Converter<String, User>() {
                                 @Override
                                 public User convert(String var1){
                                     return new User();
                                 }
                               });
                           }

                           @Override
                           public void addInterceptors(InterceptorRegistry registry) {
                               registry.addInterceptor(new HandlerInterceptor() {
                                   @Override
                                   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
                                       return true;
                                   }
                                   @Override
                                   public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {

                                   }
                                   @Override
                                   public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {

                                   }
                               });
                           }

                           @Override
                           public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
                               converters.add(new MyMessageConverter());
                           }

                           //自定义内容协商策略
                           @Override
                           public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
                               Map<String, MediaType> map = new HashMap();
                               map.put("json", MediaType.APPLICATION_JSON);
                               map.put("xml", MediaType.APPLICATION_XML);
                               map.put("sjd", MediaType.parseMediaType("application/x-sjd"));
                               ParameterContentNegotiationStrategy parameterContentNegotiationStrategy = new ParameterContentNegotiationStrategy(map);
                               //基于请求头以及请求参数都可以使用自定义的媒体类型
                               configurer.strategies(Arrays.asList(parameterContentNegotiationStrategy, new HeaderContentNegotiationStrategy()));
                           }
                       };
                   }


数据响应与内同协商
    1、数据响应分两种
        1、响应到页面，前后端一体的单体项目
        2、响应数据，前后端分离
            响应的数据格式包括有json、xml、xfs、图片、音视频、自定义协议数据

    2、响应json步骤
        1.1、jackson.jar+@ResponseBody
            引入web场景的启动器时就已经引入了,这里就会引入针对json的消息转换器
            <dependency>
              <groupId>org.springframework.boot</groupId>
              <artifactId>spring-boot-starter-json</artifactId>
              <version>2.3.4.RELEASE</version>
              <scope>compile</scope>
            </dependency>
           这个启动器内已经引入了下面的和数据响应有关的jar包
           <dependency>
                 <groupId>com.fasterxml.jackson.core</groupId>
                 <artifactId>jackson-databind</artifactId>
                 <version>2.11.2</version>
                 <scope>compile</scope>
               </dependency>
               <dependency>
                 <groupId>com.fasterxml.jackson.datatype</groupId>
                 <artifactId>jackson-datatype-jdk8</artifactId>
                 <version>2.11.2</version>
                 <scope>compile</scope>
               </dependency>
               <dependency>
                 <groupId>com.fasterxml.jackson.datatype</groupId>
                 <artifactId>jackson-datatype-jsr310</artifactId>
                 <version>2.11.2</version>
                 <scope>compile</scope>
               </dependency>

            1.2、在控制器上添加或者请求的方法上添加@ResponseBody注解
                给前端自动返回json数据
        在SpringMVC中，可以使用@RequestBody和@ResponseBody两个注解，分别完成请求报文到对象和对象到响应报文的转换，
        底层这种灵活的消息转换机制，就是Spring3.x中新引入的HttpMessageConverter即消息转换器机制
        原理
            1.1、目标方法执行完之后有一个返回值,遍历所有返回值处理器，判断哪个返回值处理器可以处理当前返回值
                (springmvc支持处理哪些返回值就看有多少种返回值处理器，可以具体看一下每一种返回值处理器处理的什么格式的数据)
                这样就找到了RequestResponseBodyMethodProcessor这个返回值处理器,判断返回值上有没有ResponseBody这个注解
                @Override
                public boolean supportsReturnType(MethodParameter returnType) {
                    return (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) ||
                            returnType.hasMethodAnnotation(ResponseBody.class));
                }

            1.2、RequestResponseBodyMethodProcessor这个返回值处理器如何处理返回值的呢？
                调用handleReturnValue方法处理返回值，RequestResponseBodyMethodProcessor可以处理返回值标了@ResponseBody注解的
                @Override
                public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,
                        ModelAndViewContainer mavContainer, NativeWebRequest webRequest)
                        throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {

                    mavContainer.setRequestHandled(true);
                    ServletServerHttpRequest inputMessage = createInputMessage(webRequest);
                    ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);

                    // Try even with null return value. ResponseBodyAdvice could get involved.
                    //使用消息转换器进行写出操作
                    writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);
                }

            1.3、writeWithMessageConverters方法的执行，将数据写为json
                1、内容协商(浏览器发送请求时默认会以请求头的方式告诉服务器他能接收什么样的内容类型)
                2、服务器最终根据返回值以及目标类型等，以及服务器中存在的消息转换器来决定服务器能产生什么样的媒体类型的数据
                根据浏览器能够接收的类型以及服务器能产生什么样的类型选出大家都可以接收的类型；

                选出媒体类型后开始"查找"可以将返回的class类型的对象转换为MediaType类型数据的消息转换器
                3、springmvc会遍历容器底层的消息转换器messageConverters，看谁能处理这个返回值
                    (就是将这个返回值类型转换成选出来的媒体类型的消息转换器)
                    messageConverters作用：看是否支持将此class类型的对象转换为MediaType类型的数据
                    例子：是否支持将person对象转化为json；或者是否支持将json转换为person对象；
                    消息转换器可以双向转换
                4、默认的消息转换器共有十个左右
                    有只支持返回值类型是byte类型的，还有返回值为String类型的，resources类型的；
                    最终找到MappingJackson2HttpMessageConverter，支持所有类型的返回值转换成json
                    (利用jackson底层的objectMapper进行转换)
                5、找到这个消息转换器之后就准备开始转换成json了
                    1、首先获取到返回的对象，这个就是准备转换json并且写入响应体的数据
                        body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,
                                (Class<? extends HttpMessageConverter<?>>) converter.getClass(),
                                inputMessage, outputMessage);

                    2、开始转换并响应数据
                        genericConverter.write(body, targetType, selectedMediaType, outputMessage);
                    3、write方法调用
                        //将返回的对象转换成json并写到outputMessage
                        writeInternal(t, type, outputMessage);
                        //刷到响应体中
                        outputMessage.getBody().flush();



            内容协商原理
                1、判断当前响应头中是否已经确定媒体类型，mediaType(有可能是在拦截器里确定了响应的媒体类型)
                2、获取客户端支持接收的媒体类型(获取客户端Accept请求头字段)，【application/xml等】
                    使用contentNegotiationManager内容协商管理器获取，
                    默认基于请求头的策略HeaderContentNegotiationStrategy
                3、服务器遍历循环当前系统所有的消息转换器，看哪些消息转换器支持写这个对象
                    可以添加一些jar包，这样就可以添加一些服务器可以处理的媒体类型
                     <dependency>
                        <groupId>com.fasterxml.jackson.dataformat</groupId>
                        <artifactId>jackson-dataformat-xml</artifactId>
                        <version></version>
                    </dependency>
                    添加了这个jar包后，消息转换器就会多一个处理xml的，服务器可以处理的媒体类型就会多一个application/xml
                4、支持的话就把这个消息转换器支持的媒体类型放到集合中返回出来，这就是服务器针对这个返回值对象能生产的媒体类型，
                5、客户端需要【application/xml】，服务端有可能支持好几种
                6、for循环进行内容协商选出最佳媒体类型
                7、用支持“将对象转换为最佳匹配媒体类型的消息转换器”，调用它进行转化

            浏览器请求时是没法自定义它能够接收的媒体类型的，那么如何设置自定义媒体类型呢
                1、开启浏览器请求参数方式的内容协商功能
                    spring.mvc.contentnegotiation.favor-parameter=true
                    然后在url的请求参数上添加format参数  xxxx?format=xml   或者  xxxx?format=json


            自定义消息转换器
                1、自定义消息转换器MyMessageConverter
                public class MyMessageConverter implements HttpMessageConverter<User> {

                    @Override
                    public boolean canRead(Class<?> aClass, MediaType mediaType) {
                        return false;
                    }

                    @Override
                    public boolean canWrite(Class<?> aClass, MediaType mediaType) {
                        return aClass.isAssignableFrom(User.class);
                    }

                    @Override
                    public List<MediaType> getSupportedMediaTypes() {
                        return MediaType.parseMediaTypes("application/x-sjd");
                    }

                    @Override
                    public User read(Class<? extends User> aClass, HttpInputMessage httpInputMessage) throws IOException, HttpMessageNotReadableException {
                        return null;
                    }

                    @Override
                    public void write(User user, MediaType mediaType, HttpOutputMessage httpOutputMessage) throws IOException, HttpMessageNotWritableException {
                        String info = user.getAge() + "----------" + user.getName();
                        httpOutputMessage.getBody().write(info.getBytes());

                    }
                }


                //webmvcConfiguree 定制化springmvc的功能
                    @Bean
                public WebMvcConfigurer webMvcConfigurer(){
                        return new WebMvcConfigurer() {
                            @Override
                            public void addFormatters(FormatterRegistry registry) {

                            }

                            @Override
                            public void addInterceptors(InterceptorRegistry registry) {

                            }

                            //添加自定义消息转换器
                            @Override
                            public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
                                converters.add(new MyMessageConverter());
                            }

                            //这也是添加自定义消息转换器，但是和上面区别在于，如果使用下面这个的话，那么就不会往
                            //converters里注册默认的一批消息转换器，所以建议使用上面那个
                            @Override
                            protected void configureMessageConverters(List<HttpMessageConverter<?>> converters) {

                            }

                            //如果想要在浏览器使用自定义的媒体类型请求，那么配置这个
                            //parameterContentNegotiationStrategy和HeaderContentNegotiationStrategy两个策略会优先使用
                            //参数的，所以当你在url后面添加format=sjd，说明浏览器优先接受sjd的媒体类型的数据；
                            //当然如果你不配这个参数解析器那就
                            关闭浏览器请求参数方式的内容协商功能
                            spring.mvc.contentnegotiation.favor-parameter=false，默认就是false，可以不配置，那这样就只有
                            从请求头获取浏览器接收的媒体类型的策略HeaderContentNegotiationStrategy
                            //自定义内容协商策略
                            //ParameterContentNegotiationStrategy策略默认只有json和xml，我们可以添加一个媒体类型
                            @Override
                            public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
                                Map<String, MediaType> map = new HashMap();
                                map.put("json",MediaType.APPLICATION_JSON);
                                map.put("xml",MediaType.APPLICATION_XML);
                                map.put("sjd",MediaType.parseMediaType("application/x-sjd"));
                                //基于参数的策略
                                ParameterContentNegotiationStrategy parameterContentNegotiationStrategy = new ParameterContentNegotiationStrategy(map);
                                configurer.strategies(Arrays.asList(parameterContentNegotiationStrategy));
                            }
                        };
                }
                到此就可以使用自定义的媒体类型得到想要的响应数据格式；



拦截器
    /**：拦截所有请求，包括静态资源   (注意：/*  这是servlet的用法；/**这是spring的用法)
   拦截器原理
    1、根据当前请求，找到handlerExecutionChian【可以处理请求的所有handler以及匹配当前handler所有的拦截器】
    2、先来顺序执行所有所有拦截器的prehandle方法
        1、如果当前拦截器的prehandle返回为true，则执行下一个拦截器
        2、如果当前拦截器返回为false，则直接倒叙执行已经执行了的拦截器的afterCompletion方法
        //目标方法执行之前先执行这个拦截器链的prehandle方法
        if (!mappedHandler.applyPreHandle(processedRequest, response)) {
          return;
       }
        mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
    3、如果任何一个拦截器返回false，直接跳出，不执行目标方法
    4、所有拦截器都返回true，执行目标方法
    5、目标方法执行后，，倒叙执行所有拦截器的postHandle方法
    6、前面的所有步骤有任何异常的话，都会触发拦截器的afterCompletion方法，倒叙执行
    7、页面成功渲染完成后也会倒叙触发拦截器的afterCompletion方法

通过MultipartFile文件上传原理
    自动配置原理
    文件上传自动配置类：MultipartAutoConfiguration--MultipartProperties
    自动配置好了StandardServletMultipartResolver  【文件上传解析器】
    1、请求进来使用文件上传解析器判断并封装文件上传请求，返回StandardMultipartHttpServletRequest对象，如何判断是否是文件上传
        public boolean isMultipart(HttpServletRequest request) {
            return StringUtils.startsWithIgnoreCase(request.getContentType(), "multipart/");
        }

    2、参数解析器(RequestPartMethodArgumentResolver这个是文件上传的参数解析器)来解析请求中的文件内容并封装成multipartFile
    3、  请求进来时会将request中的文件信息封装成一个map<String,MultiPartFile>,根据表单中上传文件的name属性获取multipartFile
        这样就可以操作上传的文件了

springboot默认错误处理机制
    1、默认情况下，springboot提供/error 处理所有错误的映射
    2、对于机器客户端来说，他将生成json响应，其中包含错误，http状态等；对于浏览器，会响应一个"whitelable error page"白页，
        以html格式呈现现相同的数据
    3、我们可以自定义一个错误页面：在静态文件夹下新建一个error文件夹，在此文件夹下定义404.html以及5xx.html,这样404错误就会自动跳转到这个404页面；
        所有5xx的错误都会跳转到5xx的页面，而不是跳转白页或者json响应了

 异常默认处理的原理
    1、ErrorMvcAutoConfiguration这个配置类自动配置了异常处理规则
        容器中会放入这个组件：DefaultErrorAttributes->id:errorAttributes
        public class DefaultErrorAttributes implements ErrorAttributes, HandlerExceptionResolver, Ordered {}

        容器中会放入这个组件：BasicErrorController -> id:basicErrorController
           处理默认/error路径的请求

        容器中还会放一个组件view->id是error；(响应默认错误页)
        容器中放组件 beannameViewResolver (视图解析器) 按照返回的视图名作为组件的id去容器中找view对象

        @RequestMapping//返回一个json数据
        	public ResponseEntity<Map<String, Object>> error(HttpServletRequest request) {}

异常处理流程
    1、执行目标方法，目标方法执行期间有任何异常都会被catch，且标记当前请求结束，将异常赋值给dispatchException
    2、进入视图解析流程(页面跳转等)
        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException)
    3、处理handler发生的异常，处理完成返回modelAndView
        mv = processHandlerException(request, response, handler, exception);
        1、遍历所有handlerExceptionResolver，看谁能处理异常
        2、系统默认的:DefaultErrorAttributes、HandlerExceptionResolverComposite
            1、DefaultErrorAttributes先来处理异常：将异常信息保存到request作用域，并返回null
            2、HandlerExceptionResolverComposite处理异常，默认没有任何人能处理异常，所以异常会被抛出
            3、如果没有任何人能处理异常，servlet底层就会转发/error请求
            4、会被BasicErrorController接收到并处理
            5、遍历所有的errorViewResolver，看谁能解析
            6、只找到DefaultErrorViewResolver并调用resolveErrorView方法设置返回的ModelAndView
                先以请求状态码为viewName查找所有静态文件夹下的error文件夹下是否有这个viewName的文件夹，
                如果没有那就转到5xx.html，或者4xx.html

 定制几种异常处理的方式
    1、自定义错误页：在静态资源路径下新建error文件夹，并在里面创建4xx.html或者5xx.html，这样当发生相关状态码的错误时会自动
        匹配相关页面，首先会根据状态码精确查找，如果没有就查找4xx或者5xx，如果还没有，就跳白页或者json
        流程看上面

    2、@ControllerAdvice+@ExceptionHandler处理全局异常 使用ExceptionHandlerExceptionResolver处理器处理
        最终的响应由ExceptionHandlerExceptionResolver处理器响应
        1、首先会遍历所有异常处理器handlerExceptionResolvers然后找到处理异常的方法
            ServletInvocableHandlerMethod exceptionHandlerMethod = getExceptionHandlerMethod(handlerMethod, exception);
        2、处理的过程
            首先根据处理器(也就是请求的方法)查找处理器所在类是否存在标有@ExceptionHandler注解并且可以处理处理器抛出的异常的方法，
            如果有这个方法的话，就先把这个存在此方法的类包装成ExceptionHandlerMethodResolver，
            resolver = new ExceptionHandlerMethodResolver(handlerType);
            然后再把这个处理异常的方法包装成ServletInvocableHandlerMethod；
            Method method = resolver.resolveMethod(exception);
            if (method != null) {
                return new ServletInvocableHandlerMethod(handlerMethod.getBean(), method);
            }
        3、如果没有在当前类找到的话就找到容器中所有标记有@ControllerAdvice的类，然后遍历查找这些类是
            否存在标有@ExceptionHandler注解并且可以处理处理器抛出的异常的方法，如果有这个方法的话，就把这个方法包装成
            ServletInvocableHandlerMethod；
        4、为这个ServletInvocableHandlerMethod添加argumentResolvers、returnValueHandlers，这里的参数解析器和返回值处理器都是一样的，
            然后反射调用这个标有@ExceptionHandler注解的方法，调用这个方法时会使用参数解析器和返回值处理器，这里的原理和我们
            请求普通方法时是一样的


    3、
        @ResponseStatus+自定义异常，底层使用 ResponseStatusExceptionResolver 异常处理器，把ResponseStatus的注解信息
        组装返回并封装到response，然后继续抛出异常，由于无人处理异常一直返回给了tomcat容器，于是底层调用
        response.sendError(statusCode, resolvedReason);tomcat发送的/error，转发到BasicErrorController接收并处理
         还是和异常处理方式一一样，状态码就是@ResponseStatus(value = HttpStatus.FORBIDDEN)
        @ResponseStatus(value = HttpStatus.FORBIDDEN,reason = "人数太多")

      public class MyException extends RuntimeException{

          public MyException() {
          }

          public MyException(String message) {
              super(message);
          }
      }

    这几个异常处理的方式都实现了HandlerExceptionResolver这个接口，所以如果你对这几个处理器不满意，你也可以自己自定义一个，然后在类上
    添加@order注解，尽量让你的这个处理器排在前面使用，否则可能轮不到自定义处理器，前面的异常处理器就已经使用了

web原生组件注入(servlet、filter、listener)
    1、使用servlet API
        主配置类上添加@ServletComponentScan("com.example2021.springboot")，扫描到的路径上如果有原生servlet组件
        原生servlet组件
        @WebServlet(urlPatterns = "/my")
        public class MyServlet extends HttpServlet {}
        那么就会注入到servlet容器中
        效果：直接响应，没有经过spring的拦截器
     同理监听器以及过滤器
     @WebListener
     public class MyListener implements ServletContextListener {}

     @WebFilter(urlPatterns = "/error/*")
     public class MyFilter implements Filter {}

     推荐使用这种方式
    2、
        ServletRegistrationBean、FilterRegistrationBean、ServletListenerRegistrationBean
        这三个类都是ServletContextInitializer的子类，容器启动时会自动调用他们的onstarte方法，
        从而将servlet注入servlet容器
        @Configuration
        public class MyRegistConfig {

            @Bean
            public ServletRegistrationBean myServlet(){
                MyServlet2 myServlet2 = new MyServlet2();
                    //"",""  这个参数说明可处理多个样式的请求
                    return new ServletRegistrationBean(myServlet2,"","");
            }

            @Bean
            public FilterRegistrationBean myFilter(){
                MyFilter2 myFilter2 = new MyFilter2();
                FilterRegistrationBean f = new FilterRegistrationBean(myFilter2)
                f.setUrlPatterns(Arrays.asList("/error/*"));
                return f;
            }

            @Bean
            public ServletListenerRegistrationBean myListener(){
                MyListener2 myListener2 = new MyListener2();
                return new ServletListenerRegistrationBean(myListener2);
            }
        }

            dispatchServlet是通过第二种方式注入到servlet容器里来的
            springboot是使用DispatcherServletAutoConfiguration配置类注册dispatchServlet的

springboot内嵌的servlet容器
    springboot默认支持的嵌入式(springboot内置的)webserver，在本地开发的时候用的服务器，不需要安装tomcat、jetty等servlet
    容器了
        springboot默认支持三种servlet容器：tomcat、jetty、undertow
        而项目启动时他们是如何被选择作为最终容器的呢
        springboot启动时调用流程
            1、调用run方法
                SpringApplication.run(XbootApplication.class, args);
            2、根据web类型创建spring容器
                switch (this.webApplicationType) {
                    case SERVLET:
                        contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);
                        break;
                    case REACTIVE:
                        contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);
                        break;
                    default:
                        contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);
                    }
                context = createApplicationContext();
            3、刷新容器
                refreshContext(context);
            4、这个方法里又调用了
                refresh(context);---> protected void refresh(ApplicationContext applicationContext) {
                                     		Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);
                                     		((AbstractApplicationContext) applicationContext).refresh();
                                     	}
            5、((AbstractApplicationContext) applicationContext).refresh();
                这里假如是servlet的话，spring就会创建AnnotationConfigServletWebServerApplicationContext
                然后这个对象调用他的refresh()进而调用onRefresh();
            6、这里其实调用的就是AnnotationConfigServletWebServerApplicationContext的父类
                ServletWebServerApplicationContext的onRefresh()方法
            7、这个方法调用了createWebServer方法
                这个方法会获取servletWebServerFactory
                springboot底层有很多webServer工厂：
                TomcatServletWebServerFactory、JettyServletWebServerFactory、UndertowServletWebServerFactory
                这些工厂是通过什么条件注册到spring容器的呢，其实是看导入了什么场景的启动器，导入了哪个场景启动器，哪个启动器
                就注入了spring容器中

                那我们根据什么最终到底会获取到哪个呢，调用以下方法
                ServletWebServerFactory factory = getWebServerFactory();
                而这个里面获取到的工厂是容器中注册了什么工厂就获取什么工厂
            8、web场景包默认引入的就是tomcat，TomcatServletWebServerFactory创建出tomcat服务器 TomcatWebServer
                this.webServer = factory.getWebServer(getSelfInitializer());
                TomcatWebServer这个类的构造器里会调用initialize()方法
                而初始化方法内部调用了this.tomcat.start();tomcat就启动了
            9、内嵌服务器，就是手动启动服务器的代码调用(tomcat核心jar包存在)

    切换springboot内嵌的服务器,如果不想使用tomcat服务器，那就排除tomcat包，引入其他服务器的包
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <exclusions>
                <exclusion>
                    <artifactId>org.springframework.boot</artifactId>
                    <groupId>spring-boot-starter-tomcat</groupId>
                </exclusion>
            </exclusions>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jetty</artifactId>
        </dependency>

springboot使用第三方web容器启动的流程(添加servlet，filter、listener的原理)
    1、首先spring-web jar包；里有一个 META-INF/services/javax.servlet.ServletContainerInitializer
              web容器启动的时候会扫描每个jar包下的这个文件夹的文件
          2、加载文件中指定的类SpringServletContainerInitializer
          3、spring的应用一启动，SpringServletContainerInitializer这个上就会加载感兴趣的这个
            WebApplicationInitializer接口下的所有类型的组件，并且为这些组件创建对象（非接口和抽象类）
          4、调用SpringServletContainerInitializer的onstarteUp方法时会遍历WebApplicationInitializer并调用
            它的onstarteUp方法
    2、由于springboot的主配置类继承了SpringBootServletInitializer，而SpringBootServletInitializer又继承了
        WebApplicationInitializer，所以也会调用onstarteUp方法
    3、接下来就是正常的创建刷新容器，在刷新容器的过程中会调用onRefresh()方法，进而调用createWebServer方法
        private void createWebServer() {
        		WebServer webServer = this.webServer;
        		ServletContext servletContext = getServletContext();
        		//根据 webServer == null && servletContext == null说明
        		//我在创建应用上下文之前并没有外部容器启动，那么就创建一个内嵌容器
        		if (webServer == null && servletContext == null) {
        			ServletWebServerFactory factory = getWebServerFactory();
        			//这个里面添加自定义的servlet等组件的地方
        			//方法调用 createWebServer -> getWebServer -> prepareContext -> configureContext
        			//然后就来到了configureContext，有一步很关键，context.addServletContainerInitializer(starter, NO_CLASSES)
        			//我们看一下这个方法，它往里面放的不是别人，正是大名鼎鼎的ServletContainerInitializer
        			//那我们看看这个TomcatStarter是何方神圣，TomcatStarter implements ServletContainerInitializer
        			//仔细一看，里面就是依次调用传入的 ServletContextInitializers,当tomcat启动后就会调用TomcatStarter的onStartup方法
        			//进而注册servlet等组件到servlet容器中
        			//@Override
                         public void onStartup(Set<Class<?>> classes, ServletContext servletContext) throws ServletException {
                            try {
                               for (ServletContextInitializer initializer : this.initializers) {
                                  initializer.onStartup(servletContext);
                               }
                            }
        			this.webServer = factory.getWebServer(getSelfInitializer());
        			getBeanFactory().registerSingleton("webServerGracefulShutdown",
        					new WebServerGracefulShutdownLifecycle(this.webServer));
        			getBeanFactory().registerSingleton("webServerStartStop",
        					new WebServerStartStopLifecycle(this, this.webServer));
        		}
        		//说明有外部servlet容器启动了
        		else if (servletContext != null) {
        			try {
        			    //getSelfInitializer()从spring容器中获取所有ServletRegistrationBean、FilterRegistrationBean、
        			    //ServletListenerRegistrationBean等初始化器并执行onStartup方法,将servlet、listener等注册到servlet容器
        				getSelfInitializer().onStartup(servletContext);
        			}
        			catch (ServletException ex) {
        				throw new ApplicationContextException("Cannot initialize servlet context", ex);
        			}
        		}
        		initPropertySources();
        	}

        总结一下：tomcat启动后会调用ServletContainerInitializer的onstarteUp方法，这个里面会从容器中获取到所有
                ServletContextInitializer并调用onstarteUp方法，而ServletRegistrationBean、FilterRegistrationBean、
                ServletListenerRegistrationBean这些都是ServletContextInitializer实现类，所以也会调用，这些初始化器
                的onstarteUp方法就会注册servlet组件到servlet容器中


springboot定制化组件的几种方式
        a、不用@EnableWebmvc注解，使用@Configration+webmvcconfigurer实现类自定义规则；
        b、可以声明WebMvcRegistrations改变默认的底层组件；
            这样其实是重写了这些组件
            @Bean
            public WebMvcRegistrations webMvcRegistrations(){
                return new WebMvcRegistrations() {
                    @Override
                    public RequestMappingHandlerMapping getRequestMappingHandlerMapping() {
                        return null;
                    }

                    @Override
                    public RequestMappingHandlerAdapter getRequestMappingHandlerAdapter() {
                        return null;
                    }

                    @Override
                    public ExceptionHandlerExceptionResolver getExceptionHandlerExceptionResolver() {
                        return null;
                    }
                };
            }
        c、@EnableWebMvc配合@configration注解(这个注解的类要实现webmvcconfigure接口)+@Bean，
            可以全面接管springmvc，所有规则全部自己配置，实现定制和扩展功能，springboot原有的自动配置
            诸如静态资源、视图解析器、欢迎页等默认配置全部失效
            原理
                1、WebMvcAutoConfiguration 默认就配置了springmvc的自动配置功能，静态资源、欢迎页
                2、一旦使用@EnableWebMvc,会导入DelegatingWebMvcConfiguration,而他的父类是
                    WebMvcConfigurationSupport，这就导致了WebMvcAutoConfiguration失效，不会注册到容器中
                3、DelegatingWebMvcConfiguration的作用只能保证springmvc最基本的使用
                    1、把容器中所有WebMvcConfigurer拿来，所有功能的定制都是这些WebMvcConfigurer合起来一起生效
                    2、自动配置了一些非常底层的组件，RequestMappingHandlerMapping这些组件依赖的组件都是从容器中获取



springboot数据源的操作步骤
    1、导入<dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-jdbc</artifactId>
      </dependency>

      这个启动器里面导入了以下几个jar包
      //1、自动配置的包
      <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
        <version>2.3.4.RELEASE</version>
        <scope>compile</scope>
      </dependency>

      //2、数据源，连接池
      <dependency>
        <groupId>com.zaxxer</groupId>
        <artifactId>HikariCP</artifactId>
        <version>3.4.5</version>
        <scope>compile</scope>
      </dependency>

      //3、jdbc操作
      <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-jdbc</artifactId>
        <version>5.2.9.RELEASE</version>
        <scope>compile</scope>
      </dependency>

        为什么这个stater没有导入数据库驱动？因为springboot官方也不知道你使用的是mysql还是oracle等数据库驱动
        所以还是需要自己导入数据库驱动，但是springboot官方已经确定了版本号，但是要注意数据库版本和驱动版本的对应

   2、自动配置类
        DataSourceAutoConfiguration  数据源的自动配置
        DataSourceTransactionManagerAutoConfiguration 事务管理器配置


 druid数据源整合
    1、stater整合方式
    <dependency>
                  <groupId>com.alibaba</groupId>
                  <artifactId>druid-spring-boot-starter</artifactId>
                  <version>1.1.17</version>
              </dependency>



    2、自定义整合方式
       1、 <!-- 引入第三方数据源 -->
                <dependency>
                    <groupId>com.alibaba</groupId>
                    <artifactId>druid</artifactId>
                    <version>1.1.17</version>-->
                </dependency>

            注入容器
            @Configuration
            public class MyDuridConfig {
                //默认的自动配置是判断容器中没有 DataSource类型才会配置
                  HikariCP数据源，那我们这边配置了之后，那默认的配置的数据源就失效了
                @Bean
                ***@ConfigurationProperties("spring.datasource")//这样就可以把配置文件中的属性值和返回的这个对象的
                属性进行绑定，其实是找setter,set后面的名字才是我们应该在配置文件中写的
                public DataSource dataSource() throws SQLException {
                    DruidDataSource druidDataSource = new DruidDataSource();
                    //druidDataSource.setUrl("");
                    //druidDataSource.setUsername("");
                    //加入监控功能
                    //druidDataSource.setFilters("stat");
                    return druidDataSource;
                }

                @Bean
                public ServletRegistrationBean<StatViewServlet> servletRegist(){
                    StatViewServlet statViewServlet = new StatViewServlet();
                    ServletRegistrationBean<StatViewServlet> statViewServletServletRegistrationBean = new ServletRegistrationBean<>(statViewServlet,"/druid/*");
                    return statViewServletServletRegistrationBean;
                }

            }

        2、druid数据源starter
            引入druid starter
             <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>druid-spring-boot-starter</artifactId>
                <version>1.1.17</version>
            </dependency>





整合mybatis
    步骤
        1、引入mybatis启动器
            <!--里面已经引入了jdbc启动器，所以不需要单独再引入jdbc了-->
             <dependency>
                <groupId>org.mybatis.spring.boot</groupId>
                <artifactId>mybatis-spring-boot-starter</artifactId>
                <version>2.1.1</version>
             </dependency>

        2、写mapper接口,并且在类上注解@Mapper
            也可以在主配置类上标记@MapperScan("com.sjd.happiness.mapper")来扫描，而不需要在每一个mapper
            上写@Mapper注解
        3、写mapper的映射mapper文件
        4、配置文件中配置mapper文件的位置，如果有mybatis的全局配置文件，那也得配置全局配置文件的位置
            mybatis:
                # 搜索指定包别名
                typeAliasesPackage: com.ruoyi.project.**.domain
                # 配置mapper的扫描，找到所有的mapper.xml映射文件
                mapperLocations: classpath:mybatis/**/*Mapper.xml
                # 加载全局的配置文件
                configLocation: classpath:mybatis/mybatis-config.xml

    1、使用mabatis时，可以使用映射文件，也可以在mapper中的方法上使用注解，混合使用；
    诸如@Select("select * from city where id = #{id}")

整合mybatisPlus
    步骤
        1、引入场景启动器
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-boot-starter</artifactId>
                <version>3.4.1</version>
            </dependency>
        2、自动配置
            1、MybatisPlusAutoConfiguration配置类，MybatisPlusProperties配置项绑定
            2、SqlSessionFactory也自动配置好了
            3、mapperLocations自动配置好了，"classpath*:/mapper/**/*.xml"
        3、写mapper接口并且继承BaseMapper接口，并且在类上注解@Mapper也可以在主配置类上标记@MapperScan("com.sjd.happiness.mapper")来扫描，
            而不需要在每一个mapper上写@Mapper注解
        mybatisPlus的优点
            只需要继承BaseMapper，就可以拥有crud的功能


springboot整合redis
    1、RedisAutoConfiguration自动配置类，RedisProperties属性类
    2、自动注入RedisTemplate<Object, Object>
    3、StringRedisTemplate，k、v都是String
    4、我们只要使用StringRedisTemplate和RedisTemplate就可以操作redis了
 如何切换至jedis连接池
    1、排除lecttue包，导入jedis包即可

    redis环境搭建
        1、阿里云的redis，购买redis服务，付费，按量付费很便宜 经典网络
        2、申请redis的公网链接地址

profile功能
    为了方便多环境适配，springboot简化了profile功能
    @Profile("prod")
    @Data
    @Component
    @ConfigurationProperties("animal")
    @ToString
    public class User implements Animal{
        private String name;
        private  int age;

    }

@Profile("test")
@Data
@Component
@ConfigurationProperties("animal")
@ToString
public class Person implements Animal{

    private String name;
    private  int age;
}
当获取Animal的类型时，会根据当前是使用什么环境，然后将@Profile("test")所标注的对应的类型注入容器；可以使用在类上，
也可以使用在bean上；
    @Profile("test")
    @Bean
    public User user(){
       User u = new User();
       //u.setCat(cat());
        return u;
    }

也可以使用profiles组
    spring.profiles.active=mytest
    spring.profiles.group.mytest[0]=test
    spring.profiles.group.mytest[1]=test2
    这样就会加载两个配置文件

外部化配置
    1、外部配置源
        常用：java属性properties文件、yaml文件、环境变量、命令行参数
        这些值统一都会存在ConfigurableEnvironment中
        ConfigurableEnvironment environment = run.getEnvironment();
        //环境变量
         Map<String,Object> systemEnvironment = environment.getSystemEnvironment();
         //系统属性信息
         Map<String, Object> systemProperties = environment.getSystemProperties();
         可以通过@value获取
        这些配置源如果有同名的话，会出现覆盖，具体优先级查询springboot官方文档

    2、application\yaml配置文件
        配置文件的查找位置(后面的会覆盖前面的)
        1、classpath根路径
        2、classpath根路径下的config目录
        3、jar包所在当前目录
        4、jar包所在当前目录下的config目录
        5、/config目录下的直接子目录

        配置文件优先级规则
            先加载application.properties
            再加载application-env.properties，但是这个如果和application.properties出现同名的属性配置，以后面这个为准
            1、指定了环境的优先
            2、外部的配置文件优先，譬如命令行是外部的，比项目里面的application文件优先级还高

自定义starter细节
    1、starter启动原理
        1、starter-pom引入autoconfigurer包
        2、autoconfigurer包中配置使用META-INF/spring.factories中EnableAAutoConfiguration的值
           使得项目启动时加载指定的自动配置类
        3、编写自动配置类xxxAutoConfiguration-->xxxProperties
           1、@Configuration
           2、@Conditional
           3、@EnableConfigurationProperties
           4、@Bean
        4、引入stater
    2、自定义starter(具体看com.sjd.hello)
        1、新建一个module，这是stater场景启动器，场景启动器里只是用于引用自动配置包，没有其他具体代码什么的
        2、再新建一个自动配置的moudle
        3、然后在场景启动器里的pom文件引入自动配置功能的moudle
        4、先将自动配置的moudle打包安装到本地
        5、再打包安装场景启动器
        6、这样就可以在其他项目的pom文件里引入这个场景启动器





ApplicationListener和springApplicationRunlistener
    springApplicationRunlistener接口中的方法会在容器处于特定时刻调用，调用的方法里面真正处理的
    是ApplicationListener监听器


springApplication创建初始化流程
    1、springboot启动过程
        分两步，先创建SpringApplication对象，再运行run方法
        1、创建SpringApplication
            public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {
                this.resourceLoader = resourceLoader;
                Assert.notNull(primarySources, "PrimarySources must not be null");
                //保存主配置类的信息
                this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));

                //从chassspath中存在的容器类型的类返回容器类型
                this.webApplicationType = WebApplicationType.deduceFromClasspath();

                //去spring.factories中查找ApplicationContextInitializer，找到后创建对象
                //并赋值给SpringApplication对象的initializers属性
                setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));

                //去spring.factories中查找ApplicationListener，找到后创建对象
                //并赋值给SpringApplication对象的listeners属性
                setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));

                //找到主程序的main方法
                this.mainApplicationClass = deduceMainApplicationClass();
            }
        2、运行SpringApplication的run方法
            public ConfigurableApplicationContext run(String... args) {
                StopWatch stopWatch = new StopWatch();
                stopWatch.start();
                ConfigurableApplicationContext context = null;
                Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();

                //让当前应用进入headless模式，自力更生模式
                configureHeadlessProperty();

                //去spring.factories中查找所有运行时监听器SpringApplicationRunListener并创建对象，
                //并封装到SpringApplicationRunListeners
                SpringApplicationRunListeners listeners = getRunListeners(args);

                //遍历所有SpringApplicationRunListener触发器并调用starting方法，这个方法相当于事件发布机制，
                发布ApplicationStartingEvent事件,触发监听器
                listeners.starting();
                try {
                    //保存命令行参数
                    ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);

                    //准备环境
                        //1、返回或创建一个基础环境信息StandardServletEnvironment
                        //2、配置环境信息
                            //1、读取所有配置源的配置属性值
                            //2、绑定环境信息到environment
                        //3、监听器调用，发布ApplicationEnvironmentPreparedEvent事件
                    ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);

                    configureIgnoreBeanInfo(environment);

                    //打印banner图
                    Banner printedBanner = printBanner(environment);

                    //根据webApplicationType创建ioc容器AnnotationConfigServletWebServerApplicationContext，
                    //而这个webApplicationType是之前创建springApplication时赋值的
                    context = createApplicationContext();

                    //去spring.factories中查找所有运行时监听器SpringBootExceptionReporter并创建对象，
                    //并赋值给exceptionReporters
                    exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,
                            new Class[] { ConfigurableApplicationContext.class }, context);

                    //为刚创建的ioc容器做一些准备工作，准备ioc容器的基本信息
                        //1、保存环境信息
                        //2、ioc容器的后置处理流程
                        //3、应用初始化器applyInitializers
                            //1、遍历所有的初始化器ApplicationContextInitializer并调用initialize方法，来对ioc容器扩展
                            //2、监听器调用，发布ApplicationContextInitializedEvent事件
                            //3、注册一些组件springApplicationArguments、springBootBanner
                            //4、监听器调用，发布ApplicationPreparedEvent事件
                        //加载ioc里面的bean的注册信息
                    prepareContext(context, environment, listeners, applicationArguments, printedBanner);

                    //刷新ioc容器
                        //1、创建容器中的所有组件，可参照spring过程
                    refreshContext(context);

                    //容器刷新完成后，创建对象
                    afterRefresh(context, applicationArguments);

                    //监控容器完成花费时间
                    stopWatch.stop();
                    if (this.logStartupInfo) {
                        new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
                    }

                    //监听器调用，发布ApplicationStartedEvent事件
                    listeners.started(context);

                    //1、获取容器中的ApplicationRunner、CommandLineRunner，然后排序；
                         遍历所有Runner并执行他们的run方法
                    callRunners(context, applicationArguments);
                }
                catch (Throwable ex) {
                    //如果发生异常，监听器调用，发布ApplicationFailedEvent事件
                    handleRunFailure(context, ex, exceptionReporters, listeners);
                    throw new IllegalStateException(ex);
                }

                try {
                    //如果没有异常，监听器调用，发布ApplicationReadyEvent事件
                    listeners.running(context);
                }
                catch (Throwable ex) {
                    handleRunFailure(context, ex, exceptionReporters, null);
                    throw new IllegalStateException(ex);
                }
                return context;
            }

serlvlet启动过程
    1、创建servletContext
    2、找ServletContainerInitializer并调用onstarteUp方法
    3、注册servlet组件
    4、注册完之后触发contextloaderListener
    5、执行注入的servlet、filter组件的init方法

单元测试
    1、//添加了这个注解就会在spring容器中进行测试
      @SpringBootTest

    2、断言失败的话，后面的代码不会执行

    3、前置条件



springboot与日志框架
    由于市面上有很多框架，更换日志框架还得修改日志的API，所以就有人统一了日志的接口(日志的抽象层)，
    然后很多框架就都是实现了这个接口，然后
    在项目里就只需要修改框架而不用修改代码

    市面上常用的日志抽象层：jcl、slf4j等
    常用日志框架实现：log4j、log4j2、logback、jul

    spring框架默认使用jcl
    springboot默认使用slf4j和logback


    slf4j的使用
        1、如何在系统中使用slf4j
            以后再开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志的抽象层里面的方法；
            给系统里导入slf4j的jar和logback的实现jar

            import org.slf4j.Logger;
             2: import org.slf4j.LoggerFactory;
             3:
             4: public class Wombat {
             6:   final Logger logger = LoggerFactory.getLogger(Wombat.class);
            10:   public void setTemperature(Integer temperature) {
            15:     logger.debug("Temperature set to {}. Old temperature was {}.", t, oldT);
            16:     logger.info("Temperature has risen above 50 degrees.");
            20:   }
            21: }

        每一个日志框架都有自己的配置文件，使用slf4j后，配置文件还是做成日志实现框架的配置文件

        2、遗留问题
            如果你的项目已经是一个日志框架杂糅的项目，但是你想要统一换成slf4j框架的api，你可以这样转换
            1、先将系统中其他日志框架排除出去
            2、用中间包来替换原有的日志框架
            3、引入slf4j的jar包


        3、springboot日志关系
            springboot使用它来做日志功能
            <dependency>
                  <groupId>org.springframework.boot</groupId>
                  <artifactId>spring-boot-starter-logging</artifactId>
                </dependency>

            1、springboot底层使用slf4j和logback的方式进行日志记录
            2、springboot
                引用的             <dependency>
                                     <groupId>org.springframework.boot</groupId>
                                     <artifactId>spring-boot-starter-logging</artifactId>
                                   </dependency>

                里面已经把其他的日志实现框架都替换成了slf4j的适配版本

            3、中间替换包
                springboot能自动适配所有的日志,只要将引入的框架里自带的日志框架的依赖给排除掉，就会自动适配到slf4j


        当需要配置日志信息时，可以在application.properties、application.yaml中进行简单的配置，比如日志级别。
        SpringBoot默认为我们输出的日志级别为info、warn、error，如果还使用其他级别的日志，可以在配置中进行配置 。
        支持的日志级别有： ERROR, WARN, INFO, DEBUG , TRACE (Logback中没有FATAL级别，等同于ERROR）。
        日志级别 trace < debug < info < warn < error < fatal，低级别的日志会输出高级别的日志信息，反之不可以    ，
        不区分大小写。
        在application.properties中配置：
        #配置根logger的输出级别，也可以直接使用大写的 LEVEL=WARN指定
        logging.level.root=WARN
        #指定logger的name属性为org.springframework.web，即该包下的日志级别为DEBUG
        logging.level.org.springframework.web=DEBUG
        logging.level.org.hibernate=ERROR
        #指定日志输出的文件路径，/在windows下是直接定位到当前工作文件磁盘下的
        logging.path=/logs
        #指定日志文件的名称
        logging.file=logs.log

springBoot Actuator与endpoint
    应用引入 <dependency>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-actuator</artifactId>
                </dependency>

    即可使用
    访问/actuator/端点名即可查看相应的指标

    management:
        endpoints:
            #        默认是所有端点都是开启的，true，但是web方式开启的只有health和info，但是可以手动开启
            enabled-by-default: false
            #        以web方式开启端点
            web:
                exposure:
                    include: ['health','info','beans','metrics']
        endpoint:
            health:
                show-details: always
                #            当关闭所有端点后，单个开启某个端点
                enabled: true

    info:
        name: sjd
        #从pom文件获取数据
        project: @project.groupId@





springboot的一些注意点
    注解@Order或者接口Ordered的作用是定义Spring IOC容器中Bean的执行顺序的优先级，而不是定义Bean的加载顺序，
    Bean的加载顺序不受@Order或Ordered接口的影响,只是执行顺序受此影响；譬如实现CommandLineRunner接口的类会在Spring IOC容
    器加载完毕后执行，适合预加载类及其它资源；容器启动时，会查找到所有CommandLineRunner的实现类然后执行他们，但是执行顺序是什么呢，
    这时候就会根据@order的值来排序并执行；
    一般来说，对于容器内普通的Bean我们只需要关注依赖关系即可，而并不需要关心其绝对的加载顺序，而依赖关系的管理Spring的是做得很好的；
    但是@Configuration配置类它也是一个Bean，但对于配置类来说，某些场景下的执行顺序是必须的，譬如Spring Boot下配置类的执行顺序

    三大注解@AutoConfigureBefore、@AutoConfigureAfter、@AutoConfigureOrder主要是改变springboot自带的配置类的加载顺序的，
    三大注解是Spring Boot提供的而非Spring Framework。其中前两个是1.0.0就有了，@AutoConfigureOrder属于1.3.0版本新增，
    表示绝对顺序（数字越小，优先级越高）。另外，这几个注解并不互斥，可以同时标注在同一个@Configuration自动配置类上。
    但也可以是用来改变自定义的配置类的加载顺序；
    使用的正确姿势要想达到预期效果，正确姿势只需要下面两步：
        @AutoConfigureBefore(A_SonConfig.class)
        @Configuration
        public class B_ParentConfig {

            B_ParentConfig() {
                System.out.println("配置类ParentConfig构造器被执行...");
            }
        }
        1、把A_SonConfig和B_ParentConfig挪动到Application扫描不到的包内，切记：一定且必须是扫描不到的包内
        2、当前工程里增加配置META-INF/spring.factories，内容为(配置里Son和Parent前后顺序对结果无影响)：
        org.springframework.boot.autoconfigure.EnableAutoConfiguration=
                                        com.fsx.autoconfig.A_SonConfig,com.fsx.autoconfig.B_ParentConfig

        这样B就会在A之前执行








