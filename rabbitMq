MQ学习前言
    MQ=消息中间件
    何种场景下使用消息中间件？

    为什么要在系统里引入消息中间件？
        可以解耦、削峰、异步

    系统之间的直接调用产生的问题
        1、系统之间耦合比较严重
        2、面对大流量并发时，容易被冲垮
            每个接口模块的吞吐能力是有限的，这个上限能力如果时堤坝，当大流量(洪水)来临时，容易被冲垮
        3、等待同步存在性能问题
    如何解决？
        根据上述的几个问题，在设计系统时可以明确要达到的几个目标
        1、要做到系统解耦，当新的模块接进来时，可以做到代码改动最小；能够解耦
        2、设置流量缓冲池，可以让后端系统按照自身的吞吐能力进行消费，不被冲垮；能够削峰
        3、强弱依赖梳理能将非关键调用链路的操作异步化并提升整体系统的吞吐能力；能够异步

消息中间件的大致过程
    发送者把消息发送给消息服务器，消息服务器将消息存放在若干队列/主题中，在合适的时候，消息服务器会将消息转发给
    接收者；在这个过程中，发送和接受时异步的，也就是发送无需等待，而且发送者和接受者的生命周期也没有必然联系；
    尤其在发布/订阅模式下，也可以完成一对多的通信，即让一个消息有多个接受者

消息中间件的特点
    采用异步处理模式
        消息发送者可以发送一个消息无须等待响应。消息发送者将消息发送到一条虚拟的通道(主题或队列)上
        消息接受者则订阅或监听该通道，一条信息可能最终转发给一个或多个消息的接受者，这些接收者都无需对消息
        发送者做出同步回应。整个过程都是异步的。
        举例：
            也就说，一个系统跟另一个系统之间进行通信的时候，加入系统A希望发送一个消息给系统B让他去处理。但是系统
            A不关注B到底如何处理，所以系统A把消息发送给MQ，然后就不管这条消息的死活了，接着系统B从MQ里消费出来
            即可，至于怎么处理都是系统B的事情，与系统A无关
        这样的一种通信方式，就是所谓的异步通信方式，对于系统A来说，只要把消息发送给MQ，然后系统B就会
        异步的去处理了，系统A不需要同步的等待系统B处理完，这样的好处是什么呢？两个字：解耦


    应用系统之间解耦合
        发送者和接受者不必了解对方，只需要确认消息；
        发送者和接受者不必同时在线



MQ产类
   rabbitmq
    基于AMQP协议，erlang语言开发的
    具体windows安装教程可见 https://www.cnblogs.com/vaiyanzi/p/9531607.html

管理界面介绍
    Overview
        概览信息
            total

            node
                节点：rabbitmq的服务节点，可有搭建多个
            Ports and contexts
                监听端口
                    amqp(RabbitMQ服务的端口)：5672
                    RabbitMQ Management(rabbitmq管理工具的端口):15672
                    clustering(做集群用的端口号):25672

    connections
        客户端到rabbitmq服务的连接

    channels
        通道：数据是从通道里来传输的；自我理解：生产者和消费者都得要创建一个通道，只有两个通道对接了才能传输数据

    exchanges
        交换机(路由)
    queues
        队列
    admin


虚拟主机就有点像关系型数据库里面的库的概念，希望不同的应用之间都有自己独立的空间，互不影响
访问虚拟主机需要将其与用户进行绑定，比如rabbitmq提供的来宾账户是可以访问所有的虚拟主机，拥有root权限，为每个项目的虚拟主机绑定
一个特定的用户；所以必须先创建用户然后再创建虚拟主机，接着将用户与虚拟主机进行绑定，然后再使用rabbitmq；然后消息生产者把消息进入虚拟主机后
通过通道将消息放入交换机(或者不放在交换机中)；
消费者在消费消息时也需要连接rabbirmq的服务器以及虚拟主机，并从通道获取消息；

第一种模型(直连)
    p：生产者，发送消息的程序
    c：消费者，消息的接受者，会一直等待消息的到来
    queue：消息队列，类似一个邮箱，可以缓存消息，生产者香气中投递消息，消费者从中取出消息

    //通道里声明一个队列；声明一个队列,如果声明的队列不存在的情况下会自动创建
     chhannel.queueDeclare(String name, boolean durable, boolean exclusive, boolean autoDelete,aregument);
    参数介绍
        参数1：队列名称
        参数2：用来定义队列的特性是否要持久化，true持久化队列，rabbitmq关闭服务之后会持久化到硬盘，
              重启后又会自动创建；false不会持久化，重启后就没有了这个队列；
              注意：此时只会持久化队列而不会持久化队列里的消息
        参数3：是否独占队列，表示当前的队列只能当前的连接可用，其他的连接不可使用此队列
        参数4：是否在消费完成后自动删除队列，true:是，false：否

    发布消息
        channel.basicpublish(exchange,rountingkey,props,meassage);
        参数1：交换机名称
        参数2：队列名称
        参数3：传递消息额外设置，可在这里设置队列里的消息是否持久化，MessageProperties.PERSISTENT_TEXT_PLAIN 消息持久化
        参数4：消息的具体内容

     注意：消费者声明的队列和生产者声明的队列的参数要一致，否则会认为不是同一个队列

第二种模型(工作队列(任务队列))  平均分配
    当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度，长此以往会导致消息在队列中堆积，
    无法及时处理；此时就可以用到work模型，让多个消费者绑定到一个队列，共同消费消息队列里的消息；队列中的消息一旦被消费，
    就会消失，因此任务是不会被重复执行
    默认分配消息的时候是平均分配

第三种消息确认机制和能者多劳的实现
    消息确认机制
        消费者消费方法
            channel.basicConsume(queue,autoAck,Consumer);
            参数1：队列名称
            参数2：消息自动确认，默认true：消费者自动像通道反馈消息已经被消费了
                    这时通道不关心你的消费业务有没有处理完，消费者这边只要拿到了消息，然后消费者就会像通道反馈消息已经被消费了，
                    即使你的消费者down机了，此时通道立即将队列里的相关消息删除；此时可能会丢失消息
                    false：关闭消息自动确认机制
                            也就是说，即使消息被消费者消费了，但是如果没有收到消费者的手动确认已经消费完成，队列里的消息是不会删除的

                            代码中的变化
                                channel.basicQos(1);//设置通道每次从队列里抓取的消息的个数为1，每次只抓取一个消息

                                //手动确认消息被消费 参数1：消息标识(队列中的消息可能很多，所以每个消息应该有一个唯一的标识，
                                                这样当确认这个消息已经被消费了之后，通过这个标识找到队列里的对应的消息并将其删除)
                                            参数2：false  每次确认一个
                                channel.basicAck(envelope.getDeliveryTag(),multiple);

第四种模型(fanout)
    扇出，也称为广播
    这种模式下的消息发送流程是这样的
        可以有多个消费者
        每个消费者有自己的队列
        每个队列都要绑定交换机
        生产者发送的消息，只能发送到交换机，交换机决定发送给哪个队列，生产者无法决定
        交换机把消息发送给绑定过的所有队列
        队列的消费者都能拿到消息，实现一条消息被多个消费者消费

        消费者
            //消费者创建的通道里绑定交换机(这个交换机是生产者创建的，这是生产者的通道和消费者的通道就对接了)
            channel.exchangeDeclare(exchange,type);
            //临时队列
            String queuename = channel.queueDeclare().getQueue();
            //将队列绑定到交换机上
            channel.queueBind(queuename,exchange,routinKey);



