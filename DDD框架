领域驱动设计
    真实世界是什么样子，那么软件世界就怎么设计；
    真实世界                软件世界
    事物                      对象
    行为                      方法
    关系                      关联
DDD给我们的思路：
    在每次变更的时候，先回到领域模型，基于业务进行领域模型的变更

实体：
        根据eric evans的定义，”一个由它的标识定义的对象叫做实体”。通常实体具备唯一id，能够被持久化，具有业务逻辑，对应现实世界业务对象。
         实体一般和主要的业务/领域对象有一个直接的关系。一个实体的基本概念是一个持续抽象的生命，可以变化不同的状态和情形，但总是有相同的标识。
        需要注意的是：
            一些开发人员将实体当成了orm意义上的实体，而不是业务所有和业务定义的领域对象。在一些实现中采用了transaction script风格的架构，
            使用贫血的领域模型。这种认识上的混乱，在领域驱动架构中，不愿意在领域对象中加入业务逻辑而导致贫血的领域模型，同时还可能使混乱的服务对象激增。

值对象:
    值对象的定义是：描述事物的对象；更准确的说，一个没有概念上标识符描述一个领域方面的对象。这些对象是用来表示临时的事物，或者可以认为值对象是实体的
    属性，这些属性没有特性标识但同时表达了领域中某类含义的概念。
    通常值对象不具有唯一id，由对象的属性描述，可以用来传递参数或对实体进行补充描述。
    作为实体属性的描述时，值对象也会被存储。在uml的类图上显现为一对多或一对一的关系。在orm映射关系上需要采用较复杂的一对多或一对一关系映射。
    关于实体与值对象的一个例子：比如员工信息的属性，如住址，电话号码都可以改变；然而，同一个员工的实体的标识将保持不变。因此，一个实体的基本概念是一
    个持续抽象的生命，可以变化不同的状态和情形，但总是有相同的标识。\
    实体与值对象的区别:
        实体具有唯一标识，而值对象没有唯一标识，这是实体和值对象间的最大不同。
        实体就是领域中需要唯一标识的领域概念。有两个实体，如果唯一标识不一样，那么即便实体的其他所有属性都一样，也认为是两个不同的实体；一个实体的基本
        概念是一个持续抽象的生命，可以变化不同的状态和情形，但总是有相同的标识。
        不应该给实体定义太多的属性或行为，而应该寻找关联，发现其他一些实体或值对象，将属性或行为转移到其他关联的实体或值对象上。

聚合：聚合是用来定义领域对象所有权和边界的领域模式。聚合的作用是帮助简化模型对象间的关系。聚合，它通过定义对象之间清晰的所属关系和边界来实现领域模型
    的内聚，并避免了错综复杂的难以维护的对象关系网的形成。聚合定义了一组具有内聚关系的相关对象的集合，我们把聚合看作是一个修改数据的单元。
       划分aggregation是对领域模型的进一步深化，aggregation能阐释领域模型内部对象之间的深层关联．对aggregation的划分会直接映射到程序结构上．
       比如：ｄｄｄ推荐按aggregation设计model的子包．每个aggregation配备一个repository.aggregation内部的非root对象是通过导航获得的．
       一个聚合是一组相关的被视为整体的对象。每个聚合都有一个根对象（聚合根实体），从外部访问只能通过这个对象。根实体对象有组成聚合所有对象的引用，
       但是外部对象只能引用根对象实体。
       只有聚合根才能使用仓储库直接查询，其它的只能通过相关的聚合访问。如果根实体被删除，聚合内部的其它对象也将被删除。
       通常，我们把聚合组织到一个文件夹或一个包中。每一个聚集对应一个包，并且每个聚集成员包括实体、值对象，domain事件，仓储接口和其它工厂对象。
    聚合有以下一些特点：
    　　1. 每个聚合有一个根和一个边界，边界定义了一个聚合内部有哪些实体或值对象，根是聚合内的某个实体；
    　　2. 聚合内部的对象之间可以相互引用，但是聚合外部如果要访问聚合内部的对象时，必须通过聚合根开始导航，绝对不能绕过聚合根直接访问聚合内的对象，也就是说聚合根是外部可以保持对它的引用的唯一元素；
    　　3. 聚合内除根以外的其他实体的唯一标识都是本地标识，也就是只要在聚合内部保持唯一即可，因为它们总是从属于这个聚合的；
    　　4. 聚合根负责与外部其他对象打交道并维护自己内部的业务规则；
    　　5. 基于聚合的以上概念，我们可以推论出从数据库查询时的单元也是以聚合为一个单元，也就是说我们不能直接查询聚合内部的某个非根的对象；
    　　6. 聚合内部的对象可以保持对其他聚合根的引用；
    　　7. 删除一个聚合根时必须同时删除该聚合内的所有相关对象，因为他们都同属于一个聚合，是一个完整的概念。

    如何识别聚合？
    聚合中的对象关系是内聚的，即这些对象之间必须保持一个固定规则，固定规则是指在数据变化时必须保持不变的一致性规则。
    当我们在修改一个聚合时，我们必须在事务级别确保整个聚合内的所有对象满足这个固定规则。
    作为一条建议，聚合尽量不要太大，否则即便能够做到在事务级别保持聚合的业务规则完整性，也可能会带来一定的性能问题。
    有分析报告显示，通常在大部分领域模型中，有70%的聚合通常只有一个实体，即聚合根，该实体内部没有包含其他实体，只包含一些值对象；另外30%的聚合中，
    基本上也只包含两到三个实体。这意味着大部分的聚合都只是一个实体，该实体同时也是聚合根。
    如何识别聚合根？
    　　如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互。
        并不是所有的实体都是聚集根，但只有实体才能成为聚集根

仓库：仓储是用来管理实体的集合。用来存储聚合，相当于每一个聚合都应该有一个仓库实例
     写操作时针对的是聚合对象，原子性的写；读操作时参数针对的是值对象，返回的肯定也是个聚合对象


     仓储里面存放的对象一定是聚合，原因是domain是以聚合的概念来划分边界的；聚合作为一个整体概念，要么一起被取出来，要么一起被删除。外部访问不会单独
     对某个聚合内的子对象进行单独操作。因此，我们只对聚合设计仓储。
     仓储还有一个重要的特征就是分为仓储定义部分和仓储实现部分，我们在领域模型中定义仓储的接口，而在基础设施层实现具体的仓储。也符合按照接口分离模式
     在领域层定义仓储库接口的原则。
     注意：repositories本身是一种领域组件，但repositories的实现却不是领域层中的。
     respositories和dao：
     dao和repository在领域驱动设计中都很重要。dao是面向数据访问的，是关系型数据库和应用之间的契约。
     repository：位于领域层，面向aggregation root。repository是一个独立的抽象，使用领域的通用语言，它与dao进行交互，并使用领域理解的语言提供
     对领域模型的数据访问服务的“业务接口”。
 　　 dao方法是细粒度的，更接近数据库，而repository方法的粒度粗一些，而且更接近领域。领域对象应该只依赖于repository接口。客户端应该始终调用
     领域对象，领域对象再调用dao将数据持久化到数据 存储中。
 　　 处理领域对象之间的依赖关系（比如实体及其repository之间的依赖关系）是开发人员经常遇到的典型问题。解决这个问题通 常的设计方案是让服务类或
     外观类直接调用repository，在调用repository的时候返回实体对象给客户端



工厂：是用来生成聚合的，当生成一个聚合的步骤过于复杂时，可以将其生成过程放在工厂中
     由于仓库操作的是一个聚合，所以当在service里生成聚合比较复杂时就可以使用工厂，在这个工厂里我们可以将某个领域对象里面需要的某个聚合
     给查出来并封装到这个领域对象里；
     interface里的service初步封装一下领域对象，然后作为参数交给具体的applocation service里的工厂来生成聚合
     application里的service主要的工作就是工厂生成聚合然后将聚合交给仓库进行处理


    工厂用来封装创建一个复杂对象尤其是聚合时所需的知识，作用是将创建对象的细节隐藏起来。客户传递给工厂一些简单的参数，然后工厂可以在内部创建出
    一个复杂的领域对象然后返回给客户。当创建 实体和值对象复杂时建议使用工厂模式。
      不意味着我们一定要使用工厂模式。如果创建对象很简单，使用构造器或者控制反转/依赖注入容器足够创建对象的依赖。此时，我们就不需要通用工厂模式来
      创建实体或值对象。
      良好工厂的要求：
      每个创建方法都是原子的。一个工厂应该只能生产透明状态的对象。对于实体，意味着创建整个聚合时满足所有的不变量。
     一个单独的工厂通常生产整个聚合，传出一个根实体的引用，确保聚合的不变量都有。如果对象的内部聚合需要工厂，通常工厂方法的逻辑放在在聚合根上。
     这样对外部隐藏了聚合内聚的实现，同时赋予了根确保聚合完整的职责。如果聚合根不是子实体工厂的合适的家，那么继续创建一个单独的工厂。
