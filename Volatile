Java内存模型简称JMM
JMM定义了java虚拟机在计算机内存(RAM)中的工作方式
JMM包括：
    工作内存：将主内存里的变量数据拷贝一个副本到工作内存
    主 内 存：变量放在堆内存里

volatile缓存可见性实现原理
    汇编指令lock
    1、将当前处理器缓存行数据立刻写回主内存
    2、这个写操作，会触及总线嗅探机制(MESI协议)，其他处理器中变量副本会立刻失效，并强制要求从主内存中重新读取变量数据

  自己的理解，一个线程读取堆内存中的数据时只会读取一次，或者很久没有更新堆内存中的数据，所以当有线程改变了堆内存中数据后，
  其他内存不会重新从堆内存获取数据，所以导致了可见性问题


原子性就是指该操作是不可再分的。不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作。
简而言之，在整个操作过程中不会被线程调度器中断的操作，都可认为是原子性。比如 a = 1；
cpu可以单独占用总线直到指令结束，多核系统中的原子操作通常使用内存栅障（memory barrier）来实现，
即一个CPU核在执行原子操作时，其他CPU核必须停止对内存操作或者不对指定的内存进行操作，这样才能避免数据竞争问题；


自我理解：
    事务的原子性是指：要么成功，要么失败，没有中间状态，但是如果有人中间修改了操作的数据，但是只要成功执行完成，这也满足原子性；
    原子操作就不一样了，他就涵盖了事务中的原子性，隔离性，一致性原则
