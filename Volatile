Java内存模型简称JMM
JMM定义了java虚拟机在计算机内存(RAM)中的工作方式
JMM包括：
    工作内存：将主内存里的变量数据拷贝一个副本到工作内存
    主 内 存：变量放在堆内存里

缓存一致性协议(MESI)
    多个cpu从主内存读取同一个数据到各自的高速缓存，当其中某个cpu修改了缓存里的数据，该数据会马上同步回主内存，其他cpu通过总线
    嗅探机制可以感知到数据的变化从而将自己缓存里的数据失效；

    缓存加锁
        缓存锁的核心机制是基于缓存一致性协议来实现的，一个处理器的缓存回写到主内存会导致其他处理器的缓存无效，IA-32和intel 64
        使用MESI实现缓存一致性协议


volatile缓存可见性实现原理
    主要是通过汇编lock前缀指令，他会锁定这块内存区域的缓存(缓存行锁定)并回写到主内存
    IA-32和intel 64架构软件开发者手册对lock前缀指令的解释
    1、将当前处理器缓存行数据立刻写回主内存
    2、这个写回主内存的操作，会触及总线嗅探机制(MESI协议)，引起其他处理器中变量副本立刻失效，并强制要求从主内存中重新读取变量数据
    3、提供内存屏障功能，使lock前后指令不能重排序

  自己的理解，一个线程读取堆内存中的数据时只会在第一次的时候读取一次，或者很久没有更新堆内存中的数据，所以当有线程改变了堆内存中数据后，
  其他内存不会重新从堆内存获取数据，所以导致了可见性问题


原子性就是指该操作是不可再分的。不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作。
简而言之，在整个操作过程中不会被线程调度器中断的操作，都可认为是原子性。比如 a = 1；
cpu可以单独占用总线直到指令结束，多核系统中的原子操作通常使用内存栅障（memory barrier）来实现，
即一个CPU核在执行原子操作时，其他CPU核必须停止对内存操作或者不对指定的内存进行操作，这样才能避免数据竞争问题；


自我理解：
    事务中的原子性是指：要么成功，要么失败，没有中间状态，但是如果有人中间修改了操作的数据，但是只要成功执行完成，这也满足原子性；
    原子操作就不一样了，他就涵盖了事务中的原子性，隔离性，一致性原则
