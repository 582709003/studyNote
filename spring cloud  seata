
关于seata的知识点可以查看官网

CAP原则
    集群只能满足其中的CP或者AP，单机系统满足的是CA；我们往往牺牲一致性来满足可用性和分区容错性，不过这里指出的是，所谓的牺牲一致性并不是
    完全放弃数据的一致性，而是牺牲强一致性换取弱一致性；

    强一致性：在任意时刻，所有节点中的数据都是一样的，任何一次读取到的数据都是最近一次写入的数据；
    强一致性总结：在一个集群需要对外提供强一致性，所以只要集群内部一台服务器的数据发生了变化，那么就需要等待集群内其他服务器的数据同步完成后，
               整个系统才能对外提供服务；保证了强一致性，势必会损耗可用性

    弱一致性：系统中的某个数据被更新后，后续对该数据的读取可能是更新后的值，也可能是更改前的值；

    最终一致性：是弱一致性的特殊形式，存储系统在保证没有更新的情况下，最终所有的访问请求到的都是最后一次更新的值

    弱一致性和最终一致性的区别：
        弱一致性即使过了“不一致时间”的窗口，后续的读取也不一定能保证一致；而最终一致性过了不一致窗口后，后续的读取一定一致

Base理论
    BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。BASE理论是
    对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结， 是基于CAP定理逐步演化而来的。BASE理论的核心思想是：即使无
    法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。接下来看一下BASE中的三要素：
    1、基本可用
        基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性—-注意，这绝不等价于系统不可用。比如：
        （1）响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了
            1~2秒
        （2）系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的
            时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面
    2、软状态
        软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的
        过程存在延时
    3、最终一致性
        最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据
        能够达到一致，而不需要实时保证系统数据的强一致性。
    总的来说：
        BASE理论面向的是大型高可用可扩展的分布式系统，和传统的事物ACID特性是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得
        可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，
        因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。

seata
    术语
       TC：事务协调者：维护全局和分支事务的状态(seata服务器seata-server-0.9.0\seata\bin\seata-server.bat)
       TM：事务管理器：定义全局事务的范围，开始、提交或回滚全局事务(事务的发起方，即标注了@GlobalTransactional注解的方法)
       RM：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚
           (事务的参与方，一个数据库就是一个RM，订单库、库存库、账户库)
       UNDO_LOG表(这是一张数据库表):回滚日志
                  1、undo_log必须在每个业务数据库中创建，用于保存、回滚操作数据
                  2、当全局提交时，undo_log日志直接删除
                  3、当全局回滚时，将现有数据撤销，还原至操作前的状态
    AT模式
        一阶段分支事务在提交本地事务前需要获取全局锁，获取本地锁后提交本地事务，然后就可直接释放本地锁
        一阶段分支事务如果不能获取全局锁，则需要阻塞等待，直到获取全局锁才能提交本地事务；
        事务持有的全局锁需要在二阶段全局事务提交或者回滚的时候才会释放，一旦释放全局锁，下一个全局事务里的分支事务才会执行，进而全局事务才回提交或者
        回滚，再次释放全局锁，如此循环反复。

    写隔离
        一阶段本地事务提交前，需要确保先拿到 全局锁 。
        拿不到 全局锁 ，不能提交本地事务。
        拿 全局锁 的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。

        以一个示例来说明：
         两个全局事务 tx1 和 tx2，分别对 a 表的 m 字段进行更新操作，m 的初始值 1000。
         tx1 先开始，开启本地事务，拿到本地锁，更新操作 m = 1000 - 100 = 900。本地事务提交前，先拿到该记录的 全局锁 ，本地提交释放本地锁。
         tx2 后开始，开启本地事务，拿到本地锁，更新操作 m = 900 - 100 = 800。本地事务提交前，尝试拿该记录的 全局锁 ，tx1 全局提交前，
         该记录的全局锁被 tx1 持有，tx2 需要重试等待 全局锁 。
         tx1 二阶段全局提交，释放 全局锁 。tx2 拿到 全局锁 提交本地事务。
         如果 tx1 的二阶段全局回滚，则 tx1 需要重新获取该数据的本地锁，进行反向补偿的更新操作，实现分支的回滚。
         此时，如果 tx2 仍在等待该数据的 全局锁，同时持有本地锁，则 tx1 的分支回滚会失败。分支的回滚会一直重试，直到 tx2 的 全局锁 等锁超时，
         放弃 全局锁 并回滚本地事务释放本地锁，tx1 的分支回滚最终成功。
         因为整个过程 全局锁 在 tx1 结束前一直是被 tx1 持有的，所以不会发生 脏写 的问题。


服务端部署步骤
    1、将C:\app install package\seata-1.4.2\script下的server下的db下的sql文件复制到数据库中
    2、将file.conf以及registry.conf下的文件修改一下，具体如何配置看视频吧
    3、启动seata，去nacos看看服务有没有注册上去


