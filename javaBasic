java虚拟机即jvm是在安装jdk时安装好的，不同的操作系统安装不同的jdk，所以jvm其实也是不同的，但是
不同的jvm可以执行相同的字节码，这就是为什么java可以跨平台；


Java程序的运行需要经过编译阶段以及执行阶段
    编译阶段：检查Java源程序是否符合Java语法，符合就生成字节码，不符合就无法生成字节码文件；
             字节码文件不是纯粹的字节码文件
             使用jdk中带有的javac.exe命令生成字节码文件
    运行阶段：使用jdk带有的java.exe命令，主要负责执行字节码文件；
             java.exe会启动java虚拟机，jvm会启动类加载器ClassLoder,JVM会将字节码文件
             解释为二进制文件，然后操作系统执行二进制和底层硬件平台进行交互。


jdk、jre、jvm三者关系
    首先jdk和jre是独立的两个东西，两者可以独立下载安装
    jdk是程序开发包，程序员需要使用里面的各种包工具进行开发，如果仅仅是为了开发但是你不需要测试就只安装jdk即可，但是程序员是不可能
    不运行程序的，所以一般下载安装jdk时会默认下载安装jre；
    jre：这个是运行时环境，类加载器就是jre提供的，一般会在下载jdk时自动下载这个jre，但如果不要jdk可以单独安装；
    jvm：这个就是安装jre最大的用处，jvm不可以单独下载安装，jvm是jre的一个功能；
    在安装jdk时会问你要不要再安装jre，你也可以选择不安装，因为你的额jdk下已经有了jre；

配置环境变量
    windows是如何搜索命令的：
        首先会从当前目录搜索，搜索不到的话会从环境变量的path路径中搜索，
        如何都搜索不到就报错

    系统变量和用户变量的区别
        系统变量配置的话会作用整个系统，不区别哪个用户；用户变量会作用于这个用户；

注释
    javadoc注释
        /**
          * javadoc注释
          * javadoc注释
          * javadoc注释
          .......
        **/
      这种注释以后，javadoc命令在生成javadoc帮助文档时会将这部分类容提取出来放到帮助文档里；


public class和class的区别
    一个java源文件中可以有多个class文件
    一个java源文件中不一定有public class
    一个class会定义生成一个.class字节码文件
    一个java源文件当中定义public的class的话，public 的class只能有一个
                ，并且该类名必须和java源文件名称一致

标识符的命名规则：
    只能由数字、字母、下划线、美元符号$组成，不能有其他符号；
    不能由数字开头；
    关键字不能做标识符；
    理论上无长度限制，但也不要过长


变量
    变量是由数据类型、变量名、字面值组成；局部变量需要初始化后方可访问，否则报错；
        成员变量未赋值时，系统会默认赋值
        默认值
            byte、short、int、long   0
            float、double            0.0
            boolean                 false（在c语言中，true是1，false是0）
            char                    u\0000


数据类型
    作用：不同数据类型的数据占用空间大小不同，所以数据类型的作用是指导jvm运行程序时给该数据分配多大的内存空间

    分类：分基本数据类型和引用数据类型(包含字符串、类、接口、数组.......)

    基本数据类型：四大类和八小种
        第一类：整数型
            byte、short、int、long
        第二类：浮点型
            float、double
        第三类：布尔型
            boolean
        第四类：字符型
            char
83
64 32 16 8 4 2 1
1   0  1  0 0 1 1
    字符串不属于基本数据类型，属于引用类型，字符属于基本数据类型

    基本数据类型               占用空间大小(单位：字节)
    ----------------------------------------------
    byte                        1
    short                       2
    int                         4
    long                        8
    float                       4
    double                      8
    boolean                     1
    char                        2

    计算机在任何情况下都只能识别二进制

    字节：
        1 Byte = 8 bit 一个字节等于8个比特位（一个比特位表示一个二进制位）
        1 G = 1024*1024*1024*8 的比特位，就只能存这么多0或者1

        二进制位最左边的数字为0表示整数，1表示负数

    byte类型取值范围 -128 ~ 2^7 - 1 = 127
    short类型取值范围 -2^15 ~ 2^15-1
    int类型取值范围 -2^31 ~ 2^31-1
    每一种组合的二进制就是一个数字
    ...........

    java语言中表示一个整数时有三种表达方式，
    十进制   默认方式
    八进制  以0开始
    十六进制    以0X开始

    java语言中整数字面值被默认当作int类型来处理，要让这个整数型的字面值被当作long类型来处理的话需要在字面值后面加一个l/L，建议大写L
    long s = 2147483648;
    2147483648 一开始就被默认为int类型，但是int类型最大值是2147483647，所以这个数字本身就
    溢出了，报错，所以要在后面加一个大写L，这样这个数字就会自动转换为long类型

    大容量的数字类型不能直接赋值给小容量，需要进行强制转换，即加上强制转换类型符；
    但是运行阶段可能损失精度
    强转原理：
        元数据：00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100
        墙砖后数据：00000000 00000000 00000000 01100100
        将左边的二进制去掉（所有数据强转都是这样），计算机内部都是保存的补码形式
        正数的原码、反码、补码都是一样的，但是负数 的不一样，
        原码：将最高位作为符号位（0表示正，1表示负），其它数字位代表数值本身的绝对值的数字表示方式。

        反码：如果是正数，则表示方法和原码一样；如果是负数，符号位不变，其余各位取反，则得到这个数字的反码表示形式。

        补码：如果是正数，则表示方法和原码一样；如果是负数，则将数字的反码加上1（相当于将原码数值位取反然后在最低位加1）。

    byte、short以及char类型在赋值时，虽然字面值是int类型，但是不需要强转，因为sun公司给与了优待，
    只要是在类型的取值范围类都可以编译通过，但是只要超过了就会编译报错

    当计算机碰到字符类型时传统的转换为二进制就会出问题，因为数字和二进制之间的转换规则制定好之后
    就可以简单的转换；但是字符和二进制之间的转换没有指定规则于是乎就会出问题；
    所以就出现了编码方式，例如Ascill、utf-8、gbk等等；

    编码
        unicode编码方式统一了全球所有文字，容量较大；它的编码方式有多种实现：
            utf-8
            utf-16
            utf-32
            ......

        java语言使用的时utf-8编码，所以标识符可以使用中文

    空格符和制表符是不同得分asicll码

    \是转义字符，放在特殊字符之前会将特殊字符转变为普通字符

    浮点型类型详解
    float 单精度（4字节）
    double 双精度（8字节）
    double的精度也还是比较低，不适合做财务软件，涉及到钱的问题，所以sun在基础se类库中为程序员准备了精度更高的
    数据类型，只不过这是一中引用数据类型，不属于基本数据类型，他就是
    java.math.BigDecimal

    se类库字节码：jdk/jre/lib/rt.jar
    源码：jdk/src.zip

    java语言中，所有的浮点类型的数据字面值都被默认为double来处理，要想以float类型来处理，
    需要在字面值后以f/F来标识

    注意：
        在计算机中，double和float都是存储的近似值


   基本数据类型之间的相互转换
        1、八种借本数据类型除布尔类型外，其他都可以相互转换
        2、小容量向大容量转换，可自动转换
            byte<short<int<long<float<double
            byte<char<int<long<float<double
            注意：任何浮点型都比整数型容量大；char和short可表示的种类数量相同，但是char可以取更大的正整数
        3、大容量转小容量时需要强制类型转换，可能会损失精度
        4、byte、short、char混合运算时，各自先转换成int类型再做运算，结果也就是最大容量类型
        5、多种数据类型混合运算时，先转换成最大容量的那种类型再进行运算，结果也就是最大容量类型。
        double a = 10.0/3  结果是3.3333333335


算术运算符
    ++
        1、++运算符可以出现在变量前以及变量后，只要运算结束，该变量都会自加1；
        2、++出现在变量后的话：先做赋值运算，然后再自行加1
            int a = 100;
            int b = a++;

            a = 101,b=100

           ++出现在变量前面：先做自行加1运算，然后再进行赋值操作
           int m = 100;
           int n = ++ m;

           m=101,n = 101


        逻辑运算符
            &   逻辑与
            |   逻辑或
            !   逻辑非
            ^
            &&  短路与
            ||  短路或

            & 和 &&  以及  | 和 || 其实运算的结果都是一样的，区别见下：
            a & b 运算时，a和b都会运算
            a && b 运算时，如果a已经判定为true，b就不会运算




while循环语句可能执行0次；但是do while 最起码执行一次；

break语句使用在for,while,do...while循环语句跳出循环；
默认情况下，break语句中断的时距离它最近的循环语句;但是也可以给循环语句起名，用来中断指定的循环语句
           a:for (int j = 0; j < 10; j++) {
                b:for (int l = 0; l < 5; l++) {
                    System.out.println(l);
                    if (l == 3) {
                        break a;
                    }
                }
            }


方法詳解
    在jvm内存裏有這樣三块主要内存空间，（当然除了这三块内存还有其他内存空间）
    *方法去内存
    *堆内存
    *栈内存

    关于栈(stack)的数据结构
        栈属于先进后出，后进先出的数据结构；
        栈帧永远指着栈顶元素；
        栈顶元素保持活跃，其他元素静止


    方法代码片段存在哪里？方法执行的时候执行内存的过程在那里分配？
        *方法代码片段属于.class字节码文件的一部分，字节码文件再类加载的时候，将其放到
        了方法区当中，所以jvm中的三块主要的内存空间中方法区内存最先有数据，存放了代码片段。

        代码片段 虽然在方法区内存中只保留一份，但是可以被重复利用；每次调用方法的时候，需要给该方法分配独立的活动场所
        在栈内存中分配（栈内存中分配方法运行所属的内存空间）

        方法在调用的瞬间会给该方法在栈内存分配内存空间，并且发生压栈动作（分配内存空间），(方法执行就是栈帧的特点，只有栈帧保持活跃，其他方法静止，也就是其他元素静止)方法结束后发生弹栈工作（释放内存空间）
        局部变量在‘方法体’中声明，局部变量运行阶段的内存在栈中分配




方法重载(overload)
    *在同一个类中
    *方法名相同
    *参数列表不同
        数量不同
        类型顺序不同
        类型不同
    方法重载只和方法名+参数列表有关系；和返回值类型无关，修饰符列表无关


递归
    方法自己调用自己；
    递归必须有结束条件，没有结束条件一定会发生栈内存溢出，jvm停止工作；
    递归即使有了结束条件，即使结束条件是正确的，也有可能发生栈内存错误，因为递归的太深了



对象的创建
    成员变量又叫做实例变量，不创建对象，实例变量的内存空间是不存在的，只有创建了实例对象，实例变量的内存空间才会创建；

    创建对象：new 类名();

    new 是java语言中的一个运算符，作用是创建对象，在jvm堆内存中开辟新的内存；

    方法区内存：在类加载的时候，class字节码代码片段被加载到该内存空间当中；

    栈内存(局部变量)：方法代码片段执行的时候，会给该方法分配内存空间，在栈内存中压栈，局部变量的基本数据类型字面值保存在栈内存；

    堆内存：new的对象在堆内存中存储；

    局部变量在栈内存中存储；引用保存的是内存地址，所以引用类型的局部变量实际被赋值的是内存地址；

    java语言中，程序员不能直接操作堆内存，程序员只能通过“引用”区访问对象内部的实例变量

    引用之间的赋值其实就是内存地址的赋值；

    内存总结
        1、jvm只要包括三块内存：堆内存、栈内存、方法区内存
        2、堆内存和方法区内存各有一个，一个线程一个栈内存
        3、方法调用的时候，该方法所需要的内存空间在栈内存中分配，称为压栈；方法执行结束后，该方法所属的内存空间释放，称为弹栈
        4、栈中主要存储的是方法体当中的局部变量
        5、方法的代码片段以及整个类的代码片段都被存储到方法区内存当中，在类加载的时候这些代码片段会载入；
        6、在程序执行过程中使用new运算符创建的java对象，存储在堆内存当中；
            对象内部有实例变量，所以实例变量存储在堆内存当中；
        7、变量分类
            局部变量
            成员变量
                实例变量
                静态变量
        8、静态变量存储在方法区内存当中
        9、三块内存中变化最频繁的是栈内存，最先有数据的是方法区内存，垃圾回收器主要针对的是堆内存；
        10、垃圾回收机制，什么时候会考虑将某个Java对象的内存回收呢
                当堆内存当中的java对象称为垃圾数据的时候，会被垃圾回收器回收
                当没有更多的引用的指向它的时候，就会变成垃圾


this关键字
    使用在方法当中，this使用在构造方法当中，通过当前的构造方法调用其他的构造方法，语法:this(实参)；
    重点记忆：this这种语法出现在构造函数时，只能出现在构造函数第一行;

    所有静态数据都可以采用类名.也可采用引用.，但是建议类名.访问；
    采用引用的方式访问的时候即使引用为空也不会空指针异常，因为访问静态数据根本不需要对象的存在；

    this能出现在实例方法和构造方法中
        语法是this.  this()
        this不能使用在静态方法中
        this大部分情况可以省略，省略情况下是this.
        this
        this()出现在构造方法中时，只能出现在第一行，通过当前的构造方法区调用父类中的构造方法，目的是：代码复用


super关键字
    super(实参)作用是：初始化父类型特征，super. 可访问属性以及方法
    super能出现在实例方法和构造方法中
    语法是super.  super()；
    super不能使用在静态方法中
    super大部分情况可以省略
    super 子类和父类可以有同名属性，因为在不同的内存空间；子类中有和父类同名的属性，希望在子类属性中访问父类的属性，不能省略super
    super()出现在构造方法中时，只能出现在第一行，通过当前的构造方法区调用父类中的构造方法，目的是：代码复用
    this和super不能共存在构造器中

    重要结论
        当一个构造器第一行
            既没有this()有没有super()，默认会有一个super();
            表示通过当前字类的构造器调用父类的无参构造器，
            所以必须保证父类的无参构造器必须存在；
            super不是引用，也不保存内存地址，也不止像任何对象，他只代表当前对象内部的那一块父类型的特征；
访问控制权修饰符
    Public  所有地方均可被访问
    protected  同包以及子类可被访问
    default     同包下可被访问
    private     本类中可被访问

ping命令
    如何查看两台计算机是否可以正常通信
        可以使用ping命令
            ping ip/域名
            ping ip/域名 -t 这个命令会一直ping


方法重写
    什么条件构成方法重写
        1、两个类必须有继承关系
        2、重写之后的方法和之前的方法具有：
            相同的返回值类型
            相同的方法名
            相同的形参
        3、访问权限不能更低，可以更高
        4、重写之后的方法不能比之前的方法抛出更多的异常，可以更少

    注意事项
        1、方法覆盖只针对于方法，和属性无关
        2、私有方法无法覆盖
        3、构造方法因为无法继承，素以也不能被覆盖
        4、方法只针对于实例方法，静态方法覆盖没有意义


多态指的是：
    夫类型引用值类型对象
    包括编译阶段和运行阶段
    编译阶段：绑定父类的方法
    运行阶段：动态绑定子类型对象的方法
    多种形态


instanceof
    1、可以在运行阶段动态判断引用指向的对象的类型
    2、语法：引用 instanceof 类型
    3、运算结果 boolean类型



final关键字
    1、可修饰变量、方法、类
    类：
        B类继承A类，相当于对A类的功能进行了扩展，如果你不希望别人对A类进行扩展，你可以对A类加上final关键字，这样的话A类就无法继承了
    方法：
        final修饰的方法无法被重写；

    变量：
        final修饰的变量只能赋值一次值；
        final修饰的引用一旦指向某个对象，则不能再重新指向其他对象，但是该引用指向的对象内部的数据是可以修改的
        final修饰的实例变量必须手动初始化，不能采用系统默认值；
        final修饰的实例变量一般和static联合使用，称为常量；
        常量和静态变量都放在方法区，并且再类加载时初始化

抽象类和接口以及抽象类和接口的区别
    抽象类：抽象类无法实例化，抽象类是类和类之间有共同特征，将这些具有共同特征的类再进一步进行抽象就形成了抽象类；由于类本身
           是不存在的，所以抽象类无法创建对象；
           抽象类属于什么类型：抽象类也属于引用数据类型；
           抽象类如何定义：【修饰符列表】 abstract class {
                    类体
           }

           抽象类由于无法实例化，无法创建对象，所以抽象类是用来被字类继承的

           抽象类的字类仍然可以是抽象类
           抽象类虽然无法实例化，但是抽象类有构造方法，这个构造方法是供子类使用的；
           抽象类关联到一个概念：抽象方法，抽象方法表示没有实现的方法，没有方法体的方法就是抽象方法；
           抽象类中可以没有抽象方法，抽象方法必须存在抽象类中；
           一个非抽象的类继承了抽象类，必须将抽象类中的方法重写，否则会报错；
           抽象类 a = new 子类()；这个是可以的，向上转型


    接口：
        1、接口也是一种引用数据类型，编译之后也是一个class字节码文件
        2、接口是完全抽象的（抽象类是半抽象），也可以说接口是特殊的抽象类
           【修饰符列表】 interface 接口名{

           }
        3、接口支持多继承
        4、接口中只包含两部分内容：一部分是常量，一部分是抽象方法
        5、接口中所有的元素都是public修饰的；
        6、接口中所有的抽象方法的public abstract修饰符都可以省略;常量的public static final也可以省略
        7、一个类可以同时实现多个接口


Object类
    finalize():这个方法没有方法体，且是由protected修饰的
    这个方法不需要程序员手动调用，jvm垃圾回收器负责调用这个方法
    这个方法其实是为程序员提供的一个时机，程序员可以当垃圾回收的时候在这个地方写代码

    hashcode方法返回的是哈希码：实际上是一个java对象的内存地址经过哈希算法得出一个值，
    所以hashcode()方法的执行结果可以等同看作一个对象的内存地址



匿名内部类
    1、什么是内部类
        在类的内部由定义了一个新的类，被称为内部类

    2、内部类的分类
        静态内部类：类似于静态变量
            内部类前面有static修饰
        实例内部类：类似于实例变量
            内部类前面没有static修饰
            语法：new 外部类().new 内部类()
        局部内部类：类似于局部变量
            在方法体的内部的内部类

    3、使用内部类编写的代码可读性很差，能不用就不用
    4、匿名内部类是局部内部类的一种
        因为这个类没有名字，所以叫做匿名内部类

        表面上看上去好像是可以new接口了，实际上并不是接口可以new了，后面的大括号代表了对接口的实现
        new 接口(){
            对接口方法的实现
        }

        不建议使用匿名内部类，因为一个类没有名字，没有办法是用，代码也乱，可读性太差


数组
    数组也是一种引用数据类型，父类是Object
    数组是一种容器，可同时容纳多个容器；数组可以存储基本数据类型，也可以存储引用数据类型
    因为数组是引用数据类型，所以数组对象是存储在堆内存中的
    存储引用数据类型时是将引用数据类型的对象的内存地址存放到数组中
    数组一旦创建，在java中规定，长度不可变
    数组的分类：一维数组、二维数组、多维数组(一维数组较多)
    所有的数组都有length属性，用来获取数组的长度
    java中规定数组要求数组中的元素类型必须统一
    数组在内存方面存储的时候，数组中的元素内存地址是连续的，紧挨着的，这是数组存储的特点
    数组实际上是一种简单的数据结构
    所有的数组都是拿第一个元素的内存地址作为整个数组对象的内存地址
    下标从0考试，最后一个小标  length - 1
    数组的优缺点
        优点：1、查询/查找检索效率高
                原因：每一个元素的内存地址在空间上是连续的
                      每一个元素类型相同，所以占用空间大小一样
                      知道第一个元素内存地址，每一个元素占用空间的大小，又知道下标，所以通过一个
                      数学表达式就可以计算出某个下标上的元素的内存地址，直接通过内存地址定位元素，所以检索效率极高

        缺点：1、由于为了保证数组中每个元素的内存地址连续，所以在数组上随机删除增加元素的时候，效率极低
             因为会导致后面的元素统一的向前或向后的位移

             2、数组不能存储大数据量，因为很难在内存空间中找到一块特别大的连续的内存空间地址


        注意：数组对最后一个元素的增删，效率上是没有影响的

        语法：
            静态初始化语法：int[] array = {100,200,300};
            动态初始化语法：int[] array = new int[3]; 每个元素默认值0，引用类型默认值为null

             Customer[] arry  = {new Customer(),new Vip()};这样的语法是可以的；
             Customer aa = arry[0];
             Customer bb = arry[1];

             aa.shop(); 结果是customer
             bb.shop(); 结果是vip


        数组的扩容
            数组满了需要扩容；扩容是：
                先新建一个大容量的数据，然后将一个小容量数组中的数据一个个拷贝到大数组当中
                数组扩容效率较低

            扩容方法：
                System.arraycopy(Object src（源数组）,  int  srcPos（源数组希望拷贝的起始下标）,
                                                        Object dest（目标数组）, int destPos（希望拷贝到目标数组的哪个小标）,
                                                        int length（拷贝多长）)

      二维数组：
        语法：int [][]k = new int[i][j]
        对于二维数组k来说   i这个位置必须赋值，而j 这个位置 可以赋值 也可以空着不赋值。


BigDecimal：java.math.BigDecimal
    属于大数据，精度极高，不属于基本数据类型，数据java对象（引用数据类型）
    财务软件中double是不够用的


序列化和反序列化：
    序列化：Java对象存储到文件中，拆分Java对象并给每一个拆分的对象进行编号然后传输到硬盘文件后再进行组装，将java
           对象状态保存下来的过程
    反序列化：将硬盘上的数据重新恢复到内存当中，恢复成java对象

    参与序列化和反序列化的对象必须实现Serializable接口，这个接口起到标识的作用,会为该类自动生成一个序列化版本号

    java虚拟机识别一个类的时候先通过类名（包名+类名），然后再通过序列号（如果实现Serializable接口）
    序列化版本号作用是区分类的,所以还是给类生成一个序列化版本号，idea可自动生成

Transient关键字:
    如果对象的某个属性你不希望序列化，就可以在这个属性前加上这个关键字













































