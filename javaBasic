java虚拟机即jvm是在安装jdk时安装好的，不同的操作系统安装不同的jdk，所以jvm其实也是不同的，但是
不同的jvm可以执行相同的字节码，这就是为什么java可以跨平台；


Java程序的运行需要经过编译阶段以及执行阶段
    编译阶段：检查Java源程序是否符合Java语法，符合就生成字节码，不符合就无法生成字节码文件；
             字节码文件不是纯粹的字节码文件
             使用jdk中带有的javac.exe命令生成字节码文件
    运行阶段：使用jdk带有的java.exe命令，主要负责执行字节码文件；
             java.exe会启动java虚拟机，jvm会启动类加载器ClassLoder,JVM会将字节码文件
             解释为二进制文件，然后操作系统执行二进制和底层硬件平台进行交互。


jdk、jre、jvm三者关系
    首先jdk和jre是独立的两个东西，两者可以独立下载安装
    jdk是程序开发包，程序员需要使用里面的各种包工具进行开发，如果仅仅是为了开发但是你不需要测试就只安装jdk即可，
    但是程序员是不可能不运行程序的，所以一般下载安装jdk时会默认下载安装jre；
    jre：这个是运行时环境，类加载器就是jre提供的，一般会在下载jdk时自动下载这个jre，但如果不要jdk可以单独安装；
    jvm：这个就是安装jre最大的用处，jvm不可以单独下载安装，jvm是jre的一个功能；
    在安装jdk时会问你要不要再安装jre，你也可以选择不安装，因为你的额jdk下已经有了jre；

配置环境变量
    windows是如何搜索命令的：
        首先会从当前目录搜索，搜索不到的话会从环境变量的path路径中搜索，
        如何都搜索不到就报错

    系统变量和用户变量的区别
        系统变量配置的话会作用整个系统，不区别哪个用户；用户变量会作用于这个用户；

    springboot项目，一般springboot项目里classpath目录指的是resources文件夹，src目录下的main，
    编译后它下面的内容会被放到classpath下

注释
    javadoc注释
        /**
          * javadoc注释
          * javadoc注释
          * javadoc注释
          .......
        **/
      这种注释以后，javadoc命令在生成javadoc帮助文档时会将这部分类容提取出来放到帮助文档里；


public class和class的区别
    一个java源文件中可以有多个class文件
    一个java源文件中不一定有public class
    一个class会定义生成一个.class字节码文件
    一个java源文件当中定义public的class的话，public 的class只能有一个
                ，并且该类名必须和java源文件名称一致

标识符的命名规则：
    只能由数字、字母、下划线、美元符号$组成，不能有其他符号；
    不能由数字开头；
    关键字不能做标识符；
    理论上无长度限制，但也不要过长


变量
    变量是由数据类型、变量名、字面值组成；局部变量需要初始化后方可访问，否则报错；
        成员变量未赋值时，系统会默认赋值
        默认值
            byte、short、int、long   0
            float、double            0.0
            boolean                 false（在c语言中，true是1，false是0）
            char                    u\0000


数据类型
    作用：不同数据类型的数据占用空间大小不同，所以数据类型的作用是指导jvm运行程序时给该数据分配多大的内存空间

    分类：分基本数据类型和引用数据类型(包含字符串、类、接口、数组.......)

    基本数据类型：四大类和八小种
        第一类：整数型
            byte、short、int、long
        第二类：浮点型
            float、double
        第三类：布尔型
            boolean
        第四类：字符型
            char
83
64 32 16 8 4 2 1
1  0  1  0 0 1 1
    字符串不属于基本数据类型，属于引用类型，字符属于基本数据类型

    基本数据类型               占用空间大小(单位：字节)
    ----------------------------------------------
    byte                        1
    short                       2
    int                         4
    long                        8
    float                       4
    double                      8
    boolean                     1
    char                        2

    计算机在任何情况下都只能识别二进制

    字节：
        1 Byte = 8 bit 一个字节等于8个比特位（一个比特位表示一个二进制位）
        1 G = 1024*1024*1024*8 的比特位，就只能存这么多0或者1

        二进制位最左边的数字为0表示正数，1表示负数

    byte类型取值范围 -128 ~ 2^7 - 1 = 127
    short类型取值范围 -2^15 ~ 2^15-1
    int类型取值范围 -2^31 ~ 2^31-1
    每一种组合的二进制就是一个数字
    ...........

    java语言中表示一个整数时有三种表达方式，
    十进制   默认方式
    八进制  以0开始
    十六进制    以0X开始

    java语言中整数字面值被默认当作int类型来处理，要让这个整数型的字面值被当作long类型来处理的话需要在字面值后面加一个l/L，建议大写L
    long s = 2147483648;
    2147483648 一开始就被默认为int类型，但是int类型最大值是2147483647，所以这个数字本身就
    溢出了，报错，所以要在后面加一个大写L，这样这个数字就会自动转换为long类型

    大容量的数字类型不能直接赋值给小容量，需要进行强制转换，即加上强制转换类型符；
    但是运行阶段可能损失精度
    强转原理：
        元数据：00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100
        墙砖后数据：00000000 00000000 00000000 01100100
        将左边的二进制去掉（所有数据强转都是这样），计算机内部都是保存的补码形式
        正数的原码、反码、补码都是一样的，但是负数 的不一样，
        原码：将最高位作为符号位（0表示正，1表示负），其它数字位代表数值本身的绝对值的数字表示方式。

        反码：如果是正数，则表示方法和原码一样；如果是负数，符号位不变，其余各位取反，则得到这个数字的反码表示形式。

        补码：如果是正数，则表示方法和原码一样；如果是负数，则将数字的反码加上1（相当于将原码数值位取反然后在最低位加1）。

    byte、short以及char类型在赋值时，虽然字面值是int类型，但是不需要强转，因为sun公司给与了优待，
    只要是在类型的取值范围类都可以编译通过，但是只要超过了就会编译报错

    当计算机碰到字符类型时传统的转换为二进制就会出问题，因为数字和二进制之间的转换规则制定好之后
    就可以简单的转换；但是字符和二进制之间的转换没有指定规则于是乎就会出问题；
    所以就出现了编码方式，例如Ascill、utf-8、gbk等等；

    编码
        unicode编码方式统一了全球所有文字，容量较大；它的编码方式有多种实现：
            utf-8
            utf-16
            utf-32
            ......

        java语言使用的时utf-8编码，所以标识符可以使用中文

    空格符和制表符是不同得分asicll码

    \是转义字符，放在特殊字符之前会将特殊字符转变为普通字符

    浮点型类型详解
    float 单精度（4字节）
    double 双精度（8字节）
    double的精度也还是比较低，不适合做财务软件，涉及到钱的问题，所以sun在基础se类库中为程序员准备了精度更高的
    数据类型，只不过这是一中引用数据类型，不属于基本数据类型，他就是
    java.math.BigDecimal

    se类库字节码：jdk/jre/lib/rt.jar
    源码：jdk/src.zip

    java语言中，所有的浮点类型的数据字面值都被默认为double来处理，要想以float类型来处理，
    需要在字面值后以f/F来标识

    注意：
        在计算机中，double和float都是存储的近似值


   基本数据类型之间的相互转换
        1、八种基本数据类型除布尔类型外，其他都可以相互转换
        2、小容量向大容量转换，可自动转换
            byte<short<int<long<float<double
            byte<char<int<long<float<double
            注意：任何浮点型都比整数型容量大；char和short可表示的种类数量相同，但是char可以取更大的正整数
        3、大容量转小容量时需要强制类型转换，可能会损失精度
        4、byte、short、char混合运算时，各自先转换成int类型再做运算，结果也就是最大容量类型
        5、多种数据类型混合运算时，先转换成最大容量的那种类型再进行运算，结果也就是最大容量类型。
        double a = 10.0/3  结果是3.3333333335


算术运算符
    ++
        1、++运算符可以出现在变量前以及变量后，只要运算结束，该变量都会自加1；
        2、++出现在变量后的话：先做赋值运算，然后再自行加1
            int a = 100;
            int b = a++;

            a = 101,b=100

           ++出现在变量前面：先做自行加1运算，然后再进行赋值操作
           int m = 100;
           int n = ++ m;

           m=101,n = 101


        逻辑运算符
            &   逻辑与
            |   逻辑或
            !   逻辑非
            ^
            &&  短路与
            ||  短路或

            & 和 &&  以及  | 和 || 其实运算的结果都是一样的，区别见下：
            a & b 运算时，a和b都会运算
            a && b 运算时，如果a已经判定为true，b就不会运算




while循环语句可能执行0次；但是do while 最起码执行一次；

for循环三个表达式中特殊情况
    第二个表达式为空，默认是true，无限循环，除非break；
break语句使用在for,while,do...while循环语句跳出循环；
默认情况下，break语句中断时距离它最近的循环语句;但是也可以给循环语句起名，用来中断指定的循环语句
           a:for (int j = 0; j < 10; j++) {
                b:for (int l = 0; l < 5; l++) {
                    System.out.println(l);
                    if (l == 3) {
                        break a;
                    }
                }
            }


方法詳解
    在jvm内存裏有這樣三块主要内存空间，（当然除了这三块内存还有其他内存空间）
    *方法去内存
    *堆内存
    *栈内存

    关于栈(stack)的数据结构
        栈属于先进后出，后进先出的数据结构；
        栈帧永远指着栈顶元素；
        栈顶元素保持活跃，其他元素静止


    方法代码片段存在哪里？方法执行的时候执行内存的过程在那里分配？
        *方法代码片段属于.class字节码文件的一部分，字节码文件再类加载的时候，将其放到
        了方法区当中，所以jvm中的三块主要的内存空间中方法区内存最先有数据，存放了代码片段。

        代码片段 虽然在方法区内存中只保留一份，但是可以被重复利用；每次调用方法的时候，需要给该方法分配独立的活动场所
        在栈内存中分配（栈内存中分配方法运行所属的内存空间）

        方法在调用的瞬间会给该方法在栈内存分配内存空间，并且发生压栈动作（分配内存空间），(方法执行就是栈帧的特点，只有栈帧保持活跃，其他方法静止，也就是其他元素静止)方法结束后发生弹栈工作（释放内存空间）
        局部变量在‘方法体’中声明，局部变量运行阶段的内存在栈中分配




方法重载(overload)
    *在同一个类中
    *方法名相同
    *参数列表不同
        数量不同
        类型顺序不同
        类型不同
    方法重载只和方法名+参数列表有关系；和返回值类型无关，修饰符列表无关


递归
    方法自己调用自己；
    递归必须有结束条件，没有结束条件一定会发生栈内存溢出，jvm停止工作；
    递归即使有了结束条件，即使结束条件是正确的，也有可能发生栈内存错误，因为递归的太深了



对象的创建
    成员变量又叫做实例变量，不创建对象，实例变量的内存空间是不存在的，只有创建了实例对象，实例变量的内存空间才会创建；

    创建对象：new 类名();

    new 是java语言中的一个运算符，作用是创建对象，在jvm堆内存中开辟新的内存；

    方法区内存：在类加载的时候，class字节码代码片段被加载到该内存空间当中；

    栈内存(局部变量)：方法代码片段执行的时候，会给该方法分配内存空间，在栈内存中压栈，局部变量的基本数据类型字面值保存在栈内存；

    堆内存：new的对象在堆内存中存储；

    局部变量在栈内存中存储；引用保存的是内存地址，所以引用类型的局部变量实际被赋值的是内存地址；

    java语言中，程序员不能直接操作堆内存，程序员只能通过“引用”区访问对象内部的实例变量

    引用之间的赋值其实就是内存地址的赋值；

    内存总结
        1、jvm只要包括三块内存：堆内存、栈内存、方法区内存
        2、堆内存和方法区内存各有一个，一个线程一个栈内存
        3、方法调用的时候，该方法所需要的内存空间在栈内存中分配，称为压栈；方法执行结束后，该方法所属的内存空间释放，称为弹栈
        4、栈中主要存储的是方法体当中的局部变量
        5、方法的代码片段以及整个类的代码片段都被存储到方法区内存当中，在类加载的时候这些代码片段会载入；
        6、在程序执行过程中使用new运算符创建的java对象，存储在堆内存当中；
            对象内部有实例变量，所以实例变量存储在堆内存当中；
        7、变量分类
            局部变量 如果使用的话，必须赋初始值
            成员变量
                实例变量
                静态变量
        8、静态变量存储在方法区内存当中
        9、三块内存中变化最频繁的是栈内存，最先有数据的是方法区内存，垃圾回收器主要针对的是堆内存；
        10、垃圾回收机制，什么时候会考虑将某个Java对象的内存回收呢
                当堆内存当中的java对象称为垃圾数据的时候，会被垃圾回收器回收
                当没有更多的引用的指向它的时候，就会变成垃圾


this关键字
    使用在方法当中，this使用在构造方法当中，通过当前的构造方法调用其他的构造方法，语法:this(实参)；
    重点记忆：this这种语法出现在构造函数时，只能出现在构造函数第一行;

    所有静态数据都可以采用类名.也可采用引用.，但是建议类名.访问；
    采用引用的方式访问的时候即使引用为空也不会空指针异常，因为访问静态数据根本不需要对象的存在；

    this能出现在实例方法和构造方法中
        语法是this.  this()
        this不能使用在静态方法中
        this大部分情况可以省略，省略情况下是this.
        this
        this()出现在构造方法中时，只能出现在第一行，


super关键字
    super(实参)作用是：初始化父类型特征，super. 可访问属性以及方法
    super能出现在实例方法和构造方法中
    语法是super.  super()；
    super不能使用在静态方法中
    super大部分情况可以省略
    super 子类和父类可以有同名属性，因为在不同的内存空间；子类中有和父类同名的属性，希望在子类属性中访问父类的属性，不能省略super
    super()出现在构造方法中时，只能出现在第一行，通过当前的构造方法区调用父类中的构造方法，目的是：代码复用
    this和super不能共存在构造器中

    重要结论
        当一个构造器第一行
            既没有this()有没有super()，默认会有一个super();
            表示通过当前字类的构造器调用父类的无参构造器，
            所以必须保证父类的无参构造器必须存在；
            super不是引用，也不保存内存地址，也不指向任何对象，他只代表当前对象内部的那一块父类型的特征；
访问控制权修饰符
    Public  所有地方均可被访问
    protected  同包以及子类可被访问
    default     同包下可被访问
    private     本类中可被访问

ping命令
    如何查看两台计算机是否可以正常通信
        可以使用ping命令
            ping ip/域名
            ping ip/域名 -t 这个命令会一直ping


方法重写
    什么条件构成方法重写
        1、两个类必须有继承关系
        2、重写之后的方法和之前的方法具有：
            相同的返回值类型
            相同的方法名
            相同的形参
        3、访问权限不能更低，可以更高
        4、重写之后的方法不能比之前的方法抛出更多的异常，可以更少

    注意事项
        1、方法覆盖只针对于方法，和属性无关
        2、私有方法无法覆盖
        3、构造方法因为无法继承，素以也不能被覆盖
        4、方法只针对于实例方法，静态方法覆盖没有意义
        5、静态方法不能被重写
        非静态方法可以调用静态方法，但是静态方法不能调用非静态方法

多态指的是：
    夫类型引用值类型对象
    包括编译阶段和运行阶段
    编译阶段：绑定父类的方法
    运行阶段：动态绑定子类型对象的方法
    多种形态

父类里一定要有无参构造方法

instanceof
    1、可以在运行阶段动态判断引用指向的对象的类型
    2、语法：引用 instanceof 类型
    3、运算结果 boolean类型



final关键字
    1、可修饰变量、方法、类
    类：
        B类继承A类，相当于对A类的功能进行了扩展，如果你不希望别人对A类进行扩展，你可以对A类加上final关键字，这样的话A类就无法继承了
    方法：
        final修饰的方法无法被重写；

    变量：
        final修饰的变量只能赋值一次值；
        final修饰的引用一旦指向某个对象，则不能再重新指向其他对象，但是该引用指向的对象内部的数据是可以修改的
        final修饰的实例变量必须手动初始化，不能采用系统默认值；
        final修饰的实例变量一般和static联合使用，称为常量；
        常量和静态变量都放在方法区，并且再类加载时初始化

抽象类和接口以及抽象类和接口的区别
    抽象类：抽象类无法实例化，抽象类是类和类之间有共同特征，将这些具有共同特征的类再进一步进行抽象就形成了抽象类；由于类本身
           是不存在的，所以抽象类无法创建对象；
           抽象类属于什么类型：抽象类也属于引用数据类型；
           抽象类如何定义：【修饰符列表】 abstract class {
                    类体
           }

           抽象类由于无法实例化，无法创建对象，所以抽象类是用来被字类继承的

           抽象类的字类仍然可以是抽象类
           抽象类虽然无法实例化，但是抽象类有构造方法，这个构造方法是供子类使用的；
           抽象类关联到一个概念：抽象方法，抽象方法表示没有实现的方法，没有方法体的方法就是抽象方法；
           抽象类中可以没有抽象方法，抽象方法必须存在抽象类中；
           一个非抽象的类继承了抽象类，必须将抽象类中的方法重写，否则会报错；
           抽象类 a = new 子类()；这个是可以的，向上转型
    抽象类的作用：降低接口的实现类对接口实现的难度，将接口中不需要使用的方法交给抽象类进行空实现，或者一些简单的逻辑，
                这样接口的实现类只需要对接口中需要实现的方法进行重写

    接口：
        1、接口也是一种引用数据类型，编译之后也是一个class字节码文件
        2、接口是完全抽象的（抽象类是半抽象），也可以说接口是特殊的抽象类
           【修饰符列表】 interface 接口名{

           }
        3、接口支持多继承
        4、接口中只包含两部分内容：一部分是常量，一部分是抽象方法
        5、接口中所有的元素都是public修饰的；
        6、接口中所有的抽象方法的public abstract修饰符都可以省略;常量的public static final也可以省略
        7、一个类可以同时实现多个接口
        8、抽象类实现接口时，可以不对接口中的方法进行实现


Object类
    finalize():这个方法没有方法体，且是由protected修饰的
    这个方法不需要程序员手动调用，jvm垃圾回收器负责调用这个方法
    这个方法其实是为程序员提供的一个时机，程序员可以当垃圾回收的时候在这个地方写代码

    hashcode方法返回的是哈希码：实际上是一个java对象的内存地址经过哈希算法得出一个值，
    所以hashcode()方法的执行结果可以等同看作一个对象的内存地址

静态方法以及属性和该类的对象没有关系，即使使用对象的引用调用静态属性或者方法，也是使用的类调用

匿名内部类
    1、什么是内部类
        在类的内部由定义了一个新的类，被称为内部类

    2、内部类的分类
        静态内部类：类似于静态变量
            内部类前面有static修饰
        实例内部类：类似于实例变量
            内部类前面没有static修饰
            语法：new 外部类().new 内部类()
        局部内部类：类似于局部变量
            在方法体的内部的内部类

    3、使用内部类编写的代码可读性很差，能不用就不用
    4、匿名内部类是局部内部类的一种
        因为这个类没有名字，所以叫做匿名内部类

        表面上看上去好像是可以new接口了，实际上并不是接口可以new了，后面的大括号代表了对接口的实现
        new 接口(){
            对接口方法的实现
        }

        不建议使用匿名内部类，因为一个类没有名字，没有办法是用，代码也乱，可读性太差


数组
    数组也是一种引用数据类型，父类是Object
    数组是一种容器，可同时容纳多个容器；数组可以存储基本数据类型，也可以存储引用数据类型
    因为数组是引用数据类型，所以数组对象是存储在堆内存中的
    存储引用数据类型时是将引用数据类型的对象的内存地址存放到数组中
    数组一旦创建，在java中规定，长度不可变
    数组的分类：一维数组、二维数组、多维数组(一维数组较多)
    所有的数组都有length属性，用来获取数组的长度
    java中规定数组要求数组中的元素类型必须统一
    数组在内存方面存储的时候，数组中的元素内存地址是连续的，紧挨着的，这是数组存储的特点
    数组实际上是一种简单的数据结构
    所有的数组都是拿第一个元素的内存地址作为整个数组对象的内存地址
    下标从0考试，最后一个小标  length - 1
    数组的优缺点
        优点：1、查询/查找检索效率高
                原因：每一个元素的内存地址在空间上是连续的
                      每一个元素类型相同，所以占用空间大小一样
                      知道第一个元素内存地址，每一个元素占用空间的大小，又知道下标，所以通过一个
                      数学表达式就可以计算出某个下标上的元素的内存地址，直接通过内存地址定位元素，所以检索效率极高

        缺点：1、由于为了保证数组中每个元素的内存地址连续，所以在数组上随机删除增加元素的时候，效率极低
             因为会导致后面的元素统一的向前或向后的位移

             2、数组不能存储大数据量，因为很难在内存空间中找到一块特别大的连续的内存空间地址


        注意：数组对最后一个元素的增删，效率上是没有影响的

        语法：
            静态初始化语法：int[] array = {100,200,300};
            动态初始化语法：int[] array = new int[3]; 每个元素默认值0，引用类型默认值为null

             Customer[] arry  = {new Customer(),new Vip()};这样的语法是可以的；
             Customer aa = arry[0];
             Customer bb = arry[1];

             aa.shop(); 结果是customer
             bb.shop(); 结果是vip


        数组的扩容
            数组满了需要扩容；扩容是：
                先新建一个大容量的数据，然后将一个小容量数组中的数据一个个拷贝到大数组当中
                数组扩容效率较低

            扩容方法：
                System.arraycopy(Object src（源数组）,  int  srcPos（源数组希望拷贝的起始下标）,
                                                        Object dest（目标数组）, int destPos（希望拷贝到目标数组的哪个小标）,
                                                        int length（拷贝多长）)

      二维数组：
        语法：int [][]k = new int[i][j]
        对于二维数组k来说   i这个位置必须赋值，而j 这个位置 可以赋值 也可以空着不赋值。

      Arrays.binarySearch(int[] a, int key)  二分法查询指定元素时，数组必须是已经被排序好的

BigDecimal：java.math.BigDecimal
    属于大数据，精度极高，不属于基本数据类型，数据java对象（引用数据类型）
    财务软件中double是不够用的


序列化和反序列化：
    序列化：Java对象存储到文件中，拆分Java对象并给每一个拆分的对象进行编号然后传输到硬盘文件后再进行组装，将java
           对象状态保存下来的过程
    反序列化：将硬盘上的数据重新恢复到内存当中，恢复成java对象

    参与序列化和反序列化的对象必须实现Serializable接口，这个接口起到标识的作用,会为该类自动生成一个序列化版本号

    java虚拟机识别一个类的时候先通过类名（包名+类名），然后再通过序列号（如果实现Serializable接口）
    序列化版本号作用是区分类的,所以还是给类生成一个序列化版本号，idea可自动生成

Transient关键字:
    如果对象的某个属性你不希望序列化，就可以在这个属性前加上这个关键字


String字符串：
    1、在java中使用双引号括起来的都是string对象
    2、java中规定，使用双引号括起来的字符串，例如"ad"从出生到死亡都是不可变的
    3、在java中双引号括起来的字符串都是直接存储在方法区的常量池中的
    4、因为字符串使用太频繁，为了执行效率，所以把字符串放到了方法区的字符串常量中
    5、new出来的string对象肯定是在堆内存中开辟内存空间,然后111还是在常量池中开辟空间，但是堆内存中会保存这个"111"在常量池中的内存地址
        String a = new String("111");
        只要被双引号括起来的字符串，肯定在常量池中有一份

        String s1 = "11";
        String s3 = "11";
        System.out.println("result===="+(s1==s3)); 比较的是常量池的地址 true

        String s4 = new String("22");
        String s5 = new String("22");
        System.out.println("result2===="+(s4==s5)); 比较的是对内存的地址 false

        垃圾回收器是不会回收常量的内存的

String.compareTo()方法：
    按照字典顺序比较，前小后打的原则
    "a".compareTo("a") =0
    "a".compareTo("b") <0 因为a在前，b在后，前小后大

StringBuffer()是线程安全的，StringBuilder()是线程不安全的

StringBuffer底层实际上是一个char数组，往StringBuffer放字符串实际是放到字节数组中
String在频繁连接字符串时，操作过程是先生成"ab"字符串，在内存中占一个位置，然后在和"c"组成"abc"字符串;
String s = "a" + "b" + "c";
//而StringBuffer是一个个放到字符数组中，最后tostring时将数组中的内容拼接起来然后放到new String()里生成字符串；
主要是StringBuffer底层的字节数组没有final修饰
StringBuffer s2 = new StringBuffer();
s2.append("a");
s2.append("b");
s2.append("c");


包装类
    java为八种基本数据类型提供了包装类
    因为八种基本数据类型不够用


     Integer ins = new Integer(4);
     4这个基本数据类型进行构造方法的包装达到了：基本数据类型向引用数据类型的转换
     基本数据类型向引用数据类型的转换称为装箱
     int i = ins.intValue();（还有很多类似的方法可以看看）引用数据类型转换为基本数据类型的过程称为拆箱

     自动装箱和自动拆箱
        自动装箱：Integer ins = 4;
        自动拆箱：int y = ins;

     有了自动拆箱之后，Number类里的方法（intValue()....）就用不着了

    java为了提高执行效率，将-128到127之间所有的包装对象提前创建好，
    放到一个方法区的整数型常量池，目的是只要用这个区间的数据就不需要再new了，直接从常量池中获取
    Integer a1 = 128;
    Integer b1 = 128;
    System.out.println(a1 == b1); false

    Integer a2 = 127;
    Integer b2 = 127;
    System.out.println(a2 == b2); true


Random随机类：
    Random r = new Random();
    //产生【0-100】之间的正整数
    int i3 = r.nextInt(101);参数使最大值边界，不包括边界
    System.out.println(i3);

枚举类型：
    枚举编译之后也是CLASS文件，枚举是一种引用数据类型，枚举中的每一个值可以看作是常量
    语法：
        enum 枚举类型名 {
            枚举值1,枚举值2
        }


编译时异常和运行时异常都是发生在运行阶段。编译阶段异常是不会发生的；
    编译时异常因为什么而得名？
    编译时异常不是说编译时就发生异常，而是说编译时异常必须在编译阶段预先处理，如果不处理，编译器会报错，因而得名；
    所有异常都是在运行阶段发生的，因为只有程序运行阶段才可以new对象，因为异常的发生就是new异常对象；

    编译时异常和运行时异常的区别
        1、编译时异常发生的概率比较高，运行时异常发生的概率比较低


    所有Exception的直接子类，都叫做编译时异常，编译时异常又被叫做checked异常
    所有RuntimeException以及子类都属于运行时异常，也可以称作unchecked异常，运行时异常在编写程序阶段，你可以选择处理也可以不处理

try catch finally 语法中这三个部分，catch和finally都可以单独没有，但是不可以都没有

发生异常时，被try catch finally包裹的方法之后的代码是不会执行的，finally内的代码是必定会执行的，不管有没有发生异常；
finally里面的代码执行完后；
finally后面的代码，理论上如果try没有return，catch抛出异常或者return，或者finally里return的话，是可以正常执行的



集合
    1、集合中不能直接存储基本数据类型，另外集合也不能存储JAVA对象，集合中存储的都是内存地址或者说是引用
    2、在java中，集合中分为两大类
        一类是单个方式存储元素，这一类集合的超级父接口：java.util.Collection
        一类是以键值对方式存储元素，这一类集合中超级父接口：java.util.Map
    所有集合继承iterable的含义是：所有集合都是可迭代的

    List和Set是Collection的子接口

    List：
        list集合存储元素的特点：有序可重复，存储的元素有下标。这里的有序不是按照大小顺序而是存进去的顺序
        List接口特有方法
            add(int var1, E var2)
           int lastIndexOf(Object e)
           set(int var1, E var2) 用指定元素替换指定索引上的元素



        ArrayList：
                底层采用数组这种数据结构，这个集合是非线程安全的；频繁检索以及往末尾添加元素的话使用这个集合
                默认初始化容量是10；Object数组
                ArrayList集合的扩容
                ，原容量的1.5倍
                尽可能少的扩容ArrayList集合，因为扩容效率较低，建议在使用ArrayList集合的时候与孤寂元素的个数，给定一个初始容量
                集合的检索效率高，因为底层是数组，数组的类型，个数都是知道的，所以计算内存地址很高效，随机增删元素的效率较低，但是往末尾添加元素的效率较高
                a >> b 将a转化为对二进制位然后去掉末尾b位数，然后再转化为十进制

                a << b就表示把a转为二进制后左移b位（在后面添b个0）。例如100的二进制为1100100，而110010000转成十进制是400，
                那么100 shl 2 = 400。可以看出，a shl b的值实际上就是a乘以2的b次方，因为在二进制数后添一个0就相当于该数乘以2。

                Collection c2 = new HashSet<>();
                ((ArrayList) c2).add(0);
                ((ArrayList) c2).add(1);
                ((ArrayList) c2).add(2);
                ((ArrayList) c2).add(3);
                //通过这个方法可以将hashset转化为arraylist
                ArrayList c3 =  new ArrayList(c2);

        LinkedList：
            底层采用了双向链表数据结构,没有初始化容量，频繁增删使用这个集合；检索效率较低，空间存储上不连续；

            单向链表数据结构：对于链表数据结构来说，基本的单元是节点Node；对于单向链表来说，任何一个节点Node都有两个属性
                                        第一：存储的数据
                                        第二：下一个结点的内存地址

                                        优点：随机增删元素效率较高（因为链表上的元素在空间存储上内存地址不连续，所以增删元素不涉及大量元素位移）
                                        缺点：查询效率较低，每一次查找元素时都需要从头节点往下遍历

                        双向链表数据结构：基本单元还是节点Node，每一个节点Node有三个属性
                                        第一：存储的数据
                                        第二：上一个节点的内存地址
                                        第三：下一个节点的内存地址


        Vector:
            底层是采用了数组数据结构，线程安全的，Vector所有方法都有synchronized，但是效率较低，现在保证线程安全有别的方案
            ，所以vector使用较少了
            扩容之后是原容量的2倍；

            如何将arrayList变成线程安全的
                ArrayList c3 =  new ArrayList(c2);
                Collections.synchronizedList(c3);//这样c3就变成线程安全的









    Set：
        Set集合存储元素的特点：无序不可重复。Set集合中元素不可重复且元素灭有下标

        HashSet：实际上new hashSet的时候底层是new 了一个hashMap，向hashSet里存储元素的实际上是存储到hashMap集合中
                hashMap的数据结构是哈希表

        TreeSet:底层实际上是TreeMap，new TreeSet的时候，实际上是new了一个TreeMap集合，往TreeSet存储元素的时候实际上是
                往TreeMap集合的key部分里添加元素，TreeMap集合底层采用了二叉树结构；treeset无序不可重复，但可以按照元素大小顺序自动排序

                自平衡二叉树数据结构：
                    1：自平衡二叉树，遵循左小右大原则存放
                    2：遍历二叉树有三种方式：
                        前序遍历：根左右
                        中序遍历：左根右
                        后序遍历：左右根
                      注意：前中后说的是“根”的位置

                TreeSet/TreeMap集合 采用的是：中序遍历方式
                    Iterator迭代器采用的是中序遍历方式，左根右


        SortedSet:无需不可重复，但是集合中的元素可以自动按照某种规则自动排序，称为排序集合，放到该集合中的元素自动按照大小排序


        Collection集合元素删除
            迭代器删除
             Collection c = new ArrayList();
            ((ArrayList) c).add(0);
            ((ArrayList) c).add(1);
            ((ArrayList) c).add(2);
            ((ArrayList) c).add(3);
            Iterator iterator = c.iterator();
            while (iterator.hasNext()){
                Object next = iterator.next();
                //c.remove(next);  在迭代集合元素的过程中，这样删除元素后集合结构发生变化，注意Collection集合结构只要发生变化 迭代器一定要重新获取
                iterator.remove(); 删除元素时用迭代器删除
                System.out.println(next);
            }

    Map：
        map集合和collection集合没有关系
        key和value都是存储java对象的内存地址
        所有Map集合的key特点：无序不可重复
        Map集合的key和Set集合存储元素的特点是相同的
        key起到主导作用，value是key的一个附属品

        Map接口中常用方法:



        hashMap:底层是哈希表/散列表数据结构，数组初始容量16，扩容因子：0.75，达到75%的时候会开始扩容，扩容最好是2的倍数，可以达到散列分布均匀；非线程安全的；
            哈希表数据结构：是数组和单向链表的结合体；是一个一维数组，这个数组中的每个元素是单向链表；单向链表里的节点有4个属性
                            第一个哈希值（哈希值是key的hashCode()方法执行的结果，哈希值通过哈希算法转换成数组下标）
                            第二个key
                            第三个value
                            第四个 下一个节点的内存地址
                数组：在查询方面效率很高，随机增删效率较低
                单向链表：在查询方面效率很低，随机增删效率较高
            哈希表将以上两种数据结构结合在一起，充分发挥他们的优点
                map.put(key,value)的原理：
                    第一步：先将key,value封装成Node对象当中
                    第二步：底层会调用key的hashcode()方法得出哈希值，然后通过哈希算法将哈希值转换成数组的下标，下标位置上
                           如果没有任何元素，就把Node添加到这个位置上了；如果下标对应的位置上有Node（链表），此时会拿着key和
                           这个数组下标上的链表上的每一个key进行equals，如果都返回false，那么将这个Node将被添加到链表的末尾，
                           如果其中有一个equals返回了true，那么这个节点的value将会被覆盖；

                           jdk8之后：如果哈希表单向链表中元素超过8个，单向链表数据结构会变成红黑树数据结构，当红黑树上的节点数量小于6时，
                           会重新把红黑树变成单向链表数据结构；这种方式其实也是为了检索效率，二叉树的检索范围会再次缩小，提高了效率

                map.get(key)的原理：
                    先调用hashcode()方法得出哈希值，通过哈希算法得出数组下标，通过数组下标快速定位到某个位置上；如果这个位置上什么也没有，
                    返回null；如果这个位置上有单向链表，那么会拿着这个参数key去和单向链表上的每个key进行equals，如果equals都返回false，那么返回null；
                    只要其中一个返回true，那么此时这个节点就是我们要找的value，get方法返回这个value；
                注意：同一个数组下标上的所有单向链表上的节点的hashcode值相同
                    hashmap的key和value允许null值；
                重点：放在hashMap集合key部分的元素和hashSet中的集合元素，需要同时重写hshCode和equals方法


                为什么哈希表的随机增删以及查询效率都很高：增删是在链表上完成的；查询也不需要都扫描，只需要在某个数组下标上进行扫描链表；

                为什么hashMap的key需要重写hashCode以及equals方法：默认的hashcode方法返回的是内存地址的哈希值；因为equals默认比较的是内存地址，我们应该比较内容；



        hashTble：集合底层也是哈希表数据结构，初始化容量11，默认扩容因子0.75，扩容是原容量*2 +1 ；是线程安全的，所有方法都带有synchronized关键字，效率较低，现在使用较少
                  有一个子类：Propertites（key和value必须是String，线程安全的，称为属性类）

                hashTble的key和value不允许null值；

        SortedTable继承Map，TreeMap实现SortedTtable，TreeMap集合的key可以自动按照大小顺序排序



        Map集合的key其实就是Set的集合下



进程和线程的关系：
    进程和进程内存独立不共享

    在java语言中：
        一个进程中的不同线程，堆内存和方法区内存是共享的，但是栈内存是独立的，一个线程一个栈


    实现线程的第一种方式
        实现Thread类
        Thread t1 = new Mythread();//实现Thread类
        t1.start();//作用是在jvm中新开辟一个新的栈空间，这段代码瞬间就结束了，只要新的栈空间开出来，start()方法就结束了，线程就启动成功了，启动成功的线程会自动调用run方法

        注意：亘古不变的道理，方法体中的代码永远都是从上而下的逐行执行

    第二种方式
        实现Runable接口
            //这并不是一个线程类，只是一个可运行的类
            class Mythread2 implements Runnable{

                @Override
                public void run() {
                    System.out.println("分线程=======");
                }
            }


            Thread t2 = new Thread(new Mythread2());
            t2.start();

    第三种方式
        实现callable接口，这种方式实现的线程可以获取线程的返回值
        之前讲解的两种方式是无法获取线程返回值的，因为run()方法返回的是void
        缺点：效率较低，在获取t线程执行结果的时候，当前线程会阻塞

         //第一步创建一个”未来类“对象
        FutureTask futureTask = new FutureTask(new Callable() {
            @Override
            //相当于run方法，执行会有返回结果
            public Object call() throws Exception {
                System.out.println("call method begin");
                Thread.sleep(10000);
                System.out.println("call method end");
                return 100;
            }
        });

        Thread t = new Thread(futureTask);
        t.start();
        //在主线程如何获取t线程的执行结果
        //主线程会阻塞吗？   会阻塞的，因为必须要等待get方法执行结束，get方法是为了拿另一个线程执行结果
        Object o = futureTask.get();
        System.out.println("分支线程结束了");

    线程的生命周期
        可运行状态-----运行状态（遇到阻塞事件，例如sleep或者用户键盘输入，就会变成阻塞状态，阻塞状态的线程会放弃之前占有的cpu时间片，阻塞结束之后会进入就绪状态，继续抢夺cpu时间片）----死亡状态


    如何获取当前线程的对象
        Thread t = Thread.currentThread()//返回当前线程

    线程的sleep方法
        1、静态方法
        2、参数是毫秒
        3、让当前的(当前的哦)线程进入休眠，阻塞状态，放弃占有的cpu时间片

    终止睡眠线程：
        重点：run()方法中的异常不能throws，只能try catch，因为父类中没有抛出异常

        Thread t2 = new Thread(new Mythread2());
        t2.start();
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        t2.interrupt();//干扰，一盆冷水过去

    线程强制被终止
        stop(),已经过时

    常用和调度有关的方法
        yield()，这是一个静态方法，会使当前线程放弃一个时间片，从运行状态转化为就绪状态
        join()，只是一个实例方法，合并线程，
        System.out.println("========1111111111=========");
        Thread t1 = new Mythread();
        t1.start();
        try {
            t1.join();//当前线程进入阻塞状态，需等待t1执行完，当前线程才可以执行
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("========222222=========");

    关于多线程并发环境下，数据的安全问题
        什么时候会存在安全问题
            1、多线程并发
            2、有共享数据
            3、共享数据有修改行为

        如何解决线程安全问题
            使用线程同步机制，实际上就是线程不能并发了，排队执行

        说到线程同步，涉及两个专业术语
        异步编程模型：线程t1和t2，各自执行各自的，t1不管t2，t2不管t1，谁也不用等谁
        同步编程模型：线程t1和t2，在其中一个执行的时候，另一个必须等待其执行完后才可以执行
            异步就是并发，同步就是排队

        synchronized不要嵌套使用，一不小心就有可能死锁,以下是死锁案例
        public class Test {
            public static void main(String[] args) {
                Object o1 = new Object();
                Object o2 = new Object();
                Thread t1 =new MyThread(o1,o2);
                Thread t2 =new MyThread2(o1,o2);
                t1.start();
                t2.start();
            }
        }

        syncronized代码块出现异常后会自动释放锁
        可以修饰同步代码块，锁对象经常使用该对象，也可以使用运行时字节码文件对象；
        可以修饰实例方法，锁对象经常使用当前对象；
        可以修饰静态方法，锁对象是该类字节码对象，XXX.class
        锁对象不同不能实现线程同步；可以用常量对象作为锁对象

        悲观锁：syncronized以及Lock接口的子类都是悲观锁
        乐观锁：乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，
            才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。
            乐观锁适用于读操作多的场景，这样可以提高程序的吞吐量；
           乐观锁的实现：
           1：CAS 实现：Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。
           2：CAS可能出现ABA问题，所以加入版本号控制会更好

        class MyThread extends Thread{
            Object o1;
            Object o2;
            public MyThread(Object o1, Object o2) {
                this.o1 = o1;
                this.o2 = o2;
            }

            @Override
            public void run() {
                synchronized (o1){
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (o2){
                    }
                }
            }
        }



        class MyThread2 extends Thread{
            Object o1;
            Object o2;
            public MyThread2(Object o1, Object o2) {
                this.o1 = o1;
                this.o2 = o2;
            }
            @Override
            public void run() {
                synchronized (o2){
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (o1){
                    }
                }
            }
        }

守护线程
    Java语言中线程分为两大类：
        一类是用户线程，一类是守护线程（后台线程）
        其中是守护线程具有代表性的是垃圾回收器

        守护线程的特点：
            一般守护线程是一个死循环，所有的用户线程都结束后，守护线程自动结束
            main线程属于用户线程

            守护线程用在什么地方
                每天零点的时候，数据自动备份
                这个需要用到定时器，定时器其实也是一个线程，并且我们可以将定时器设置成守护线程

            Thread t1 =new MyThread();
            t1.setDaemon(true);//只要设置这个，t1线程就会变成守护线程，所有的用户线程都结束后，守护线程自动结束
            t1.start();
            for (int i = 0; i < 10; i++) {
                System.out.println("主线程========"+i);
            }


    关于Object类中的wait方法和notify方法（生产者和消费者模式）
    第一：wait和notify方法不是线程对象的方法，是java中任何一个java对象都带有的方法，因为是Object自带的
    第二：wait方法作用
        Object o = new Object();
        o.wait();//会让当前线程进入等待状态，并且会释放之前占有的o对象的锁
        表示：让正在o对象上活动的线程进入等待状态，无期限等待，直到被唤醒为止
    第三：notify方法作用
        Object o = new Object();
        o.notify();
        表示：让正在o对象上活动的线程被唤醒，不会释放之前占有的o对象的锁

        还有一个方法：notifyAll() 这个方法是唤醒o对象上处于等待的所有线程


    线程安全问题表现为三个方面
        1、原子性
            1)访问(读写)某个共享变量的操作从其他线程来看，该操作要么已经执行完毕，要么尚未发生，即其他线程看不到当前操作的中间结果
            2)访问同一组共享变量的原子操作是不能交叉的
        2、可见性
            在多线程环境中，一个线程对某个共享变量进行更新之后，后续其他的线程可能无法立即读到这个更新的结果，这就是可见性
        3、有序性
            有序性是指在什么情况下一个处理器上运行一个线程所执行的内存访问操作在另外一个处理器运行的其他线程看来是乱序的；
            乱序是指内存访问操作的顺序看起来发生了变化；

        volatile的作用：强制线程从公共内存中读取数据而是不是从工作内存中读取；解决了线程的可见性问题；
                        而synchronized解决的是多个线程之间访问公共变量的同步性
                        volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好；
                        volatile只能修饰变量
                        多线程访问volatile变量不会发生阻塞；volatile可以保证数据的可见性，但是不能保证原子性；

ThreadLocal
    ThreadLocal主要是解决为每个线程绑定自己的值,每次获取值的时候都是从当前线程里面去获取值，设置值的时候是从当前线程里设置值
    子类可以继承ThreadLocal后然后可以重写initialValue方法，改变他的初始值

Lock显示锁
    有ReentrantLock(可重入锁)实现类，他功能比synchronized多

    锁的可重入是指：当一个线程获得一个对象锁后，再次请求该对象的锁时是可以获得该对象的锁的


        ReentrantLock
            基本使用
                需要保证ReentrantLock对象是一致的，这样才能保证线程同步

        ReentrantReadWriteLock
            允许多个线程同时读取共享数据，但是一次只允许一个线程对共享数据进行写操作；
            线程在读取共享数据之前必须先持有读锁，读锁可以同时被多个线程同时拥有，线程在修改共享数据之前
            必须先持有写锁，写锁是排他的，一个线程持有写锁时，其他线程无法获得相应的锁；
            读锁只在读线程之间共享，任何一个线程持有读锁时，其他线程都无法获得写锁，保证线程在读取数据期间没有其他线程
            对数据进行更新；一个线程获得读锁时，写线程等待；一个线程获得写锁时，其他线程等待

            readLock():这个方法返回读锁

            writeLock()：这个方法返回写锁

            这两个方法返回的锁对象时同一个锁的两个不同角色，不是分别获得两个不同的锁

类加载器
    类加载器就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。如果站在JVM的角度来看，只存在两种类加载器:
    启动类加载器（Bootstrap ClassLoader）：由C++语言实现（针对HotSpot）,负责将存放在<JAVA_HOME>\lib目录或-Xbootclasspath
    参数指定的路径中的类库加载到内存中。

    其他类加载器：由Java语言实现，继承自抽象类ClassLoader。如：
        扩展类加载器（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。
        应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。
        一般情况，如果我们没有自定义类加载器默认就是用这个加载器。

    双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器
    完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。


反射机制
    反射机制有什么作用
        通过Java语言中的反射机制可以操作字节码文件，有点类似于黑客(可以读和修改字节码文件)
        通过反射机制可以操作代码片段

    反射机制的相关包在哪个包下
        java.lang.reflect.*

    相关类有哪些
        Class           代表字节码文件，代表一个类型
        Method          代表字节码中的方法字节码，
        Constructor     代表字节码中的构造方法字节码
        Filed           代表字节码中的属性字节码

    要操作一个类的字节码，首先要获取到这个类的字节码，如何获取Class实例？
    三种方式
        第一种：Class.forName()
            注意：这段代码的执行会导致：类加载
            1、静态方法
            2、方法的参数是一个字符串
            3、字符串需要的是一个完整的类名
            4、完整类名必须带有包名

        第二种：java中任何一个对象都有一个方法：getClass()
            Class c1 = Class.forName("java.lang.String"); //c1代表String的字节码文件，class文件
            //c1和sClass引用在栈里直接指向方法区里的String.class文件
            String s = "asd";
            Class<? extends String> sClass = s.getClass();//sClass就代表String.class文件

        第三种方式：在java语言中任何一种类型，包括基本数据类型，都有.class属性
            Class y = String.class;
            Class i = int.class;

        反射获取类的机制比较灵活，可以 做到不同对象额实例化，非常之灵活


    java.util包下提供了一个资源绑定器，便于获取属性配置文件中的内容
    使用这种方式的时候，只能绑定properties文件，属性配置文件必须放到类路径下，写路径的时候，扩展名不用写
    ResourceBundle resourceBundle = ResourceBundle.getBundle("属性文件名");
    String string = resourceBundle.getString("");
    System.out.println(string);


    Filed
        Class<?> aClass = Vip.class;
        Field[] fields = aClass.getFields();//获取的是公共的修饰的属性
        Field[] declaredFields = aClass.getDeclaredFields();//获取所有声明的属性

    反射机制让代码复杂了，但是为了一个灵活，这也是值得 的

注解
    注解是一种引用数据类型，编译之后也是生成class文件
    怎么自定义注解呢？语法格式？

    【修饰符列表】 @interface 注解类型名{

    }


    元注解
        只修饰注解的注解叫做元注解
        常见的元注解有：
            Target
                这是一个元注解，只能用来标注“注解类型”的注解
                这个注解用来标注“被标注的注解”可以出现在哪些位置上
                @Target(ElementType.METHOD):表示“被标注的注解”只能出现在方法上
            Retention
                这是一个元注解，用来标注“注解类型”的注解
                这个注解用来标注“被标注的注解”可最终保存在哪
                @Retention(RetentionPolicy.SOURCE)：表示该注解只被保留在java源文件中
                @Retention(RetentionPolicy.CLASS)：表示该注解只被保留在CLASS文件中
                @Retention(RetentionPolicy.RUNTIME)：表示该注解只被保留在CLASS文件中,并且可以被反射机制所读取

        //我们通常在注解中可以定义属性，一下这个是MyAnnotation注解中的name属性
        //看着像一个方法，但实际我们称之为属性name；如果一个注解当中有属性，那么必须给属性赋值
        //属性有指定默认值时，注解后面的括号里就可以不写这个属性
        //如果有且只有一个属性，名字是value的时候，在使用时，该value属性可以省略

        String name();
        int age() default 28; //属性有指定默认值，注解后面的括号里就可以不写这个属性

        注解当中的属性可以是哪一种类型呢
            八种基本数据类型和枚举类型和String类型和Class类型
            以及以上每种类型的数组

泛型：符号T、E、？代表的意思
    T：一种特定的类型
    E：也是一种类型的意思，只不过通常代表集合中的元素
    ？：这是一种无限的符号，代表任何类型都可以
    K：表示 key-value中的key键
    V：键值对中的value
    N：Number(数值类型)